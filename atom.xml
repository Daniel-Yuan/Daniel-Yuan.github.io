<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel_yuan&#39;s Blog</title>
  
  <subtitle>芙卡米天下第一可爱 n(*≧▽≦*)n</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-06T11:04:25.063Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Daniel_yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>diary</title>
    <link href="http://example.com/2020/10/06/diary/"/>
    <id>http://example.com/2020/10/06/diary/</id>
    <published>2020-10-06T07:34:39.000Z</published>
    <updated>2020-10-06T11:04:25.063Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="用魔法咒语解开它吧。" /><label>用魔法咒语解开它吧。</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="850246bf674e756f51d1713a01cd8f433c89ce1fc3e58ff8f2c456d085384ffe">984bbfaa2a7c0bf6d0de8973694307b32a178af243fd86a248a7eca8db85e9bd77e0b6ec026a5ff119c71b5ba75a3e54f15e5fe06a64855c5859563717ace74c7ab0491527819ccadefb1185b8f2260b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇博客被邪恶的博主用魔法封住了。</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛 70 E 题解</title>
    <link href="http://example.com/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-29T06:59:08.000Z</published>
    <updated>2020-09-29T07:28:41.621Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7509/E">题目链接</a></p><p><strong>题意简述</strong></p><p>定义若二元组 <span class="math inline">\((a,b)&lt;(c,d)\)</span>，则有 <span class="math inline">\(a&gt;c\)</span> 或者 <span class="math inline">\(a=c \text{ and } b&lt;d\)</span>。</p><p>给你 <span class="math inline">\(n\)</span> 个数，第 <span class="math inline">\(i\)</span> 个数是 <span class="math inline">\(a_i\)</span>。</p><p>现在系统会生成 <span class="math inline">\(n\)</span> 个二元组，第 <span class="math inline">\(i\)</span> 个二元组是 <span class="math inline">\((a_i,i)\)</span> 或者是 <span class="math inline">\((a_i+1,i)\)</span>，然后给每个二元组一个排名，设排名数列为 <span class="math inline">\(rk\)</span>。</p><p>求有多少种不同的 <span class="math inline">\(rk\)</span> 数列，两个 <span class="math inline">\(rk\)</span> 序列不同当且仅当存在至少一个位置 <span class="math inline">\(x\)</span>，使得两个 <span class="math inline">\(rk\)</span> 数列的 <span class="math inline">\(rk_x\)</span> 不同。</p><p><span class="math inline">\(n\leq 5\times 10^5,a_i\leq 10^6\)</span>，时空限制：2s 256M。</p><a id="more"></a><p><strong>样例</strong></p><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>解释：有以下八种二元组的搭配方式，以及其相应的 <span class="math inline">\(rk\)</span> 序列。</p><p><span class="math inline">\((1,1),(2,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((1,1),(2,2),(3,3)\ \ \ \ rk:3,2,1\)</span></p><p><span class="math inline">\((1,1),(3,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((1,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((2,1),(2,2),(2,3)\ \ \ \ rk:1,2,3\)</span></p><p><span class="math inline">\((2,1),(2,2),(3,3)\ \ \ \ rk:2,3,1\)</span></p><p><span class="math inline">\((2,1),(3,2),(2,3)\ \ \ \ rk:2,1,3\)</span></p><p><span class="math inline">\((2,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p><p>不同的 <span class="math inline">\(rk\)</span> 序列一共有 <span class="math inline">\(5\)</span> 个。</p><p><strong>题解</strong></p><p>比赛的时候一直认为是一个组合数学题目，没想到是一个 DP。</p><p>先下一个定义：若两个由前 <span class="math inline">\(i-1\)</span> 个二元组形成的序列，无论 <span class="math inline">\([i,n]\)</span> 中的每个二元组是 <span class="math inline">\((a_x,x)\)</span> 还是 <span class="math inline">\((a_x+1,x)\)</span>，这两个序列最终形成的排名序列都是相同的，那么我们把它们称作<strong>不可区分</strong>的。</p><p>首先把所有二元组按照 <span class="math inline">\((a_i,i)\)</span> 排序。为了方便，下文默认输入就已经保证了 <span class="math inline">\((a_i,i)&lt;(a_{i+1},i+1)\)</span>。</p><p>考虑 DP，设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i-1\)</span> 个二元组组成的<strong>可区分</strong>的序列个数。</p><p>那么第 <span class="math inline">\(i\)</span> 个位置既可以放 <span class="math inline">\((a_i,i)\)</span> 也可以放 <span class="math inline">\((a_i+1,i)\)</span>，所以有 <span class="math inline">\(f_{i+1}=2f_i\)</span>，但是这样显然会算重，所以考虑容斥。</p><p>考虑对于一个位置 <span class="math inline">\(i\)</span>，找到一个极短的区间 <span class="math inline">\([l,r](l\leq i\leq r)\)</span>，它需要满足存在一种在 <span class="math inline">\([l,i-1],[i+1,r]\)</span> 放置二元组的方案，使得第 <span class="math inline">\(i\)</span> 个位置放 <span class="math inline">\((a_i,i)\)</span> 和放 <span class="math inline">\((a_i+1,i)\)</span> 是<strong>不可区分</strong>的。这样的话，这种放置方法的贡献本来只有 <span class="math inline">\(1\)</span> 但是被算了两次，所以 <span class="math inline">\(f_r\)</span> 就需要减去 <span class="math inline">\(f_l\)</span>。</p><p>因为这个区间是极短的，所以可以恰好不重不漏地把所有的不合法的方案都减掉，最终的 <span class="math inline">\(f_{n+1}\)</span> 即为答案。</p><p>不难发现，因为我们一开始排好了序，所以 <span class="math inline">\(l,r\)</span> 是单调递增的，<span class="math inline">\(i\)</span> 也是我们单调枚举的，所以 DP 的总复杂度是 <span class="math inline">\(O(n)\)</span> 的。（有趣的是，复杂度的瓶颈在于排序）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, id;</span><br><span class="line">  Node (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _id = <span class="number">0</span>) &#123; x = _x, id = _id; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x ^ A.x ? x &gt; A.x : id &lt; A.id; &#125;;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; read(n);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(a[i].x), a[i].id = i;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; i &amp;&amp; (Node(a[l].x, a[l].id) &lt; Node(a[i].x + <span class="number">1</span>, a[i].id))) ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; (Node(a[r].x + <span class="number">1</span>, a[r].id) &lt; Node(a[i].x, a[i].id))) ++r;</span><br><span class="line">    f[r] = (f[r] + mod - f[l]) % mod;</span><br><span class="line">    f[i + <span class="number">1</span>] = ((f[i] + f[i]) % mod + f[i + <span class="number">1</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  print(f[n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/7509/E&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意简述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义若二元组 &lt;span class=&quot;math inline&quot;&gt;\((a,b)&amp;lt;(c,d)\)&lt;/span&gt;，则有 &lt;span class=&quot;math inline&quot;&gt;\(a&amp;gt;c\)&lt;/span&gt; 或者 &lt;span class=&quot;math inline&quot;&gt;\(a=c \text{ and } b&amp;lt;d\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;给你 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个数，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数是 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在系统会生成 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个二元组，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个二元组是 &lt;span class=&quot;math inline&quot;&gt;\((a_i,i)\)&lt;/span&gt; 或者是 &lt;span class=&quot;math inline&quot;&gt;\((a_i+1,i)\)&lt;/span&gt;，然后给每个二元组一个排名，设排名数列为 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求有多少种不同的 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 数列，两个 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 序列不同当且仅当存在至少一个位置 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，使得两个 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 数列的 &lt;span class=&quot;math inline&quot;&gt;\(rk_x\)&lt;/span&gt; 不同。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\leq 5\times 10^5,a_i\leq 10^6\)&lt;/span&gt;，时空限制：2s 256M。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="容斥" scheme="http://example.com/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="妙题" scheme="http://example.com/tags/%E5%A6%99%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线性代数优化矩阵快速幂</title>
    <link href="http://example.com/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>http://example.com/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-09-26T07:23:28.000Z</published>
    <updated>2020-10-06T10:49:19.832Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们需要求维度为 <span class="math inline">\(c\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 次幂，那么一个显然的方法是用快速幂，复杂度为 <span class="math inline">\(c^3 \log m\)</span>。不过当需要用到高精度的时候，该算法速度会大大下降。</p><p>考虑这么一个事情，<a id="more"></a> 如果可以找到一个矩阵 <span class="math inline">\(C\)</span> 和一个对角矩阵 <span class="math inline">\(P\)</span>（只有主对角线上的值不为 <span class="math inline">\(0\)</span>），使得 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>，那么 <span class="math inline">\(A^m=C\times P \times C^{-1} \times C \times P \times C^{-1}...\)</span>，不断的使用结合率，就可以得到 <span class="math inline">\(C \times P^m \times C^{-1}\)</span>。因为 <span class="math inline">\(P\)</span> 是对角矩阵，那么 <span class="math inline">\(P^m\)</span> 本质上只要对 <span class="math inline">\(P\)</span> 中的每个值跑一个实数的快速幂。这样就可以把复杂度优化到 <span class="math inline">\(c^3+c\log n\)</span>，即实数的快速幂和两次矩阵乘法。</p><p>现在的问题就是怎么得到一个合法的 <span class="math inline">\(C\)</span>。</p><p>引入两个概念：特征值和特征向量。</p><p>一个数 <span class="math inline">\(\lambda\)</span> 是矩阵 <span class="math inline">\(A\)</span> 的特征值，当且仅当存在一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>，使得 <span class="math inline">\(A\times B=\lambda B\)</span>，我们把这个向量 <span class="math inline">\(B\)</span> 称作特征向量。需要注意的是，对于同一个 <span class="math inline">\(\lambda\)</span>，<span class="math inline">\(B\)</span> 可能不止一个。</p><p>如果我们求出了一组特征值 <span class="math inline">\(\lambda_1,\lambda_2...\lambda_c\)</span>，以及对应的特征向量 <span class="math inline">\(B_1,B_2...B_c\)</span>，那么就有 <span class="math inline">\(A\times [B_1,B_2...B_c]=[\lambda_1\cdot B_1,\lambda_2\cdot B_2...\lambda_c\cdot B_c]\)</span>，设 <span class="math inline">\(C=[B_1,B_2...B_c]\)</span>，右乘一个对角矩阵相当于每一列 <span class="math inline">\(i\)</span> 乘上一个对角阵中的元素 <span class="math inline">\(a_{i,i}\)</span>，所以可以构造对角矩阵 <span class="math inline">\(P=\begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots&amp;0\\ 0 &amp; \lambda_2 &amp; \cdots&amp;0\\ \vdots &amp; \vdots&amp;\ddots&amp;\vdots \\ 0&amp;\cdots&amp;0&amp;\lambda_c\end{bmatrix}\)</span>，就可以得到 <span class="math inline">\(A\times C=C\times P\Leftrightarrow A=C\times P\times C^{-1}\)</span> 。</p><p>考虑怎么求特征值，因为 <span class="math inline">\(A\times B=\lambda B\)</span> 那么就有 <span class="math inline">\(\lambda B-A\times B=0\)</span>，所以 <span class="math inline">\((\lambda I-A)\times B=0\)</span>，因为 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span>，所以必须有 <span class="math inline">\(\det(\lambda I-A)=0\)</span>，那么可以通过行列式列方程求得 <span class="math inline">\(\lambda\)</span>。</p><p>考虑使用反证法证明 <span class="math inline">\(\det(\lambda I-A)=0\)</span>。设 <span class="math inline">\(G=\lambda I-A\)</span>，那么如果 <span class="math inline">\(\det(G)\not=0\)</span>，那么如果把 <span class="math inline">\(G\)</span> 看作是一个方程组的系数矩阵，<span class="math inline">\(B\)</span> 为未知数，那么 <span class="math inline">\(B\)</span> 将会是唯一的。而因为等式右边等于 <span class="math inline">\(0\)</span> ，所以无论如何用高斯消元，最后总会有 <span class="math inline">\(B_c=0\)</span>，那么一直往回迭代就会得到一个全 <span class="math inline">\(0\)</span> 向量，与 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span> 冲突。而如果 <span class="math inline">\(det(G)=0\)</span>，那么 <span class="math inline">\(G\)</span> 至少有一个自由元，那么就可以通过自由元，得到至少一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>。</p><p>由此我们就可以求出所有的特征值，对于某个特征值，把它带回矩阵，通过初等矩阵的行变换把它变成一个最简形式，然后把自由元带入任意一个值（一般为 <span class="math inline">\(1\)</span>）就可以得到一个特征向量 <span class="math inline">\(B\)</span>（当然对于任意的 <span class="math inline">\(k\cdot B,k\not=0\)</span> 都是符合要求的）。</p><p>至此就可以得到所有的特征值及其对应的特征向量。那么就可以得到矩阵 <span class="math inline">\(C\)</span>，求个逆就可以得到 <span class="math inline">\(C^{-1}\)</span>（消元可以用辗转相除法，就可以避免求逆元），就可以用上述做法优化了。</p><p>下面就举个栗子，用此方法得到斐波那契数列的通项公式。</p><p>众所周知，斐波那契数列的递推矩阵是 <span class="math inline">\(A=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\ \end{bmatrix}\)</span> 。</p><p>先求出该矩阵的特征值，设其为 <span class="math inline">\(\lambda\)</span>，根据定义，有 <span class="math inline">\(\det \left ( \begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \right) = 0\)</span> ，所以 <span class="math inline">\((\lambda-1)\times \lambda-1=0\)</span>，解出 <span class="math inline">\(\lambda=\frac{1\pm\sqrt{5}}{2}\)</span> 。</p><p>再根据定理，列出方程 <span class="math inline">\(\begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ \end{bmatrix}=\begin{bmatrix} 0 \\ 0 \\ \end{bmatrix}\)</span> 可以解出两个特征向量 <span class="math inline">\(\lambda_1=\frac{1-\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_1=\begin{bmatrix} 1 \\ \frac{-1-\sqrt{5}}{2} \\ \end{bmatrix}\)</span>，<span class="math inline">\(\lambda_2=\frac{1+\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_2=\begin{bmatrix} 1 \\ \frac{-1+\sqrt{5}}{2} \\ \end{bmatrix}\)</span> 。那么根据定义，设 <span class="math inline">\(C=[B_1,B_2]\)</span>，构造对角阵 $P=\begin{bmatrix} _1 &amp; 0 \ 0 &amp; _2 \ \end{bmatrix} $，就可以得到 <span class="math inline">\(A\times C=C\times P\)</span>，所以有 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>。故 <span class="math inline">\(A^m=C\times P^m \times C^{-1}\)</span>。</p><p>通过手算可以求得 <span class="math inline">\(C^{-1}= \begin{bmatrix} 1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; -\frac{\sqrt{5}}{5} \\ \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; \frac{\sqrt{5}}{5} \\ \end{bmatrix}\)</span>。</p><p>对于斐波那契数列第 <span class="math inline">\(m\)</span> 项，即是 <span class="math inline">\(A^m\)</span> 的 <span class="math inline">\(a_{1,1}\)</span>。显然 <span class="math inline">\(P^m=\begin{bmatrix} (\frac{1-\sqrt{5}}{2})^m &amp; 0 \\ 0 &amp; (\frac{1+\sqrt{5}}{2})^m \ \end{bmatrix}\)</span> ，那么 <span class="math inline">\(C\times P^m \times C^{-1}\)</span> 的 <span class="math inline">\(a_{1,1}\)</span> 为 <span class="math inline">\((\frac{1-\sqrt{5}}{2})^m\times(1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5})+(\frac{1+\sqrt{5}}{2})^m\times \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5}\)</span>，整理之后就为 <span class="math inline">\(\frac{1}{\sqrt{5}}\left((\frac{1+\sqrt{5}}{2})^{m+1}-(\frac{1-\sqrt{5}}{2})^{m+1}\right)\)</span> ，即为斐波那契数列的通项公式。</p><p>因为出现了根号，所以整个过程看似比较麻烦，不过在递推矩阵满足一些性质的时候有较快的方法求特征值和特征向量（比如在整个矩阵是一个上/下三角矩阵时，特征值就是主对角线上的值，自由元就是项数变少了某行，设它为 <span class="math inline">\(1\)</span>，就可以在矩阵大小的复杂度内求得一个特征向量）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果我们需要求维度为 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的矩阵 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次幂，那么一个显然的方法是用快速幂，复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(c^3 \log m\)&lt;/span&gt;。不过当需要用到高精度的时候，该算法速度会大大下降。&lt;/p&gt;
&lt;p&gt;考虑这么一个事情，</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>PAM 学习笔记</title>
    <link href="http://example.com/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T07:20:06.000Z</published>
    <updated>2020-09-26T07:20:37.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义">定义</h4><p>PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。</p><p>PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。</p><a id="more"></a><table><thead><tr class="header"><th style="text-align: left;"></th><th>AC 自动机</th><th>PAM</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">点         </td><td>一个前缀</td><td>一个回文串</td></tr><tr class="even"><td style="text-align: left;">转移边</td><td>从起点走到终点，相当于在起点的字符串后面加上一个字符</td><td>从起点走到终点，相当于在起点的字符串两侧都加上一个字符</td></tr><tr class="odd"><td style="text-align: left;">fail 边</td><td>存在的最长后缀</td><td>存在的最长回文后缀</td></tr></tbody></table><p>但是，PAM 有一个 AC 自动机不具有的性质——它有两个根！因为可以发现走转移边并不会改变回文串长度的奇偶性，这样的话就保存不了所有的回文串了，所以我们需要两个根，一个叫做奇根，还有一个叫做偶根，这样才能维护所有的回文串。</p><h4 id="构造">构造</h4><p>定义完了那就看看怎么构造它。这里我们使用增量法。</p><p>为了方便，我们给每个点定义一个结构体，存当前点的信息，这里我们就维护三个信息：当前回文串的长度、转移边、fail 边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> son[<span class="number">26</span>], fail;</span><br><span class="line">&#125; t[MAXN];</span><br></pre></td></tr></table></figure><p>先看看怎么初始化，显然我们要先定义两个根。对于奇根，它的长度为 <code>-1</code> （可以把在它两侧加一个字符，当做它会吃掉一个字符），它一开始没有儿子，它的 fail 边随便指（因为它的两侧一定可以加字符）。对于偶根，它的长度为 <code>0</code> （可以看成是空串），它一开始没有儿子，它的 fail 边指向奇根，因为它两侧不能加字符的话，就只能丢给奇根了。即：（<code>0</code> 号节点是偶根，<code>1</code> 号节点是奇根）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>].len = <span class="number">0</span>; t[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">t[<span class="number">1</span>].fail = t[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>假设上一次加入的点是 <code>last</code> ，现在需要新增一个字符 <code>ch</code>，假设它存储在 <code>s[pos]</code>。</p><p>首先我们需要找到一个 <code>last</code> 所代表串的一个最长后缀，使得可以在这个后缀后面加上 <code>ch</code>，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfail</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s[pos] != s[pos - t[last].len - <span class="number">1</span>])</span><br><span class="line">    last = t[last].fail;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这个最长后缀所在的点记作 <code>cur</code>，然后接下来就看 <code>cur</code> 节点有没有 <code>ch</code> 这个儿子，如果有就直接跳过，把 <code>last</code> 设为这个儿子，否则就新增一个节点，记为 <code>nxt</code>。</p><p>对于 <code>nxt</code>，它的长度是 <code>cur</code> 的长度 <code>+2</code> （根据转移边的定义）。它的 fail 的寻找和 AC 自动机很像，是在 <code>cur</code> 的 <code>fail</code> 中再找到一个最长的有 <code>ch</code> 这个字符的儿子的后缀，然后把 <code>nxt</code> 的 fail 指向那个后缀的 <code>ch</code> 儿子。最后再把 <code>cur</code> 的 <code>ch</code> 儿子设为 <code>nxt</code>。具体实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nxt = ++cnt;</span><br><span class="line">t[nxt].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">t[nxt].fail = t[Getfail(t[cur].fail, pos)].son[s[pos] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">t[cur].son[s[pos] - <span class="string">&#x27;a&#x27;</span>] = nxt;</span><br></pre></td></tr></table></figure><p>最后也需要让 <code>last</code> 等于 <code>nxt</code> 。</p><p>这样就可以把 PAM 构造出来，复杂度是 <span class="math inline">\(O(n)\)</span> 的，因为每次跳 fail 会让当前串的长度至少减 <code>2</code>，而加入一个字符只会让当前串的长度加 <code>2</code>，所以跳 fail 的次数是有保障的。</p><h4 id="应用">应用</h4><p>PAM 可以处理很多有关回文串的信息，具体在此就不展开了。实际上我们可以把 AC 自动机或是 SAM 的那些套路拿到 PAM 上来用，具体的怎么做还是得要进行实践。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。&lt;/p&gt;
&lt;p&gt;PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回文自动机" scheme="http://example.com/tags/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>做多项式题的一点小技巧</title>
    <link href="http://example.com/2020/09/26/%E5%81%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2020/09/26/%E5%81%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-09-26T07:19:26.000Z</published>
    <updated>2020-09-26T07:19:46.722Z</updated>
    
    <content type="html"><![CDATA[<p>有一类多项式题，十分考验选手的推式子能力，真正的代码部分仅仅只是几个模板拼凑在一起。这类题目如果出现，往往会造成比较大的分差，所以在此略微归纳一下这类题目的做法。大致如下：</p><a id="more"></a><p>两个主要思想：在解多项式方程的时候，把多项式当做数看，在允许的情况下，可以等式两边同时加减乘除一个多项式；部分题目的多项式可能是无穷项的，在这种情况下，可能会出现把原多项式经过一些操作之后得到自身。</p><p>两个主要套路：一个是先想出一个 DP 的做法，然后根据 DP 转移的特性，发现其卷积的性质并把卷积部分弄成多项式，之后直接卷积加速，或者通过解方程的方式求答案；另一个是直接设求解的东西为一个多项式，然后根据其性质使其可以从自己转移到自己，然后解方程。</p><p>具体如何使用请看下面两个题目的题解。</p><hr /><h4 id="集训队作业2013城市规划-题解">[集训队作业2013]城市规划 题解</h4><p><strong>题意简述：</strong>求 <span class="math inline">\(n\)</span> 个点无重边无自环有标号无向连通图数目。<span class="math inline">\(n\leq 10^5\)</span>。</p><p><strong>题解：</strong>我们设 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(i\)</span> 个节点的答案，直接求并不好求，但是我们可以很容易的得到 <span class="math inline">\(n\)</span> 个点的图的数量，即 <span class="math inline">\(2^{C_n^2}\)</span> ，考虑怎么用 <span class="math inline">\(f\)</span> 来表示它。</p><p><span class="math inline">\(1\)</span> 号节点最终一定会有一个连通块，考虑枚举这个连通块的大小，于是就有 <span class="math inline">\(2^{C_n^2}=\sum_{i=1}^nC_{n-1}^{i-1}f(i)2^{C_{n-i}^2}\)</span>。也就是 <span class="math inline">\(i\)</span> 个点形成一个连通块，剩下的点随意连边。</p><p>为了方便，设 <span class="math inline">\(g(i)=2^{C_i^2}\)</span>，原式子就变成了 <span class="math inline">\(g(n)=\sum_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)\)</span>。</p><p>把组合数拆开，移项得 <span class="math inline">\(\frac{g(n)}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{g(n-i)}{(n-i)!}\)</span>，设 <span class="math inline">\(F(i)=\frac{f(i)}{(i-1)!}\)</span>，<span class="math inline">\(G(i)=\frac{g(i)}{i!}\)</span>，后面的求和就是一个卷积的形式，即 <span class="math inline">\(F\times G\)</span>。</p><p>把等式左边也稍加整理一下，就有 <span class="math inline">\(nG(n)=(F\times G)(n)\)</span>。</p><p>我们定义多项式的点乘为对应项相乘，再设 <span class="math inline">\(H(i)=i\)</span>，那么就有 <span class="math inline">\((H\cdot G)(n)=(F\times G)(n)\)</span>，即 <span class="math inline">\(H\cdot G=F\times G\)</span>。</p><p>又因为 <span class="math inline">\(G\)</span> 的常数项为 <span class="math inline">\(1\)</span>，故 <span class="math inline">\(G\)</span> 存在逆元，所以可以两边同时卷上 <span class="math inline">\(G^{-1}\)</span>。于是就有 <span class="math inline">\(F=(H\cdot G)\times G^{-1}\)</span>，写个多项式求逆就可以得到 <span class="math inline">\(F\)</span> 了。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><h3 id="cf438e-the-child-and-binary-tree-题解">CF438E The Child and Binary Tree 题解</h3><p><strong>题意简述：</strong> 有无数个点，每个点的权值可以是给出集合 <span class="math inline">\(S\)</span> 中的任意一个，定义一棵树的权值是所有点的权值和，求有多少棵节点数目任意的、形态不同的、权值为 <span class="math inline">\(val\)</span> 的二叉树。对于每个 <span class="math inline">\(val\leq k\)</span> 都需要求解。<span class="math inline">\(k,|S|\leq 10^5\)</span>。</p><p>题解：直接设多项式 <span class="math inline">\(f\)</span> 为答案多项式，其中 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(val=i\)</span> 的方案数。特别的，<span class="math inline">\(f(0)=1\)</span>。现在考虑 <span class="math inline">\(f\)</span> 怎么求。</p><p>设 <span class="math inline">\(g(i)\)</span> 表示一个点的权值为 <span class="math inline">\(i\)</span> 的方案数，显然 <span class="math inline">\(i\in S\)</span> 则 <span class="math inline">\(g(i)=1\)</span>，反之 <span class="math inline">\(g(i)=0\)</span>。</p><p>那么对于当前的，它左儿子的方案数是 <span class="math inline">\(f\)</span>，右儿子的方案数是 <span class="math inline">\(f\)</span>，它自己的方案数是 <span class="math inline">\(g\)</span>，而这个问题把解集合并就相当于是一个背包，那么就有 <span class="math inline">\(f=f\times f\times g+1\)</span>，这个加一是指当前这个点的子树为空。</p><p>之后把 <span class="math inline">\(f\)</span> 当做未知数解方程，根据求根公式，有 <span class="math inline">\(f=\frac{1\pm\sqrt{1-4g}}{2g}\)</span>，现在需要考虑正负取正还是负。</p><p>我们可以这么分析，当 <span class="math inline">\(g\)</span> 趋近于 <span class="math inline">\(0\)</span> 也就是 <span class="math inline">\(|S|\)</span> 趋近于 <span class="math inline">\(0\)</span> 的时候，<span class="math inline">\(f=\frac{1\pm1}{0}\)</span>，而此时方案数是为 <span class="math inline">\(0\)</span> 的，也就是 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(0\)</span>，那么就只能取负号，所以 <span class="math inline">\(f=\frac{1-\sqrt{1-4g}}{2g}\)</span>。</p><p><span class="math inline">\(g\)</span> 常数项不是 <span class="math inline">\(1\)</span>，没有逆元，考虑把分子有理化。就有 <span class="math inline">\(f=\frac{2}{1+\sqrt{1-4g}}\)</span>。多项式开根加个求逆即可。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><p>上述题目，第一题用的是第一个 trick，第二题用的是第二个 trick，较好的体现了做多项式题目的技巧。且这两个题目十分经典，不失为练习多项式的好题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一类多项式题，十分考验选手的推式子能力，真正的代码部分仅仅只是几个模板拼凑在一起。这类题目如果出现，往往会造成比较大的分差，所以在此略微归纳一下这类题目的做法。大致如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>斯特林数学习笔记</title>
    <link href="http://example.com/2020/09/26/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/09/26/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T07:18:32.000Z</published>
    <updated>2020-10-06T10:56:07.317Z</updated>
    
    <content type="html"><![CDATA[<h4 id="下降幂和上升幂">下降幂和上升幂</h4><p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次下降幂记作 <span class="math inline">\(x^{\underline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x-i)\)</span> 。</p><p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次上升幂记作 <span class="math inline">\(x^{\overline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x+i)\)</span>。</p><a id="more"></a><h4 id="第一类斯特林数">第一类斯特林数</h4><p><span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}\)</span> 表示第一类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个圆排列的方案数。圆排列不能为空。</p><p>第一类斯特林数有一个递推式，<span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}=\begin{bmatrix} n-1 \\ i \end{bmatrix}\times(n-1)+\begin{bmatrix} n-1 \\ i-1 \end{bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个圆排列，要么就跟在某个数的后面。</p><h4 id="第二类斯特林数">第二类斯特林数</h4><p><span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}\)</span> 表示第二类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个无标号的集合的方案数。集合不能为空。</p><p>第二类斯特林数有一个递推式，<span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}=\begin{Bmatrix}n-1 \\ i\end{Bmatrix}\times i+\begin{Bmatrix}n-1 \\ i-1\end{Bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个集合，要么就放在之前的某个集合里面。</p><h4 id="斯特林数和自然幂下降幂上升幂的关系">斯特林数和自然幂、下降幂、上升幂的关系</h4><p>对于自然幂和下降幂，有这么一个式子。<span class="math inline">\(n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\)</span>。</p><p>考虑从组合意义来理解它。<span class="math inline">\(n^m\)</span> 相当于是把 <span class="math inline">\(m\)</span> 个有标号的球放入 <span class="math inline">\(n\)</span> 个有标号的盒子的方案数，考虑枚举有多少个盒子有球，假设为 <span class="math inline">\(i\)</span>，那么选盒子的方案就是 <span class="math inline">\(\begin{pmatrix}n \\ i\end{pmatrix}\)</span>，然后把 <span class="math inline">\(m\)</span> 个球放到这 <span class="math inline">\(i\)</span> 个盒子里面去，方案是 <span class="math inline">\(\begin{Bmatrix}m \\ i\end{Bmatrix}\)</span>，而因为第二类斯特林数的集合是无标号的，这里是有标号的，所以最后需要乘上一个 <span class="math inline">\(i!\)</span>，然后把组合数展开，就得到上面的那个式子。</p><p>对于自然幂和上升幂，有这么一个式子。<span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}n^i\)</span> 。</p><p>考虑用数学归纳法来证明它，对于 <span class="math inline">\(m=0\)</span> 式子显然成立，假设现在已经证明对于 <span class="math inline">\(m\leq k-1\)</span> 式子成立，需要证明对于 <span class="math inline">\(m=k\)</span> 式子成立。</p><p><span class="math display">\[\begin{split}n^{\overline{k}}&amp;=n^{\overline{k-1}}\times(n+k-1)\\&amp;=n^{\overline{k-1}}\times n+n^{\overline{k-1}}\times(k-1)\\&amp;=\sum_{i=0}^{k-1}\begin{bmatrix}k-1 \\ i\end{bmatrix}n^{i+1}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~\\&amp;=\sum_{i=1}^{k-1}\begin{bmatrix}k-1 \\ i-1\end{bmatrix}n^{i}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~~~~\\&amp;=\sum_{i=0}^k\begin{bmatrix}k \\ i\end{bmatrix}n^i\end{split}\]</span></p><p>故可以证明原式子成立。</p><h4 id="斯特林反演">斯特林反演</h4><h5 id="反转公式-i">反转公式 I</h5><p><span class="math inline">\(x^{\overline{k}}=(-1)^k(-x)^{\underline{k}}\)</span>，<span class="math inline">\(x^{\underline{k}}=(-1)^k(-x)^{\overline{k}}\)</span>。</p><p>这两个式子把它们拆开就可以证明相等了。</p><h5 id="反转公式-ii">反转公式 II</h5><p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}\begin{Bmatrix}i \\ m\end{Bmatrix}=[m==n]\)</span></p><p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{Bmatrix}n \\ i\end{Bmatrix}\begin{bmatrix}i \\ m\end{bmatrix}=[m==n]\)</span></p><p>对于第二个证明如下： <span class="math display">\[\begin{split}n^m&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i(-n)^{\overline{i}}\\&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix} i \\ j \end{bmatrix}(-n)^j\\&amp;=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m \\ i\end{Bmatrix}\begin{bmatrix} i \\ j \end{bmatrix}(-1)^{i-j}\\\end{split}\]</span> 把 <span class="math inline">\(n\)</span> 看成是一个未知数时，对于一个多项式 <span class="math inline">\(\sum a_in^i\)</span>，<span class="math inline">\(n^m\)</span> 可以且仅可以用 <span class="math inline">\(a_mn^m\)</span> 来表示，所以最后的式子只有 <span class="math inline">\(j=m\)</span> 的时候为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。</p><p>对于第一个式子，有 <span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}(-1)^i(-n)^i\)</span>，把后面的自然幂展开成下降幂，然后再推一推就可以类似于上面讨论证明。</p><h5 id="斯特林反演公式">斯特林反演公式</h5><p><span class="math inline">\(f(n)=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}f(i)\)</span>。</p><p>和二项式反演类似，只需要证明一个方向，另一个方向显然成立。</p><p>正向证明如下： <span class="math display">\[\begin{split}g(n)&amp;=\sum_{i=0}^n[i==n]g(i)\\&amp;=\sum_{i=0}^n\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\sum_{i=0}^j\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}f(j)\end{split}\]</span></p><h4 id="第一类斯特林数求自然数幂和">第一类斯特林数求自然数幂和</h4><p>设 <span class="math inline">\(\sum_{i=1}^n i^k\)</span> 为 <span class="math inline">\(S_k(n)\)</span>。 <span class="math display">\[\begin{split}&amp;\because n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\&amp;\therefore n^{\underline{m}}=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\&amp;\therefore n^m=n^{\underline{m}}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\&amp;\therefore \sum_{n=1}^X n^m=\sum_{n=1}^Xn^{\underline{m}}-\sum_{n=1}^X\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\&amp;\begin{split}\therefore S_m(X)&amp;=m!\sum_{n=1}^X\begin{pmatrix}n \\ m\end{pmatrix}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}\sum_{n=1}^Xn^i\\&amp;=m!\begin{pmatrix}X+1 \\ m+1\end{pmatrix}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)\\&amp;=\frac{(X+1)^{\underline{m+1}}}{m+1}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)~\\\end{split}\end{split}\]</span> 故 <span class="math inline">\(S_m(X)\)</span> 可以在 <span class="math inline">\(m^2\)</span> 的时间复杂度内求得，且不要求模数是质数。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;下降幂和上升幂&quot;&gt;下降幂和上升幂&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 次下降幂记作 &lt;span class=&quot;math inline&quot;&gt;\(x^{\underline{k}}\)&lt;/span&gt;，表示的是 &lt;span class=&quot;math inline&quot;&gt;\(\prod_{i=0}^{k-1}(x-i)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 次上升幂记作 &lt;span class=&quot;math inline&quot;&gt;\(x^{\overline{k}}\)&lt;/span&gt;，表示的是 &lt;span class=&quot;math inline&quot;&gt;\(\prod_{i=0}^{k-1}(x+i)\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="斯特林数" scheme="http://example.com/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组学习笔记</title>
    <link href="http://example.com/2020/09/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/09/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T07:18:00.000Z</published>
    <updated>2020-09-26T07:21:28.082Z</updated>
    
    <content type="html"><![CDATA[<p>老忘后缀数组咋写，写个东西记录下。</p><p>算法核心：因为后缀是在同一个串内的，要充分利用其它信息。</p><a id="more"></a><p>考虑倍增，即从小到大按照长度为 <span class="math inline">\(2^k\)</span> 的串进行排序。</p><p>先按照长度为 <span class="math inline">\(1\)</span> 的串排序，每个点有一个排名。</p><p>然后扩展到长度为 <span class="math inline">\(2\)</span>，现在可以知道每个长度为 <span class="math inline">\(2\)</span> 的串前一半相对的排名和后一半相对的排名，那么显然是要先按前一半的排，如果相等再按后一半的排，用 pair 加快排可以做到 <span class="math inline">\(n\log n\)</span>，但是不够。考虑使用基数排序，就可以做到 <span class="math inline">\(n\)</span> 。</p><p>再扩展到长度为 <span class="math inline">\(4\)</span> …… 总时间复杂度 <span class="math inline">\(n\log n\)</span>。</p><p>光求这个没啥用，考虑求一个 height，表示排名为 i 的后缀和排名为 i-1 的最长公共前缀有多长。那么任意两个后缀的 LCP 就可以直接通过 RMQ 求。</p><p>考虑怎么求 height，设 h 表示第 i 串和排名恰好小于它 1 的串的最长公共前缀。那么有 <span class="math inline">\(h[i]\ge h[i-1]+1\)</span>。如果 <span class="math inline">\(h[i-1]\leq 1\)</span>，那么显然成立，否则 <span class="math inline">\(h[i-1]\geq 2\)</span>，假设排名恰好小于第 i-1 串 1 的串是第 k 串，那么就有 <span class="math inline">\(s[i-1,i-1+h[i-1])=s[k,k+h[i-1])\)</span> 且 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么 <span class="math inline">\(s[i,i-1+h[i-1])=s[k+1,k+h[i-1])\)</span>，因为 <span class="math inline">\(h[i-1]\geq 2\)</span>，那么这个区间不为空，又因为 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么第 k+1 串的排名肯定是小于第 i 串的，而距离 i 越远 LCP 就越小，那么第 i 串和排名恰好小于它 1 的串的 LCP 至少为 <span class="math inline">\(h[i-1]-1\)</span> 。所以可以直接从小到大暴力枚举求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;老忘后缀数组咋写，写个东西记录下。&lt;/p&gt;
&lt;p&gt;算法核心：因为后缀是在同一个串内的，要充分利用其它信息。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数组" scheme="http://example.com/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>广义二项式定理</title>
    <link href="http://example.com/2020/09/26/%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    <id>http://example.com/2020/09/26/%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</id>
    <published>2020-09-26T07:17:04.000Z</published>
    <updated>2020-09-26T07:17:35.341Z</updated>
    
    <content type="html"><![CDATA[<p>提前介绍一下广义的组合数，组合数 <span class="math inline">\(\tbinom{n}{m}\)</span> 的定义是 <span class="math inline">\(\frac{n\times (n-1)\times ... \times (n-m+1)}{m!}\)</span>，广义下的组合数只需要保证 <span class="math inline">\(m\)</span> 为非负整数，<span class="math inline">\(n\)</span> 可以是任意实数。</p><a id="more"></a><p>对于广义的组合数，有个恒等式 <span class="math inline">\(\tbinom{n}{m}=\tbinom{m-n-1}{m}\times (-1)^{m}\)</span> 。</p><blockquote><p>两式的分母都是一样的，对于左式，其分子是 <span class="math inline">\(n\times (n-1)\times ... \times (n-m+1)\)</span>，对于右式，其分子是 <span class="math inline">\((m-n-1)\times ((m-n-1)-1) \times ... \times ((m-n-1)-m+1)\)</span>，可以发现右式分子的每个单项式和左式分子的单项式一一对应，并且互为相反数，那么最后乘上一个 <span class="math inline">\((-1)^m\)</span> 即可。</p></blockquote><p>有个很妙的记忆方法：两级反转（和艾克真的一点关系都没有 /doge）连续变化两次，设未知数，下标不变，上标用 <span class="math inline">\(m-1\)</span> 去减，即：<span class="math inline">\(\tbinom{n}{m}=\tbinom{m-?-1}{m}\times (-1)^{2m}\)</span>，那么可以很快得出问号是 <span class="math inline">\(m-n-1\)</span> 。当然直接用上文的证明去推更 nice。</p><p>广义二项式定理： <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 这里的 <span class="math inline">\(k\)</span> 可以是任意实数，一般会用在 <span class="math inline">\(k\)</span> 为负整数的时候，那么我们在下面约定所有出现的 <span class="math inline">\(k\)</span> 都是<strong>负整数</strong>，且为了方便理解，设 <span class="math inline">\(n=-k\)</span>。</p><p>考虑用生成函数去解释，先把 <span class="math inline">\((a+b)^{k}\)</span> 看成 <span class="math inline">\((a+bx)^{k}\)</span> 那么最后只要把 <span class="math inline">\(x\)</span> 看成 <span class="math inline">\(1\)</span> 即可。</p><p>先考虑最基本的情况：<span class="math inline">\((1-x)^{-n}\)</span> 。</p><p>根据数学知识可以知道上式就是 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}\)</span> 。</p><p>根据生成函数，可以知道 <span class="math inline">\((1-x)^{-1}=\sum_{i=0}^{\infty} x^i\)</span> 。</p><blockquote><p>设 <span class="math inline">\(S=1+x+x^2+...\)</span>，那么 <span class="math inline">\(xS=x+x^2+x^3+...\)</span>，那么 <span class="math inline">\(S-xS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-x}\)</span> 即 $ (1-x)^{-1}$</p></blockquote><p>那么 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\left( \sum_{i=0}^{\infty} x^i \right)^{n}\)</span> 。</p><p>考虑从组合意义上去计算这个式子：你有 <span class="math inline">\(n\)</span> 种球，每种球无限个，你需要从这 <span class="math inline">\(n\)</span> 种球中选择一共 <span class="math inline">\(i\)</span> 个球，每种球至少选 <span class="math inline">\(0\)</span> 个，其方案数就是 <span class="math inline">\(x^i\)</span> 的系数。那么使用隔板法就有 <span class="math inline">\(\tbinom{i+n-1}{n-1}\)</span> 。</p><p>所以 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}x^i\)</span> 。</p><p>那么我们再在 <span class="math inline">\(x\)</span> 前面加上一个系数 <span class="math inline">\(p\)</span> ，即求 <span class="math inline">\((1-px)^{-1}\)</span> 。它是等于 <span class="math inline">\(\sum_{i=0}^{\infty} p^ix^i\)</span> 。</p><blockquote><p>设 <span class="math inline">\(S=1+px+p^2x^2+...\)</span> ，那么 <span class="math inline">\(pxS=px+p^2x^2+p^3x^3+...\)</span>，那么 <span class="math inline">\(S-pxS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-px}\)</span> 即 <span class="math inline">\((1-px)^{-1}\)</span> 。</p></blockquote><p>那再按照上面的方法去推，就有 <span class="math inline">\(\left( (1-px)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}p^ix^i\)</span></p><p>回到一开始的问题，<span class="math inline">\((a+bx)^k=a^k \left( 1-(-\frac{b}{a}x) \right)^k\)</span> 。</p><p>那么就有 <span class="math inline">\((a+bx)^k=a^k \sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-\frac{b}{a})^ix^i\)</span> 。整理一下，<span class="math inline">\(\sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-1)^ia^{k-i}b^ix^i\)</span> 。</p><p>注意了，这里等式内部的组合数的 <span class="math inline">\(k\)</span> 前面都带个负号，因为上文在推导过程中，设的是 <span class="math inline">\(n=-k\)</span>，所以在组合数中的 <span class="math inline">\(n\)</span> 才是正号。</p><p>再根据文首提及的那个恒等式，就有 <span class="math inline">\(\tbinom{i-k-1}{-k-1}=\tbinom{i-k-1}{i}=\tbinom{k}{i}\times (-1)^i\)</span> 。</p><p>可以发现两个 <span class="math inline">\((-1)^i\)</span> 抵掉了，那么 <span class="math inline">\((a+bx)^k=\sum_{i=0}^{\infty} \tbinom{k}{i}a^{k-i}b^ix^i\)</span> 。</p><p>把 <span class="math inline">\(x=1\)</span> 带入原式，即可得 <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;提前介绍一下广义的组合数，组合数 &lt;span class=&quot;math inline&quot;&gt;\(\tbinom{n}{m}\)&lt;/span&gt; 的定义是 &lt;span class=&quot;math inline&quot;&gt;\(\frac{n\times (n-1)\times ... \times (n-m+1)}{m!}\)&lt;/span&gt;，广义下的组合数只需要保证 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 为非负整数，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 可以是任意实数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合数学" scheme="http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>多项式学习笔记</title>
    <link href="http://example.com/2020/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T07:15:21.000Z</published>
    <updated>2020-10-06T02:21:07.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前置知识">前置知识</h4><h5 id="形式幂级数">形式幂级数</h5><p>对于一个多项式 <span class="math inline">\(\sum_{i=0}^{\infty}a_ix^i\)</span>，如果我们只关心它的各项系数 <span class="math inline">\(\{a_0,a_1...\}\)</span>，而并不关心 <span class="math inline">\(x\)</span> 的值以及其收敛或发散的问题，就可以说其是关于 <span class="math inline">\(x\)</span> 的形式幂级数。</p><a id="more"></a><h5 id="牛顿迭代">牛顿迭代</h5><p>对于一个已知的多项式 <span class="math inline">\(F\)</span>，求一个多项式 <span class="math inline">\(A\)</span>，使得 <span class="math inline">\(F(A)=0\)</span> 在模 <span class="math inline">\(x^n\)</span> 意义下成立，其中 <span class="math inline">\(F,A\)</span> 都是形式幂级数。</p><p>牛顿迭代是这样的，假设我们已经求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 下的解 <span class="math inline">\(A_0\)</span>，那么可以把 <span class="math inline">\(F(A)\)</span> 在 <span class="math inline">\(A_0\)</span> 处泰勒展开，再模掉 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(F(A)=F(A_0)+F&#39;(A_0)(A-A_0)\)</span>，然后就可以通过解方程求的在模 <span class="math inline">\(x^n\)</span> 意义下的 <span class="math inline">\(A\)</span>。</p><h4 id="运算">运算</h4><h5 id="加减法">加减法</h5><p>就是多项式对应项相加减。即 <span class="math inline">\(C_ix^i=(A_i+B_i)x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p><h5 id="乘法卷积">乘法（卷积）</h5><p>多项式的乘法本质上是求 <span class="math inline">\(C_ix^i=\sum_{j+k=i}A_jB_kx^i\)</span>。可以使用 FFT 或者 NTT 解决。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h5 id="求导">求导</h5><p>对于一个单项式 <span class="math inline">\(kx^n\)</span> 求导，其值是 <span class="math inline">\(knx^{n-1}\)</span>，而对于多项式的求导，本质上是把各个单项式求导之后再加起来。即 <span class="math inline">\(C_ix^i=(i+1)A_{i+1}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p><p>有两个在多项式中常见的求导公式：<span class="math inline">\((\ln x)&#39;=\frac{1}{x},(e^x)&#39;=e^x\)</span>。</p><p>特别的，复合函数也可以求导，<span class="math inline">\((F(G))&#39;=F&#39;(G)\times G&#39;\)</span>。</p><h5 id="积分">积分</h5><p>积分是求导的逆运算，在求导中，有 <span class="math inline">\(kx^n\rightarrow knx^{n-1}\)</span>，那么积分里面就有 <span class="math inline">\(kx^n\rightarrow\frac{k}{n+1}x^{n+1}\)</span> 。而对于多项式的积分，也是把各个单项式求导之后再加起来，即 <span class="math inline">\(C_ix^i=\frac{A_{i-1}}{i}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p><h5 id="翻转">翻转</h5><p>对于一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(A(x)=\sum_{i=0}^n a_ix^i\)</span>，将它变成 <span class="math inline">\(\sum_{i=0}^n a_{n-i}x^i\)</span>，就称之为翻转，记作 <span class="math inline">\(A^R(x)\)</span>，不难发现本质上 <span class="math inline">\(A^R(x)=A(\frac{1}{x})\times x^n\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p><h5 id="求逆">求逆</h5><p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个多项式 <span class="math inline">\(A^{-1}(x)\)</span>，使得 <span class="math inline">\(A(x)\times A^{-1}(x)\equiv 1~(~{\rm mod}~x^{n})\)</span>。</p><p>考虑使用牛顿迭代，设 <span class="math inline">\(B(x)=A^{-1}(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 。假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}=\frac{1}{B_0(x)}+(\frac{1}{B_0(x)})&#39;(B(x)-B_0(x))\)</span>，我们知道 <span class="math inline">\((\frac{1}{B_0(x)})&#39;=-\frac{1}{B_0^2(x)}\)</span>，那么把 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 中的 <span class="math inline">\(\frac{1}{B(x)}\)</span> 换成上面右边的那一坨，然后稍加整理一下就有 <span class="math inline">\(B(x)\equiv 2B_0(x)-A(x)B_0^2(x)~(~{\rm mod}~x^n)\)</span> 。直接这么倍增处理即可，复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。因为相对于最后一次来说，前面的若干次可以忽略不计。</p><h5 id="除法和取模">除法和取模</h5><p><span class="math inline">\(A(x)=B(x)\times C(x)+D(x)\)</span>，其中 <span class="math inline">\(A(x)\)</span> 是 <span class="math inline">\(n\)</span> 次多项式，<span class="math inline">\(B(x)\)</span> 是 <span class="math inline">\(m\)</span> 次多项式，<span class="math inline">\(m&lt;n\)</span>，给出 <span class="math inline">\(A(x),B(x)\)</span>，求 <span class="math inline">\(C(x),D(x)\)</span>。</p><p>显然，<span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，<span class="math inline">\(D(x)\)</span> 的次数最大是 <span class="math inline">\(m-1\)</span>，就把它看做是 <span class="math inline">\(m-1\)</span> 项，高位不足就补零。</p><p>先换元，把等式两边的 <span class="math inline">\(x\)</span> 换做 <span class="math inline">\(\frac{1}{x}\)</span>，然后再在两边同时乘上 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(A(\frac{1}{x})\times x^n=B(\frac{1}{x})\times x^{m}\times C(\frac{1}{x}) \times x^{n-m}+D(\frac{1}{x})\times x^{m-1}\times x^{n-m+1}\)</span>，根据上述的翻转式子，就是 <span class="math inline">\(A^R(x)=B^R(x)\times C^R(x)+D^R(x)\times x^{n-m+1}\)</span> 。前面已经说了 <span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，那么等式模去 <span class="math inline">\(x^{n-m+1}\)</span> 并不会对 <span class="math inline">\(C(x)\)</span> 有任何损失，所以就有 <span class="math inline">\(A^R(x)\equiv B^R(x)\times C^R(x)~({\rm mod}~x^{n-m+1})\)</span>，对 <span class="math inline">\(B^R(x)\)</span> 求个逆元乘上就可以得到 <span class="math inline">\(C^R(x)\)</span>，翻转一下就是 <span class="math inline">\(C(x)\)</span>，然后就可以通过 <span class="math inline">\(A(x)-B(x)\times C(x)\)</span> 得到 <span class="math inline">\(D(x)\)</span>。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h5 id="ln-和-exp">ln 和 exp</h5><p>因为积分是求导的逆运算，所以一个多项式先求导再积分，多项式不变。</p><p>那么对于 ln，就可以先求导再积分来求。即 <span class="math inline">\(\ln F(x)=\int_0^n(\ln F(x))&#39;~{\rm dx}\)</span>，前面已经提到了复合函数求导，所以就有 <span class="math inline">\(\ln F(x)=\int_0^n\frac{F&#39;(x)}{F(x)}~{\rm dx}\)</span> 。复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p><p>对于 exp，它是 ln 的逆运算，考虑用牛顿迭代求。设 <span class="math inline">\(B(x)=e^{A(x)}\)</span>，那么就有 <span class="math inline">\(\ln B(x)-A(x)=0\)</span>，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\ln B(x)=\ln B_0(x)+\ln&#39;B_0(x)(B(x)-B_0(x))\)</span>，上文已有 <span class="math inline">\(ln&#39;B_0(x)=\frac{1}{B_0(x)}\)</span>，把这个 <span class="math inline">\(\ln B(x)\)</span> 带回原式中去，整理一下就有 <span class="math inline">\(B(x)\equiv B_0(x)(A(x)+1-\ln B_0(x))~(~{\rm mod}~x^n)\)</span>。直接倍增求即可，复杂度也是 <span class="math inline">\(O(n\log n)\)</span>。</p><h5 id="开根">开根</h5><p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个 <span class="math inline">\(B(x)\)</span>，使得 <span class="math inline">\(B^2(x)\equiv A(x)~(~{\rm mod}~x^n)\)</span>。</p><p>仍然可以使用牛顿迭代法求，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(B^2(x)=B_0^2(x)+(B_0^2(x))&#39;(B(x)-B_0(x))\)</span>。类似的，整理之后就有 <span class="math inline">\(B(x)\equiv \frac{A(x)}{2B_0(x)}+\frac{B_0(x)}{2}~(~{\rm mod}~x^n)\)</span> 。复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的。</p><h4 id="其他东西">其他东西</h4><h5 id="分治-fft">分治 FFT</h5><p>分治 FFT 可以用来干两种事情。</p><p>一种是要把一堆多项式要乘起来，如果直接一个一个乘的话复杂度最坏是 <span class="math inline">\(O(n^2\log n)\)</span> 的，而如果每次对半分，左右分别计算然后再卷积一次，单层的复杂度就是 <span class="math inline">\(O(n\log n)\)</span> 的，一共 <span class="math inline">\(O(\log n)\)</span> 层，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>还有一种是需要求一个多项式的时候，前面的项对后面的项有影响，那么就可以用 CDQ 分治的思想，先算前面的，然后算前面对后面的贡献，最后再算后面的，复杂度 <span class="math inline">\(O(n \log^2 n)\)</span>。</p><h5 id="任意模数-ntt">任意模数 NTT</h5><p>有两种方法，三模数 NTT 和 拆系数 MTT。</p><p>三模数 NTT，就如它的名字，选三个 NTT 模数，分别做一遍 NTT 最后用 CRT 合并。最后 CRT 求出来的一定是精确的值，所以需要保证最终的值在三个 NTT 模数的乘积以内。复杂度是 <span class="math inline">\(O(n \log n)\)</span>，9 倍常数。</p><p>拆系数 MTT，也如它的名字，就是把每个数 <span class="math inline">\(X\)</span> 拆成 <span class="math inline">\(AM+B\)</span> 的形式，那么如果有两个多项式 <span class="math inline">\(AM+B\)</span> 和 <span class="math inline">\(CM+D\)</span> 相乘，最后的结果就是 <span class="math inline">\(ACM^2 + (AD+BC)M+BD\)</span>，最后乘出来的结果是 <span class="math inline">\(M^2{\rm len}\)</span>，一般情况下可以跑 FFT，用 long double 存。复杂度是 <span class="math inline">\(O(n\log n)\)</span>，7 倍常数。</p><h5 id="多点求值">多点求值</h5><p>对于一个多项式 <span class="math inline">\(F\)</span>，给出一些 <span class="math inline">\(z_i\)</span>，需要求出 <span class="math inline">\(F(z_i)\)</span> 的值。</p><p>对于求出 <span class="math inline">\(F(z_i)\)</span>，我们可以这么做：次数从高到低扫这个多项式，然后把当前项的一个 <span class="math inline">\(x\)</span> 展开成 <span class="math inline">\(z_i\)</span>（即对于 <span class="math inline">\(ax^k\)</span>，把它展开成 <span class="math inline">\(ax^{k-1}z_i\)</span>，然后把它累加到 <span class="math inline">\(x^{k-1}\)</span> 项中去），最后在常数项的那个值就是 <span class="math inline">\(F(z_i)\)</span>。可以发现，这个过程实际上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p><p>对于上述问题，有另一种理解方式：设 <span class="math inline">\(F(z)=A(z)(z-z_i)+B\)</span>，那么当 <span class="math inline">\(z=z_i\)</span> 时，<span class="math inline">\(F(z_i)=B\)</span>，所以本质上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p><p>在自然数集中，有 <span class="math inline">\(X~{\rm mod}~BC~{\rm mod}~B = X~{\rm mod}~B\)</span>，其实在多项式中也是这样。</p><p>所以可以考虑分治。在分治的过程中，把 <span class="math inline">\(F\)</span> 对 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> 取模，最后递归到叶子节点的时候，当前的多项式就只剩下常数项，就是需要求的 <span class="math inline">\(F(z_i)\)</span>。</p><p>考虑发现复杂度，一开始需要求得 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> ，分治 FFT 解决。之后需要分治求解，在每一层，多项式的长度都是 <span class="math inline">\(O({\rm len})\)</span>，所以每层的总长是 <span class="math inline">\(O(n)\)</span> 的，一共有 <span class="math inline">\(O(\log n)\)</span> 层。所以总复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span> ，常数巨大。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;前置知识&quot;&gt;前置知识&lt;/h4&gt;
&lt;h5 id=&quot;形式幂级数&quot;&gt;形式幂级数&lt;/h5&gt;
&lt;p&gt;对于一个多项式 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=0}^{\infty}a_ix^i\)&lt;/span&gt;，如果我们只关心它的各项系数 &lt;span class=&quot;math inline&quot;&gt;\(\{a_0,a_1...\}\)&lt;/span&gt;，而并不关心 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的值以及其收敛或发散的问题，就可以说其是关于 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的形式幂级数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="多项式" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于莫比乌斯函数的一些小技巧</title>
    <link href="http://example.com/2020/09/26/%E5%85%B3%E4%BA%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2020/09/26/%E5%85%B3%E4%BA%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-09-26T01:59:01.000Z</published>
    <updated>2020-09-26T07:14:31.585Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些有关莫比乌斯函数的应用以及一些数论方面的东西。</p><a id="more"></a><h3 id="kgcdxy-leftrightarrow-kx-text-and-ky">1. <span class="math inline">\(k|\gcd(x,y) \Leftrightarrow k|x \text{ and } k|y\)</span></h3><p>这个 trick 比较显然，不过还是小小的证明一下。</p><p>因为 <span class="math inline">\(\gcd(x,y)\)</span> 同时整除 <span class="math inline">\(x,y\)</span>，所以满足左边一定满足右边。因为 <span class="math inline">\(\gcd(x,y)\)</span> 是最大公因数，如果满足右边而不满足左边，那么一定存在一个 <span class="math inline">\(z\)</span> 使得 <span class="math inline">\(\gcd(x,y)\times z\)</span> 也是 <span class="math inline">\(x,y\)</span> 的公因数，和最大公因数的定义矛盾。</p><p>因此，若有式子 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{k|\gcd(x,y)}\mu(k)\)</span>，后面的 <span class="math inline">\(k|\gcd(x,y)\)</span> 就可以换成 <span class="math inline">\(k|x\text{ and }k|y\)</span>，这样的话就可以交换求和符号把 <span class="math inline">\(k\)</span> 提前了。</p><p>这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p><h3 id="若要计算-fgcdxy可以设-fnsum_dngd-来化简式子">2. 若要计算 <span class="math inline">\(f(\gcd(x,y))\)</span>，可以设 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span> 来化简式子。</h3><p>举个简单的例子，我们需要计算 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\gcd(i,j)\)</span>。</p><p>当然，这个并不典型，而且大多数人都会枚举 <span class="math inline">\(\gcd\)</span> 做，不过我们现在使用当前的这个 trick 来解决这个问题。</p><p>我们设 <span class="math inline">\(f(n)=n\)</span>，且 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span>，那么原式就变成了 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{d|\gcd(x,y)}g(d)\)</span> 。然后就可以通过 trick 1 交换求和符号把 <span class="math inline">\(d\)</span> 提前了。而根据莫比乌斯反演，我们可以知道 <span class="math inline">\(g(n)=\sum_{d|n}f(d)\mu(\frac{n}{d})\)</span>（在该例题中恰好是 <span class="math inline">\(\mu*id=\varphi\)</span>），那么也可以很快地计算出 <span class="math inline">\(g\)</span>。这样就通过这个 trick 达到了简化式子的效果，而且在一些情况下比直接枚举 <span class="math inline">\(\gcd\)</span> 再把式子化来化去简单。</p><p>同样的，这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p><h3 id="设-dx-为-x-的因子个数那么-dntimes-msum_xnsum_ymgcdxy1">3. 设 <span class="math inline">\(d(x)\)</span> 为 <span class="math inline">\(x\)</span> 的因子个数，那么 <span class="math inline">\(d(n\times m)=\sum_{x|n}\sum_{y|m}[\gcd(x,y)=1]\)</span>。</h3><p>可以发现，把所有合法的 <span class="math inline">\(x,y\)</span> 拿出来，然后列出所有的 <span class="math inline">\(x\times \frac{m}{y}\)</span>，这就是所有 <span class="math inline">\(n\times m\)</span> 的因子。</p><p>肯定不能感性的就这么理解，考虑严谨一点点的证明。</p><p><strong>先证明每个因子一定存在一种方式可以得到。</strong></p><p>我们假设 <span class="math inline">\(n=\prod p_i^{a_i},m=\prod p_i^{b_i}\)</span>，设某个 <span class="math inline">\(n\times m\)</span> 的因子 <span class="math inline">\(d=\prod p_i^{c_i}\)</span> 。对于 <span class="math inline">\(d\)</span> 的某个质因子及其次幂 <span class="math inline">\(p_i^{c_i}\)</span>，以及对应的 <span class="math inline">\(n,m\)</span> 的质因子及其次幂 <span class="math inline">\(p_i^{a_i},p_i^{b_i}\)</span>。分两种情况讨论。</p><ol type="1"><li>若 <span class="math inline">\(c_i\leq b_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(b_i-c_i\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((0)+(b_i-(b_i-c_i))=c_i\)</span>，且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(0,b_i-c_i)=0}=1\)</span>。</li><li>若 <span class="math inline">\(c_i&gt;b_i\)</span>，又因为 <span class="math inline">\(c_i\leq a_i+b_i\)</span>，所以 <span class="math inline">\(c_i-b_i\leq a_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(c_i-b_i\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((c_i-b_i)+(b_i-0)=c_i\)</span>。且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(c_i-b_i,0)=0}=1\)</span></li></ol><p>这样的话，对于因子 <span class="math inline">\(d\)</span> 的每个 <span class="math inline">\(p_i\)</span> 都这么构造一下即可。</p><p><strong>再证明每个因子只能由这一种方式得到。</strong></p><p>根据上一部分的证明，不能发现这个性质其实是显然的。不过还是简要说一下。</p><p>对于上文的情况 1，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最小为 <span class="math inline">\((1)+(b_i-0)=b_i+1&gt; b_i\geq c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p><p>对于上文的情况 2，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最大为 <span class="math inline">\((0)+(b_i-1)=b_i-1&lt;b_i&lt;c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p><p>综上就可以证明这个 trick。</p><p>同样的，这个 trick 对于多个元素的乘积同样有效，即：</p><p><span class="math inline">\(d(\prod a_i)=\sum_{b_1|a_1}\sum_{b_2|a_2}...[\gcd(b_1,b_2)=1][\gcd(b_1,b_3)=1][\gcd(b_2,b_3)=1]...\)</span>。</p><h3 id="若求和式中出现枚举-xy-且涉及到了-xy-时大多数时候需要改变思路枚举-xy">4. 若求和式中出现枚举 <span class="math inline">\(x,y\)</span> 且涉及到了 <span class="math inline">\(xy\)</span> 时，大多数时候需要改变思路枚举 <span class="math inline">\(xy\)</span>。</h3><p>其实这个是一个十分普遍的小 trick。</p><p>还是用那个老到不能再老的例子举例，求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)\)</span>。</p><p>我们来枚举 <span class="math inline">\(\gcd\)</span>，然后变化一下就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]\)</span> 。根据常识，就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{n}{kd}\rfloor\)</span>，直接这么做就是 <span class="math inline">\(n\log n\)</span> 的，而且对于 <span class="math inline">\(n\)</span> 很大或者是多组询问不太好优化。</p><p>我们发现求和式中出现了 <span class="math inline">\(d\)</span>，也出现了 <span class="math inline">\(k\)</span>，同时涉及到了 <span class="math inline">\(dk\)</span>，那么考虑设 <span class="math inline">\(T=dk\)</span>，我们来枚举 <span class="math inline">\(T\)</span>，就有 <span class="math inline">\(\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{n}{T}\rfloor\sum_{k|T}\mu(k)\frac{T}{k}\)</span>。这样的话，有个求和变成了狄利克雷卷积，而一般来说卷出来的东西是积性函数。这样的话，前面的东西就可以用整数分块，而后面的东西可以线性筛预处理，或者使用亚线性筛直接求。这样大大加快了代码运行的时间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结一些有关莫比乌斯函数的应用以及一些数论方面的东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="莫比乌斯函数" scheme="http://example.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF506E 题解</title>
    <link href="http://example.com/2020/09/17/CF506E-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2020/09/17/CF506E-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-17T13:30:58.000Z</published>
    <updated>2020-09-19T02:52:49.095Z</updated>
    
    <content type="html"><![CDATA[<p>一道极 (e) 妙 (xin) 的自动机优化 DP 的题目。</p><p>先假设最后得到的字符串为 <span class="math inline">\(T\)</span>，由题意易知 <span class="math inline">\(T\)</span> 合法当且仅当 <span class="math inline">\(T\)</span> 是回文串且 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T\)</span> 的一个子序列。</p><p><span class="math inline">\(T\)</span> 是回文串的这个性质我们可以通过从外向内一个一个填字符来实现，所以我们需要 DP 的是 <span class="math inline">\(S\)</span> 相对于 <span class="math inline">\(T\)</span> 而言被匹配了多少个字符。</p><p>特别的，因为当 <span class="math inline">\(T\)</span> 的长度为奇数的时候，最后一次填的字符本质上是一个字符，需要特别处理，所以下面我们先讨论 <span class="math inline">\(T\)</span> 的长度为偶数的情况。</p><a id="more"></a><p>因为 <span class="math inline">\(T\)</span> 这个字符串是从外向内确定的，所以 <span class="math inline">\(S\)</span> 的匹配也是从外向内的，故可以设 <span class="math inline">\(f_{i,l,r}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前后 <span class="math inline">\(i\)</span> 个字符，当前 <span class="math inline">\(S\)</span> 还剩下 <span class="math inline">\([l,r]\)</span> 没有匹配到的方案数。</p><p>考虑转移，假设当前有 <span class="math inline">\(s[l] = s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r-1}\)</span>，如果当前填的字符不是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(25\)</span>。</p><p>假设当前 <span class="math inline">\(s[l] \not= s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r}\)</span>，如果当前填的字符是 <span class="math inline">\(s[r]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r-1}\)</span>，如果当前填的字符不是两者，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(24\)</span>。</p><p>需要注意的是，对于所有的 <span class="math inline">\(f_{i,l,r}(l&gt;r)\)</span>，因为 <span class="math inline">\((l&gt;r)\)</span>，也就是说 <span class="math inline">\(S\)</span> 已经被匹配完，所以无论填什么字符都没关系，那么它们就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(26\)</span>。</p><p>这样我们便有了一个 <span class="math inline">\(n\times |S|^2\)</span> 的 DP，如果把后面的状态强行剥离就可以做到 <span class="math inline">\(|S|^6\log n\)</span>，似乎并没有什么用。</p><p>考虑优化这个 DP，我们把这个 DP 的转移用一张图来表示，对于 <span class="math inline">\(S=abab\)</span>，转移图是这样的：</p><figure><img src="https://s1.ax1x.com/2020/09/17/wftvp6.png" alt="wftvp6.png" /><figcaption>wftvp6.png</figcaption></figure><p>其中下划线是已经匹配的部分，在 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列的椭圆表示 <span class="math inline">\(f_{x,i,j}\)</span>，我们把所有的 <span class="math inline">\(l&gt;r\)</span> 的状态归到一个状态里面去，就有了如上的转移图。一个合法的方案本质上就是从 <span class="math inline">\(abab\)</span> 走 <span class="math inline">\(n+|S|\)</span> 步到 ____​ 的一条路径。</p><p>我们把某条路径上面的所有节点拿出来，并且按照 <span class="math inline">\(s[l]\)</span> 是否等于 <span class="math inline">\(s[r]\)</span> 分类成两种点，可以发现，无论这两种点的排列如何，当这两种点的数量确定的时候，答案已经确定了。</p><p>设 <span class="math inline">\(s[l]=s[r]\)</span> 的点为 <span class="math inline">\(0\)</span> 类点，<span class="math inline">\(s[l]\not=s[r]\)</span> 的点为 <span class="math inline">\(1\)</span> 类点，不难发现在某条路径上确定了 <span class="math inline">\(1\)</span> 类点的数目后，可以直接计算得到一个唯一的 <span class="math inline">\(0\)</span> 类点的数目，而 <span class="math inline">\(1\)</span> 类点的数目的取值范围为 <span class="math inline">\([0,len-1]\)</span>，所以总共不同的路径数最多只有 <span class="math inline">\(|S|\)</span> 条。</p><p>考虑有多少种方案经过某条路径，设 <span class="math inline">\(g_{x,l,r}\)</span> 表示在区间 <span class="math inline">\([l,r]\)</span> 的这段转移中，总共经过 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(1\)</span> 类点的方案数，用记忆化搜索即可求得，我们需要的就是 <span class="math inline">\(g_{x,1,|S|}\)</span>。这部分复杂度 <span class="math inline">\(|S|^3\)</span>。</p><p>在一条路径上面 DP 的复杂度是 <span class="math inline">\(|S|\times n\)</span>，通过矩阵优化可以优化到 <span class="math inline">\(|S|^3\times \log n\)</span>，总复杂度即 <span class="math inline">\(|S|^4\log n\)</span>，虽然仍然过不了，但是优化了很多。</p><p>我们设起点为 <span class="math inline">\(S\)</span>， <span class="math inline">\(0\)</span> 类点为黑色，<span class="math inline">\(1\)</span> 类点为白色，终点为 <span class="math inline">\(T\)</span>，上述过程中的转移图差不多是这样：</p><figure><img src="https://s1.ax1x.com/2020/09/18/w4aqtH.png" alt="w4aqtH.png" /><figcaption>w4aqtH.png</figcaption></figure><p>考虑继续优化，上述算法问题就出在我们对每种路径都跑了一次 DP，考虑把它们合并成一次。先规定所有的路径<span class="math inline">\(0\)</span> 类点都在前面，<span class="math inline">\(1\)</span> 类点都在后面。然后在新的转移图上把第一行放上 <span class="math inline">\(0\)</span> 类点，第二行放上 <span class="math inline">\(1\)</span> 类点，在第一行的点之间连边，第二行的点之间连边，现在就考虑怎么在第一行的点和第二行的点之间连边，不难发现，这种连边实质上代表了一种路径，因为这种边只能走一次，且走这种边就可以确定经过的 <span class="math inline">\(0\)</span> 类点和 <span class="math inline">\(1\)</span> 类点的数目，这样的话复杂度就优化到了 <span class="math inline">\(|S|^3\log n\)</span>。</p><p>把上图按照这种优化连边之后的图就是这样：</p><figure><img src="https://s1.ax1x.com/2020/09/18/w4d83R.png" alt="w4d83R.png" /><figcaption>w4d83R.png</figcaption></figure><p>其中从第一行的点到第二行的点的转移系数为有多少种方案经过这种路径，即 <span class="math inline">\(g_{x,l,r}\)</span>。可以发现这样转化之后只有 <span class="math inline">\(\frac{3}{2}|S|\)</span> 个点，且因为转移图是 DAG 图，所以可以通过编号使得转移都是从编号小的点转移到编号大的点，这样可以得到一个比较优秀的常数优化。复杂度 <span class="math inline">\(|S|^3\log n\)</span>。</p><p>最后还需要考虑一下 <span class="math inline">\(|T|\)</span> 为奇数。我们先把 <span class="math inline">\(|T|\)</span> 的长度看做 <span class="math inline">\(|T|+1\)</span> ，这样就可以得到一个答案。考虑有多少种方案不合法，可以发现是所有最后一步是放两个字符，且恰好在最后一次转移的时候放的方案，我们把这种方案算出来减掉即可。具体的，把所有最后一步是放两个字符的路径拿出来，然后去掉终点的自环再跑一遍上述 DP，这次求出来的答案就是要减掉的方案。</p><p>至此便可完美解决此题。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = i; j &lt;= lim; ++j) &#123;</span><br><span class="line">        re.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = i; k &lt;= j; ++k)</span><br><span class="line">          re.a[i][j] = (re.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; F;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Matpow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Matrix re;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; j &lt;= lim; ++j)</span><br><span class="line">      re.a[i][j] = (i == j);</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[x][l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">  <span class="keyword">if</span> (s[l] == s[r])</span><br><span class="line">    f[x][l][r] = DP(x, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f[x][l][r] = (DP(x - <span class="number">1</span>, l + <span class="number">1</span>, r) + DP(x - <span class="number">1</span>, l, r - <span class="number">1</span>)) % mod;</span><br><span class="line">  <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">int</span> n, len;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; n;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  lim = len + (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">    F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  F.a[lim][lim] = <span class="number">26</span>;</span><br><span class="line">  F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">    ans = F.a[<span class="number">1</span>][lim];</span><br><span class="line">  ans = (ans + F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod) % mod;</span><br><span class="line">  <span class="keyword">if</span> ((n + len) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(F.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(F.a));</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!((len - i) &amp; <span class="number">1</span>))</span><br><span class="line">        F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">      ans = (ans - F.a[<span class="number">1</span>][lim] + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!(len &amp; <span class="number">1</span>))</span><br><span class="line">      ans = (ans - F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道极 (e) 妙 (xin) 的自动机优化 DP 的题目。&lt;/p&gt;
&lt;p&gt;先假设最后得到的字符串为 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;，由题意易知 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 合法当且仅当 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 是回文串且 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的一个子序列。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 是回文串的这个性质我们可以通过从外向内一个一个填字符来实现，所以我们需要 DP 的是 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 相对于 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 而言被匹配了多少个字符。&lt;/p&gt;
&lt;p&gt;特别的，因为当 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的长度为奇数的时候，最后一次填的字符本质上是一个字符，需要特别处理，所以下面我们先讨论 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 的长度为偶数的情况。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="自动机" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Daniel_yuan&#39;s New Blog</title>
    <link href="http://example.com/2020/09/15/Daniel-yuan-s-New-Blog/"/>
    <id>http://example.com/2020/09/15/Daniel-yuan-s-New-Blog/</id>
    <published>2020-09-15T11:04:27.000Z</published>
    <updated>2020-09-15T11:05:00.308Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Daniel_yuan 的新博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是 Daniel_yuan 的新博客。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSP-S 2019 游记</title>
    <link href="http://example.com/2019/11/16/CSP-S%202019%20%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2019/11/16/CSP-S%202019%20%E6%B8%B8%E8%AE%B0/</id>
    <published>2019-11-16T10:48:53.000Z</published>
    <updated>2020-10-06T02:22:16.568Z</updated>
    
    <content type="html"><![CDATA[<p>我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离十一月十六日只不足几天，CSP 的审判快要降临了罢，我正有写一点东西的必要了。（雾</p><a id="more"></a><h2 id="day--1">Day -1</h2><p>教练组织高二的学长出去玩去了，苦逼的我还要接着考 CSP 信(zi)心(bi)赛。/羡慕</p><p>配 <code>emacs</code> 的时候突然忘记 <code>default</code> 怎么写了，一直认为最后两个字母是 <code>te</code> 。最后还是靠着 <code>switch</code> 的高亮打出来的（CSP 前犯这种错误我怕不是要爆零）</p><p>晚上 U 盘坏了，捣鼓了一晚上。</p><p>考前 RP 突然爆炸，感觉吃枣药丸（怕不是 CSP-S RP++ 爆负了……）</p><h2 id="day-0">Day 0</h2><p>上午写了一个线性基板子，一个矩阵快速幂板子，一个 <code>Miller-Rabin</code> 板子。</p><p>之后就欢快地颓了一下午加一晚上。<del>（某乎：如何看待某巨佬 AK CSP-S）</del></p><h2 id="day-1">Day 1</h2><p>在一阵互相膜拜之后进入了考场。</p><p>座位之间有隔板 <del>考试前还在讨论如何用毒瘤码风祸害周围同学</del>，键盘敲起来特别舒服，值得一提的是，<code>Emacs</code> 有配置文件！<del>好评</del>。</p><p>开考后 10 分钟就把 T1 切了。</p><p>T2 像极了考前的一道 <del>九条可怜</del> 的括号匹配题，几分钟码了个 <code>Trie</code> 树就过样例了，然而那个题<strong>忽略括号方向</strong> <del>我给忘了QAQ</del>。</p><p>然后 T3 看上去很玄学的样子，开始手玩，结果手玩不动样例……<del>还不如暴搜</del></p><p>闲的没事就给 T2 写了个对拍，一组就错……</p><p>发现了那个小错误后重新思考做法，发现还是可以用栈的思想，在每次加入或删除一个节点的时候计算贡献，过了样例后接着拍，还是炸了，不过 <del>它已经被我优化到拍几百组错一组了</del>。</p><p>接着调，发现是个小错误，调完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几千组错一组了</del>。</p><p>接着调，又发现个小错误，跳完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几万组错一组了</del>。</p><p>当我百思不得其解时，已经 10:50了 QAQ。</p><p>当我气的去打完 T3 搜索并且想了一下特殊数据后，已经 11:20 了。</p><p>当我感慨造化弄人，以为要命绝于此，要被这次 <code>CSP</code> 送退役时，发现：<strong>我 ** <code>vector</code> 访问了非法内存 ？？？</strong> 。</p><p>改完之后拍几万组都没有问题，不过这次考试也因为 T2 止步 210 了……</p><p>又欢乐地颓了一下午加一晚上。</p><h2 id="day-2">Day 2</h2><p>昨天颓太欢乐了，今早莫名的困……</p><p>感觉今天心态都不一样了……昨天想着怎么拿高分怎么 AK，今天就只想着多拿点分 <del>（还是不能给我这种蒟蒻太高的期望）</del></p><p>开场就写了一个 T1 的 <span class="math inline">\(n^2m\)</span> 的做法，后来发现它假了，只能补上一维保证正确性，最后打了个 <span class="math inline">\(n^3m\)</span> 的 <code>DP</code>。</p><p>然后写 T2，一开始写了一个 <span class="math inline">\(n^3\)</span> 的<code>DP</code>，并且理性分析发现可以优化到 <span class="math inline">\(n^2\)</span> 。经过人(bao)类(li)智(da)慧(biao)后，发现每个以每个点为终点的 <code>DP</code> 值有且仅有一个有用，于是可以使用单调队列优化做到 <span class="math inline">\(O(n)\)</span> ，<del>但是为啥我压 8 位高精都可以MLE，只能过 type=0</del></p><p>最后写 T3，发现暴力分出奇地高，于是写完暴搜后就找特殊数据的规律，<del>还真被我找到了</del>，又骗了一大波分。</p><p>一道题都没切预计都比昨天高……<del>我 ** 昨天在干嘛</del>。</p><h2 id="后记">后记：</h2><p>210 + 247 = 457……没能完成教练定的500分目标<del>AFO AFO</del>……</p><p>趁还没有退役先把游记码了……<del>AFO了就没机会了</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离十一月十六日只不足几天，CSP 的审判快要降临了罢，我正有写一点东西的必要了。（雾&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
