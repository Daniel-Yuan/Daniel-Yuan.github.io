<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel_yuan&#39;s Blog</title>
  
  <subtitle>芙卡米天下第一可爱 n(*≧▽≦*)n</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-28T12:51:28.872Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Daniel_yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ3328 PYXFIB 题解</title>
    <link href="http://example.com/2021/01/28/BZOJ3328-PYXFIB-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2021/01/28/BZOJ3328-PYXFIB-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-01-28T12:26:26.000Z</published>
    <updated>2021-01-28T12:51:28.872Z</updated>
    
    <content type="html"><![CDATA[<p>好像网上没有这么做的题解，所以就写个吧。</p><a id="more"></a><p>直接单位根反演，就有： <span class="math display">\[\frac{1}{k}\sum_{j=0}^{k-1}\sum_{i=0}^n{n \choose i}(\omega_k^j)^iF_i\]</span> 正常的做法是把斐波那契数用矩阵表示，然后用二项式定理。</p><p>考虑直接头铁用通项公式展开斐波那契数，就有 <span class="math display">\[\frac{1}{\sqrt{5}k}\sum_{j=0}^{k-1}\left(\frac{1+\sqrt{5}}{2}(1+\frac{1+\sqrt{5}}{2}\omega_k^j)^n-\frac{1-\sqrt{5}}{2}(1+\frac{1-\sqrt{5}}{2}\omega_k^j)^n\right)\]</span> 在模意义下可能没有 <span class="math inline">\(5\)</span> 的二次剩余，故考虑扩域，把数表示成 <span class="math inline">\(a+b\sqrt{5}\)</span> 的形式。</p><p>定义一下扩域后数的加减乘除然后直接做即可。在这里除法的本质是求逆元，也就是求 <span class="math inline">\(c+d\sqrt{5}\)</span> 使得它和 <span class="math inline">\(a+b\sqrt{5}\)</span> 乘起来为 <span class="math inline">\(1\)</span>。</p><p>不过需要注意的是，当 <span class="math inline">\(P=5\)</span> 的时候，<span class="math inline">\(\frac{1}{\sqrt{5}k}\)</span> 没有逆元，这样就会 WA，考虑特殊处理一下。</p><p>可以发现 <span class="math inline">\(\frac{1}{\sqrt{5}k}\)</span> 表示成 <span class="math inline">\(a+b\sqrt{5}\)</span> 的形式的时候 <span class="math inline">\(a=0\)</span>，那么当 <span class="math inline">\(P\not=5\)</span> 的时候它的逆元 <span class="math inline">\(a=0\)</span>，既然这样，后面的式子求出来的 <span class="math inline">\(a\)</span> 也会等于 <span class="math inline">\(0\)</span>。</p><p>所以我们根本没有必要在这一步把这个复数求逆，直接把 <span class="math inline">\(k\)</span> 求逆乘上后面的式子求出来的 <span class="math inline">\(b\)</span> 即可。</p><p>常数可能会比矩阵乘法的做法小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好像网上没有这么做的题解，所以就写个吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="单位根反演" scheme="http://example.com/tags/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>单位根反演学习笔记</title>
    <link href="http://example.com/2021/01/28/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/01/28/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-28T08:39:39.000Z</published>
    <updated>2021-01-28T09:16:24.028Z</updated>
    
    <content type="html"><![CDATA[<p>以下等式被称作单位根反演：</p><a id="more"></a><p><span class="math display">\[[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}\]</span> 其中 <span class="math inline">\(\omega_n\)</span> 表示在所求域内的 <span class="math inline">\(n\)</span> 次单位根。<span class="math inline">\(n\)</span> 次单位根的定义是，若 <span class="math inline">\(\omega_n\)</span> 是 <span class="math inline">\(n\)</span> 次单位根当且仅当 <span class="math inline">\(\omega_n^0,\omega_n^1...\omega_n^{n-1}\)</span> 互不相同，且 <span class="math inline">\(\omega_n^0=\omega_n^n\)</span>。一般来说所求域会是模大质数 <span class="math inline">\(P\)</span> 的同余域，所以若设 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(P\)</span> 的原根，那么在该域下，<span class="math inline">\(n\)</span> 次单位根为 <span class="math inline">\(g^{\frac{P-1}{n}}\)</span>。</p><p>关于单位根，有个比较显然的等式，即 <span class="math inline">\(\omega_n^k=\omega_n^{k\text{ mod }n}\)</span>。</p><p>基于上面的等式，就有了一种单位根反演证明方法：</p><ol type="1"><li>若 <span class="math inline">\([n|k]\)</span> 那么 <span class="math inline">\(\omega_n^{ik}=1\)</span>，所以右边的式子算出来就是 <span class="math inline">\(1\)</span>。</li><li>反之，<span class="math inline">\(\sum_{i=0}^{n-1}\omega_n^{ik}=\sum_{i=0}^{n-1}(\omega_n^k)^i=\frac{1-\omega_n^n}{1-\omega_n^k}\)</span>，因为前提，分母一定不是 <span class="math inline">\(0\)</span>，而分子为 <span class="math inline">\(0\)</span>，所以整体为 <span class="math inline">\(0\)</span>。</li></ol><p>故得证。</p><hr /><p>虽然单位根反演看上去特别简单，但是在用的时候其实很难把一个式子和单位根反演联系起来，这就需要多加练习。</p><p>举个栗子：<a href="https://loj.ac/p/6485">LOJ #6485 LJJ 学二项式定理</a>。 <span class="math display">\[\begin{aligned}&amp;\sum_{i=0}^n{n \choose i}s^ia_{i\text{ mod }4}\\=&amp;\sum_{i=0}^n{n\choose i}s^i\sum_{j=0}^3[4|i-j]a_j\\=&amp;\sum_{i=0}^n{n\choose i}s^i\sum_{j=0}^3a_j\frac{1}{4}\sum_{k=0}^3\omega_4^{(i-j)k}\\=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\sum_{i=0}^n{n\choose i}s^i\omega_4^{ik-jk}\\=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\omega_4^{-jk}\sum_{i=0}^n{n\choose i}s^i\omega_4^{ik}\\=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\omega_4^{-jk}(1+s\omega_4^k)^n\end{aligned}\]</span> 当然，直接看推式子的话，这道题就浪费了，所以接下来梳理一下解题思路。</p><p>首先直接求和肯定是不好求的，因为后面的下标取模非常麻烦，但是我们可以把后面的模枚举出来，就有了第一步。</p><p>之后直接套用单位根反演，并且可以发现组合数和 <span class="math inline">\(s^i\)</span> 很像二项式定理，所以对单位根的指数进行一些分裂等处理，使得所有和 <span class="math inline">\(i\)</span> 有关的项全部被分离，并且把带 <span class="math inline">\(i\)</span> 的项通过二项式定理合并。</p><p>最后就只需要模拟求和式了，复杂度 <span class="math inline">\(O(9\times \log n)\)</span>。</p><hr /><p>其实很多单位根反演都是把模或者除之类的算术暴力展开，得到一个符合单位根反演的式子之后直接反演，然后通过对单位根指数的分裂与合并，把单位根的各项分配到合适的地方去，之后就通过一些数学方法合并一些式子，使得求和式变得简单。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下等式被称作单位根反演：&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="反演" scheme="http://example.com/tags/%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>[NOI2016] 循环之美 题解</title>
    <link href="http://example.com/2021/01/26/NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2021/01/26/NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-01-26T13:15:59.000Z</published>
    <updated>2021-01-28T08:40:30.738Z</updated>
    
    <content type="html"><![CDATA[<p>手玩发现，一个极简分数，如果其分母和进制的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(1\)</span>，那么就符合题意。</p><p>那么就变成了求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\)</span>。</p><p>其实这个求和式的化简并不难，只是需要多发现式子之间的联系。</p><a id="more"></a><h4 id="展开-ij1">1. 展开 <span class="math inline">\([(i,j)=1]\)</span>。</h4><p><span class="math display">\[\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\\=&amp;\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor\sum_{j=1}^{\lfloor\frac{m}{t}\rfloor}[(tj,k)=1]\\=&amp;\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor[(t,k)=1]\sum_{a|k}\mu(a)\lfloor\frac{m}{ta}\rfloor\\=&amp;\sum_{a|k}\mu(a)\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor[(t,k)=1]\lfloor\frac{m}{ta}\rfloor\end{aligned}\]</span></p><p>后面显然可以整除分块。但是分块后需要求 <span class="math inline">\(\sum_{i=1}^n\mu(i)[(i,k)=1]\)</span>。到在这里博主就不会了，因为这个式子看起来不可推。但是实际上设这个为 <span class="math inline">\(g(n,k)\)</span>，稍加整理： <span class="math display">\[\begin{aligned}&amp;\sum_{i=1}^n\mu(i)[(i,k)=1]\\=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^{\lfloor\frac{n}{a}\rfloor}\mu(ia)\\=&amp;\sum_{a|k}\mu^2(a)\sum_{i=1}^{\lfloor\frac{n}{a}\rfloor}\mu(i)[(i,a)=1]\\=&amp;\sum_{a|k}\mu^2(a)g(\lfloor\frac{n}{a}\rfloor,a)\end{aligned}\]</span> 这个式子暴力推，<span class="math inline">\(g\)</span> 到边界亚线性筛。</p><h4 id="展开-ik1">2. 展开 <span class="math inline">\([(i,k)=1]\)</span>。</h4><p>博主一开始没有想到展开这个，但是这样推相对简单。</p><p><span class="math display">\[\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\\=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac{m}{a}\rfloor}[(i,ja)=1]\\=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac{m}{a}\rfloor}[(i,j)=1][(i,a)=1]\end{aligned}\]</span></p><p>可以发现最后的式子和第一个式子很像，式子答案为 <span class="math inline">\(f(n,m,k)\)</span>，那么就有 <span class="math inline">\(f(n,m,k)=\sum_{a|k}f(\lfloor\frac{m}{a}\rfloor,n,a)\)</span>。到边界直接算即可。</p><hr /><p>可以发现对不同的地方展开，有两个截然不同的结果，虽然最后都可以得到正确答案，但是会有不同的推导难度。</p><p>而不管用什么，最重要的部分都是等效替代，也就是说把某个求和式设成函数 <span class="math inline">\(f\)</span>，然后在推导中注意看式子中有没有重新得到 <span class="math inline">\(f\)</span>，然后就可以得到 <span class="math inline">\(f\)</span> 之间的递推式了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;手玩发现，一个极简分数，如果其分母和进制的 &lt;span class=&quot;math inline&quot;&gt;\(\gcd\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，那么就符合题意。&lt;/p&gt;
&lt;p&gt;那么就变成了求 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其实这个求和式的化简并不难，只是需要多发现式子之间的联系。&lt;/p&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="http://example.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>[NOI2019] 序列 题解</title>
    <link href="http://example.com/2021/01/26/NOI2019-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2021/01/26/NOI2019-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-01-26T01:11:10.000Z</published>
    <updated>2021-01-26T02:51:49.752Z</updated>
    
    <content type="html"><![CDATA[<p>简单学习了模拟费用流之后一直有点迷糊，后来在交流中似乎悟到了些什么。</p><p>能推出这道题挺开心的，而且对模拟费用流有了更进一步的理解。</p><a id="more"></a><p>首先这个题目很容易建出费用流的图。</p><p>考虑每次增广都会新增一对 <span class="math inline">\(a,b\)</span>，那么我们就需要起点向 <span class="math inline">\(\{a\}\)</span> 连边，<span class="math inline">\(\{b\}\)</span> 向终点连边，这样一条路径就一定会对应一对 <span class="math inline">\(a,b\)</span>。</p><p>对于 <span class="math inline">\(K\)</span> 个下标的限制，直接对起点拆点。</p><p>而对于至少的限制，我们把其转化成最多，即最多 <span class="math inline">\(K-L\)</span> 对 <span class="math inline">\(c,d\)</span> 不相同，这样也可以用一条流量为 <span class="math inline">\(K-L\)</span> 的边表示。</p><p>而对于相同和不同的限制，如果相同那么显然可以直接流，即 <span class="math inline">\(a_i\)</span> 向 <span class="math inline">\(b_i\)</span> 连边。而如果不同，那么就需要通过上一行的边，所以建立两个辅助节点 <span class="math inline">\(L,R\)</span>，<span class="math inline">\(L\)</span> 向 <span class="math inline">\(R\)</span> 连 <span class="math inline">\(K-L\)</span> 的边，然后 <span class="math inline">\(\{a\}\)</span> 向 <span class="math inline">\(L\)</span> 连边，<span class="math inline">\(R\)</span> 向 <span class="math inline">\(\{b\}\)</span> 连边。</p><p>因为我们在增广的同时要保证最大，所以在所有起点向 <span class="math inline">\(\{a\}\)</span> 的边上和 <span class="math inline">\(\{b\}\)</span> 向终点的边上加上他们的权值的费用，其它边的费用为 <span class="math inline">\(0\)</span>，这样就有了一个费用流的模型。</p><p><a href="https://imgchr.com/i/sXiJIJ"><img src="https://s3.ax1x.com/2021/01/26/sXiJIJ.png" /></a></p><p>直接费用流肯定过不了，考虑模拟费用流。</p><p>我们可以发现一共有六种增广方式。 <span class="math display">\[\begin{aligned}&amp;S \rightarrow A \rightarrow B \rightarrow T\\&amp;S \rightarrow A \rightarrow L \rightarrow R \rightarrow B \rightarrow T\\&amp;S \rightarrow A_1 \rightarrow L \rightarrow A_2 \rightarrow B_2 \rightarrow T\\&amp;S \rightarrow A_1 \rightarrow B_1 \rightarrow R \rightarrow B_2 \rightarrow T\\&amp;S \rightarrow A_1 \rightarrow L \rightarrow A_2 \rightarrow B_2 \rightarrow R \rightarrow B_3 \rightarrow T\\&amp;S \rightarrow A_1 \rightarrow B_1 \rightarrow R \rightarrow B_2 \rightarrow A_2 \rightarrow L \rightarrow A_3 \rightarrow B_3 \rightarrow T\\\end{aligned}\]</span> 在有下标的路径中，下标相同的点的位置相同。（如 <span class="math inline">\(A_1\)</span> 和 <span class="math inline">\(B_1\)</span> 的）</p><p>可以发现其中只有路径 <span class="math inline">\(2\)</span> 会经过 <span class="math inline">\(L\rightarrow R\)</span> 的边，所以我们可以先贪心把路径 <span class="math inline">\(2\)</span> 走完，然后再增广 <span class="math inline">\(K-L\)</span> 次。</p><p>考虑剩下的增广，设 <span class="math inline">\(P\)</span> 为没选的点的集合，<span class="math inline">\(Q\)</span> 为选了的点，且当前状态是用 <span class="math inline">\(L\rightarrow R\)</span> 边形成的集合，<span class="math inline">\(O\)</span> 为选了的点，且当前状态是用 <span class="math inline">\(A_i\rightarrow B_i\)</span> 的边形成的集合。</p><p>那么对于剩下的五种路径，我们有以下限制： <span class="math display">\[\begin{aligned}A, B   \in &amp;P\\\text{}\\A_1, B_2 \in &amp;P; &amp;A_2     \in &amp;Q\\A_1, B_2 \in &amp;P; &amp;B_1     \in &amp;Q\\A_1, B_3 \in &amp;P; &amp;A_2, B_2 \in &amp;Q\\A_1, B_3 \in &amp;P; &amp;B_1, A_3 \in &amp;Q; &amp;A_2, B_2 \in O\end{aligned}\]</span> 然后在增广完之后，上面的五条路径分别会出现这样的改变：</p><table><colgroup><col style="width: 12%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th></th><th><span class="math inline">\(\text{insert } O\)</span></th><th><span class="math inline">\(\text{delete } O\)</span></th><th><span class="math inline">\(\text{insert } Q\)</span></th><th><span class="math inline">\(\text{delete } Q\)</span></th><th><span class="math inline">\(\text{insert }P\)</span></th><th><span class="math inline">\(\text{delete }P\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\text{path 1}\)</span></td><td><span class="math inline">\(A,B\)</span></td><td></td><td></td><td></td><td></td><td><span class="math inline">\(A,B\)</span></td></tr><tr class="even"><td><span class="math inline">\(\text{path 3}\)</span></td><td><span class="math inline">\(A_2,B_2\)</span></td><td></td><td><span class="math inline">\(A_1\)</span></td><td><span class="math inline">\(A_2\)</span></td><td></td><td><span class="math inline">\(A_1,B_2\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\text{path 4}\)</span></td><td><span class="math inline">\(A_1,B_1\)</span></td><td></td><td><span class="math inline">\(B_2\)</span></td><td><span class="math inline">\(B_1\)</span></td><td></td><td><span class="math inline">\(A_1,B_2\)</span></td></tr><tr class="even"><td><span class="math inline">\(\text{path 5}\)</span></td><td><span class="math inline">\(A_2,B_2\)</span></td><td></td><td><span class="math inline">\(A_2,B_2\)</span></td><td><span class="math inline">\(A_1,B_3\)</span></td><td></td><td><span class="math inline">\(A_1,B_3\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\text{path 6}\)</span></td><td><span class="math inline">\(A_1,B_1,A_3,B_3\)</span></td><td><span class="math inline">\(A_2,B_2\)</span></td><td><span class="math inline">\(B_1,A_3\)</span></td><td><span class="math inline">\(A_2,B_2\)</span></td><td></td><td><span class="math inline">\(A_1,B_3\)</span></td></tr></tbody></table><p>可以发现改变量并不多。</p><p>那么我们用 <span class="math inline">\(5\)</span> 个可删堆，分别维护：<span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(P\)</span> 的和的最大值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(P\)</span> 的最大值，<span class="math inline">\(B\)</span> 在 <span class="math inline">\(P\)</span> 的最大值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(P\)</span> 且 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(Q\)</span> 的最大的 <span class="math inline">\(A\)</span> 的权值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(Q\)</span> 且 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(P\)</span> 的最大的 <span class="math inline">\(B\)</span> 的权值。并同时维护 <span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(Q\)</span>，<span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(O\)</span> 的对数，就可以通过这五个可删堆的拼凑，得到上述五条路径的最大值，修改的时候由于修改量很少，暴力更新可删堆即可。</p><p>总复杂度 <span class="math inline">\(O(\sum n\log \max\{n\})\)</span>。</p><p>贴个代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, id;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v ^ A.v ? v &lt; A.v : id &lt; A.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v == A.v &amp;&amp; id == A.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ErasableHeap</span> &#123;</span></span><br><span class="line">  <span class="built_in">priority_queue</span> &lt;Node&gt; I, O;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (!O.empty() &amp;&amp; I.top() == O.top()) I.pop(), O.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (!I.empty()) I.pop();    <span class="keyword">while</span> (!O.empty()) O.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node x)</span> </span>&#123; I.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(Node x)</span>  </span>&#123; O.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; flush(); <span class="keyword">return</span> I.empty(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Node <span class="title">top</span><span class="params">()</span>   </span>&#123; flush(); <span class="keyword">return</span> I.top();   &#125;</span><br><span class="line">&#125; q1, q2, q3, q4, q5;</span><br><span class="line"><span class="comment">// Max AB in P; Max A in P; Max B in P; Max A in P and B in Q; Max A in Q and B in P;</span></span><br><span class="line"><span class="keyword">int</span> visa[MAXN], visb[MAXN];</span><br><span class="line"><span class="keyword">int</span> stkQ[MAXN], stkO[MAXN];</span><br><span class="line"><span class="comment">// 0 : in P; 1 : in Q; 2 : in O</span></span><br><span class="line"><span class="keyword">int</span> cntO, cntQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">0</span>) q1.erase((Node)&#123;a[x].v + b[x].v, x&#125;);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span>)                 q2.erase(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visb[x] == <span class="number">0</span>)                 q3.erase(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">1</span>) q4.erase(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">0</span>) q5.erase(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">1</span>) --cntQ;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">2</span> &amp;&amp; visb[x] == <span class="number">2</span>) --cntO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertAll</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">0</span>) q1.insert((Node)&#123;a[x].v + b[x].v, x&#125;);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span>)                 q2.insert(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visb[x] == <span class="number">0</span>)                 q3.insert(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">1</span>) q4.insert(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">0</span>) q5.insert(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">1</span>) stkQ[++cntQ] = x;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">2</span> &amp;&amp; visb[x] == <span class="number">2</span>) stkO[++cntO] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushInQ</span><span class="params">(<span class="keyword">int</span> *vis, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  DeleteAll(x);</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  InsertAll(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushInO</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  DeleteAll(x);</span><br><span class="line">  visa[x] = visb[x] = <span class="number">2</span>;</span><br><span class="line">  InsertAll(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> T; read(T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, K, L; read(n), read(K), read(L);</span><br><span class="line">    <span class="keyword">int</span> res = K - L;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      read(a[i].v), a[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      read(b[i].v), b[i].id = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      visa[i] = visb[i] = <span class="number">0</span>;</span><br><span class="line">    cntO = <span class="number">0</span>, cntQ = <span class="number">0</span>;</span><br><span class="line">    q1.clear(); q2.clear(); q3.clear(); q4.clear(); q5.clear();</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.v &gt; y.v; &#125;);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.v &gt; y.v; &#125;);  </span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= res; ++i) &#123;</span><br><span class="line">      ans += a[i].v, visa[a[i].id] = <span class="number">1</span>;</span><br><span class="line">      ans += b[i].v, visb[b[i].id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.id &lt; y.id; &#125;);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.id &lt; y.id; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) InsertAll(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = L;</span><br><span class="line">    <span class="keyword">while</span> (L--) &#123;</span><br><span class="line">      LL val1 = q1.top().v;</span><br><span class="line">      LL val2 = !q2.empty() &amp;&amp; !q5.empty() ? q2.top().v + q5.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val3 = !q3.empty() &amp;&amp; !q4.empty() ? q3.top().v + q4.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val4 = cntQ &amp;&amp; !q2.empty() &amp;&amp; !q3.empty() ? q2.top().v + q3.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val5 = cntO &amp;&amp; !q4.empty() &amp;&amp; !q5.empty() ? q4.top().v + q5.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      <span class="keyword">if</span> (val1 &gt; val2 &amp;&amp; val1 &gt; val3 &amp;&amp; val1 &gt; val4 &amp;&amp; val1 &gt; val5) &#123;</span><br><span class="line">        ans += val1;</span><br><span class="line">        PushInO(q1.top().id);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val2 &gt; val3 &amp;&amp; val2 &gt; val4 &amp;&amp; val2 &gt; val5) &#123;</span><br><span class="line">        ans += val2;</span><br><span class="line">        <span class="keyword">int</span> tmp = q5.top().id;</span><br><span class="line">        PushInQ(visa, q2.top().id);</span><br><span class="line">        PushInO(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val3 &gt; val4 &amp;&amp; val3 &gt; val5) &#123;</span><br><span class="line">        ans += val3;</span><br><span class="line">        <span class="keyword">int</span> tmp = q4.top().id;</span><br><span class="line">        PushInQ(visb, q3.top().id);</span><br><span class="line">        PushInO(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val4 &gt; val5) &#123;</span><br><span class="line">        ans += val4;</span><br><span class="line">        <span class="keyword">int</span> t1 = q2.top().id, t2 = q3.top().id;</span><br><span class="line">        PushInO(stkQ[cntQ]);</span><br><span class="line">        PushInQ(visa, t1);</span><br><span class="line">        PushInQ(visb, t2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += val5;</span><br><span class="line">        <span class="keyword">int</span> t1 = q4.top().id, t2 = q5.top().id, t3 = stkO[cntO];</span><br><span class="line">        PushInQ(visa, t3), PushInQ(visb, t3);</span><br><span class="line">        PushInO(t1);</span><br><span class="line">        PushInO(t2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">S -&gt; A -&gt; B -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A -&gt; L -&gt; R -&gt; B -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; L -&gt; A2 -&gt; B2 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; B1 -&gt; R -&gt; B2 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; L -&gt; A2 -&gt; B2 -&gt; R -&gt; B3 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; B1 -&gt; R -&gt; B2 -&gt; A2 -&gt; L -&gt; A3 -&gt; B3 -&gt; T</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, use all of the path 2</span></span><br><span class="line"><span class="comment">Then, expand rest times</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Let P is a set of the nodes not be chosen, Q is a set of the nodes be chosen into LR, Otherwise is O.</span></span><br><span class="line"><span class="comment">path 1 : A, B   in P                            O : A, B   insert</span></span><br><span class="line"><span class="comment">path 3 : A1, B2 in P; A2     in Q               O : A2, B2 insert                         Q : A2 delete,     A1     insert</span></span><br><span class="line"><span class="comment">path 4 : A1, B2 in P; B1     in Q               O : A1, B1 insert                         Q : B1 delete,     B2     insert</span></span><br><span class="line"><span class="comment">path 5 : A1, B3 in P; A2, B2 in Q               O : A2, B2 insert                         Q : A2, B2 delete, A1, B3 insert</span></span><br><span class="line"><span class="comment">path 6 : A1, B3 in P; B1, A3 in Q; A2, B2 in O  O : A2, B2 delete, A1, B1, A3, B3 insert  Q : B1, A3 delete, A2, B2 insert</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; (<span class="keyword">double</span>)(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>最后再来个总结：</p><p>模拟费用流究其根本是先建图，然后再分析图进行贪心模拟。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单学习了模拟费用流之后一直有点迷糊，后来在交流中似乎悟到了些什么。&lt;/p&gt;
&lt;p&gt;能推出这道题挺开心的，而且对模拟费用流有了更进一步的理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="http://example.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
    <category term="模拟费用流" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>DP of DP</title>
    <link href="http://example.com/2021/01/21/DP-of-DP/"/>
    <id>http://example.com/2021/01/21/DP-of-DP/</id>
    <published>2021-01-21T11:53:34.000Z</published>
    <updated>2021-01-21T12:37:37.879Z</updated>
    
    <content type="html"><![CDATA[<p>做过不少 DP of DP 题，但是考试还是想不到，很气，写个总结记录下。</p><a id="more"></a><p>对于一个题目，如果它要求的是在某个限制下计数，并且在看一个状态有没有满足限制的时候也需要 DP，这时候往往就要用到 DP of DP。</p><p>一般的流程是这样的，我们先考虑对于一个已知状态，怎么判定其是否满足性质。这时候我们一般都会有一个 DP，且这个 DP 是用增量法填表的，即类似于 <span class="math inline">\(f_{i,...}\)</span> 表示前 <span class="math inline">\(i\)</span> 个位置（或其它）怎么怎么样。然后因为我们的根本需求是计数，而计数我们也用到增量法，所以可以把 <span class="math inline">\(f_{i,...}\)</span> 的 <span class="math inline">\(i\)</span> 放到外层 DP 处，然后把剩下的 <span class="math inline">\(f_{...}\)</span> 给排成一列压缩起来，变成一个状态。这样在外层我们就得到了 <span class="math inline">\(F_{i,S}\)</span>，表示考虑前 <span class="math inline">\(i\)</span> 个位置（或其它），内层 DP 的状态是 <span class="math inline">\(S\)</span> 的方案数。在转移 <span class="math inline">\(i+1\)</span> 的时候，我们把 <span class="math inline">\(S\)</span> 还原成内层 DP 数组 <span class="math inline">\(f_{...}\)</span>，然后对 <span class="math inline">\(f_{...}\)</span> 和 <span class="math inline">\(i+1\)</span> 跑内层 DP 得到一个新状态<span class="math inline">\(f^{&#39;}_{...}\)</span> 并重新压缩成 <span class="math inline">\(T\)</span>，这样就可以从 <span class="math inline">\(F_{i,S}\)</span> 转移到 <span class="math inline">\(F_{i+1,T}\)</span>。</p><p>考虑看一道例题：</p><blockquote><p>给一个小写字母字符串 <span class="math inline">\(S\)</span>，<span class="math inline">\(|S|\leq15\)</span>，问有多少个长度为 <span class="math inline">\(n\)</span>，<span class="math inline">\((n\leq 100)\)</span> 的小写字母字符串 <span class="math inline">\(T\)</span>，使得 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 的最长上升子序列的长度为 <span class="math inline">\(k\)</span>。对于 <span class="math inline">\(k=0,1,2...|S|\)</span> 都要求答案。</p></blockquote><p>经典题，按照上面的流程来做。</p><p>首先对于一个已知字符串 <span class="math inline">\(T\)</span>，考虑求它的最长上升子序列。设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前 <span class="math inline">\(i\)</span> 个字符，<span class="math inline">\(S\)</span> 的前 <span class="math inline">\(j\)</span> 个字符的最长上升子序列最长是多少。这个 DP 符合增量法，所以把 <span class="math inline">\(f_{1,2...j}\)</span> 压缩成一个状态 <span class="math inline">\(S\)</span>。在外层，设 <span class="math inline">\(F_{i,S}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前 <span class="math inline">\(i\)</span> 个字符，<span class="math inline">\(f_{i,\{0,1...|S|\}}\)</span> 算出来的值状压起来为 <span class="math inline">\(S\)</span> 的方案数。转移的时候，枚举下一个字符填什么，然后把 <span class="math inline">\(S\)</span> 还原成 <span class="math inline">\(f\)</span>，然后计算出新的 <span class="math inline">\(f&#39;\)</span>，再状压回 <span class="math inline">\(T\)</span>，就可以从 <span class="math inline">\(F_{i,S}\)</span> 转移到 <span class="math inline">\(F_{i+1,T}\)</span> 了。</p><p>这样我们就完成了普通的 DP of DP，但是这样复杂度有问题，因为 <span class="math inline">\(f\)</span> 的取值范围是 <span class="math inline">\([0,15]\)</span> 压起来特别大，但是我们发现 <span class="math inline">\(f_i-f_{i-1}\in[0,1]\)</span>，所以可以把 <span class="math inline">\(f_i-f_{i-1}\)</span> 压起来，这样 <span class="math inline">\(F_{i,S}\)</span> 的 <span class="math inline">\(S\)</span> 的取值只有 <span class="math inline">\(2^{15}\)</span> 了。</p><p>代码如下，这里只实现了字符集为 <span class="math inline">\(\{N,O,I\}\)</span> 。原题是 <a href="https://www.luogu.com.cn/problem/P4590">[TJOI2018] 游园会</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>], g[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> Trans[<span class="number">1</span> &lt;&lt; <span class="number">15</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">3</span>][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> bitcnt[<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> Ans[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y - mod, x += (x &gt;&gt; <span class="number">31</span>) &amp; mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI S = <span class="number">0</span>, NS; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      f[i] = f[i - <span class="number">1</span>] + ((S &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;N&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">0</span>] = NS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;O&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">1</span>] = NS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;I&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">2</span>] = NS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur = <span class="number">1</span>, nxt = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    swap(cur, nxt);</span><br><span class="line">    <span class="built_in">memset</span>(dp[nxt], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[nxt]));</span><br><span class="line">    <span class="keyword">for</span> (RI S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">2</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">2</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">2</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">2</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">2</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S)</span><br><span class="line">    bitcnt[S] = bitcnt[S ^ (S &amp; (-S))] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S)</span><br><span class="line">      Add(Ans[bitcnt[S]], dp[nxt][i][S]);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们肯定不仅仅满足这个普通的 DP of DP，我们需要更便捷的东西——自动机。</p><p>也就是说我们干脆就直接把 <span class="math inline">\(S\)</span> 看成是一个状态的集合，然后把所有的状态的集合建出一个转移的自动机。一个自动机上面的节点代表着一个状态，而转移边就代表着这个状态加入一个东西后可以转移到哪里。这样我们的 DP 就变成了一个普通的自动机上 DP。</p><p>典型例子是 <a href="https://www.luogu.com.cn/problem/P5279">[ZJOI2019] 麻将</a>，可以结合<a href="https://daniel-yuan.github.io/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/#more">我的这篇博客</a>把这个题切了。</p><p><del>（不知为何写着写着就变成一个普及 DP of DP 的博客了……）</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做过不少 DP of DP 题，但是考试还是想不到，很气，写个总结记录下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="DP of DP" scheme="http://example.com/tags/DP-of-DP/"/>
    
  </entry>
  
  <entry>
    <title>[ZJOI2019] 麻将 题解</title>
    <link href="http://example.com/2021/01/21/ZJOI2019-%E9%BA%BB%E5%B0%86-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2021/01/21/ZJOI2019-%E9%BA%BB%E5%B0%86-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-01-21T00:33:52.000Z</published>
    <updated>2021-01-21T01:13:52.612Z</updated>
    
    <content type="html"><![CDATA[<p>首先对于已有的一堆牌，我们应该要能确定它能不能胡。</p><p>这部分具体的可以参考<a href="https://daniel-yuan.github.io/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/#more">我的另一篇博客</a>，顺带说一句，[ZJOI2019] 麻将的前置知识居然被拿去 [GXOI/GZOI2019] 出了个宝牌一大堆<del>，ZJOI 恐怖如斯</del>。</p><a id="more"></a><p>回到这个题目，对于一个已知状态，我们可以设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 张牌，<span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，<span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，有无雀头的最大面子数。</p><p>但是现在状态是未知的，所以考虑 DP of DP，即把这个 <span class="math inline">\(f\)</span> 压到状态里面去。为了方便，我们把 <span class="math inline">\(f_{0/1/2,0/1/2,0/1}\)</span> （注意到这里已经忽略了 <span class="math inline">\(i\)</span>，因为 <span class="math inline">\(i\)</span> 对转移没有影响）建一个自动机。而自动机上面的信息就是形如 <span class="math inline">\(f_{0,0,0}=x,f_{0,0,1}=y...\)</span> 这样的多元组，因为还有七对子的特殊牌型，所以在自动机上面额外记录一个 <span class="math inline">\(cnt\)</span> 表示对子数。</p><p>乍一看，一共有 <span class="math inline">\(3\times 3\times 2=18\)</span> 个 <span class="math inline">\(f\)</span> 状态，而 <span class="math inline">\(f\)</span> 的取值有 <span class="math inline">\(0/1/2/3/4\)</span> 五种（大于 <span class="math inline">\(4\)</span> 已经没有意义，故可以限制最大值为 <span class="math inline">\(4\)</span>），并且还有一个额外的 <span class="math inline">\(cnt\)</span> 需要记录，自动机上的节点数会达到 <span class="math inline">\(5^{18}\times 8=3.0517578125×10^{13}\)</span>，我们难以承受。但是显然有很多状态不会被涉及到，比如说 <span class="math inline">\(f_{0,0,0}=3\)</span> 的时候任何 <span class="math inline">\(f\)</span> 值都不会小于 <span class="math inline">\(3\)</span>。所以我们可以写一个 BFS 去看看自动机节点数有多少。特别的，如果 <span class="math inline">\(cnt=7\)</span> 或者 <span class="math inline">\(f_{0,0,0}=4\)</span>，那么已经胡牌，我们可以建立一个胡牌节点，与此同时，我们也可以把转移边记录下来，特别的，胡牌节点只有自环。代码形如这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">map &lt;Status, int&gt; mp;</span><br><span class="line">void GetStatus() &#123;</span><br><span class="line">  Status t, nxt; &#x2F;&#x2F; 这是一个定义状态的结构体</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  q.push(t), mp[t] &#x3D; ++cnt;</span><br><span class="line">  while (t.cnt !&#x3D; -1) t.Trans(2); &#x2F;&#x2F; 这里是构造一个胡牌节点</span><br><span class="line">  mp[t] &#x3D; ++cnt;</span><br><span class="line">  for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i)</span><br><span class="line">    child[mp[t]][i] &#x3D; mp[t];</span><br><span class="line">  while (!q.empty()) &#123;</span><br><span class="line">    t &#x3D; q.front(); q.pop();</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i) &#123;</span><br><span class="line">      nxt &#x3D; t, nxt.Trans(i); &#x2F;&#x2F; 更新 f</span><br><span class="line">      if (mp.find(nxt) &#x3D;&#x3D; mp.end())</span><br><span class="line">        q.push(nxt), mp[nxt] &#x3D; ++cnt; &#x2F;&#x2F; 新建节点</span><br><span class="line">      child[mp[t]][i] &#x3D; mp[nxt]; &#x2F;&#x2F; 记录转移边</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt; 100000) break; &#x2F;&#x2F; protection</span><br><span class="line">  &#125;</span><br><span class="line">  length &#x3D; mp.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 <span class="math inline">\(f\)</span> 具体怎么转移大家可以自己推一推。</p><p>然后你会发现搜出来只有 1566 个节点（我也不知道为什么和很多博客上写的都不同，我还怀疑了自己好久……），于是我们就可以根据这个来 DP 了（可以把节点看做是内部的 DP）。</p><p>设 <span class="math inline">\(g_{i,j,k}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，当前牌长度为 <span class="math inline">\(j\)</span>，在自动机上面的点 <span class="math inline">\(k\)</span> 的方案数。转移的时候枚举这一种牌有多少张即可，复杂度 <span class="math inline">\(O(n^2\times 1566)\)</span>。因为相同种类的牌是有编号区分的，所以转移的时候一定要乘组合数（被卡了好久）。</p><p>最后再考虑计算答案。对于一个至少 <span class="math inline">\(k\)</span> 次才能胡牌的状态，它对答案的贡献为 <span class="math inline">\(k\)</span>。因为是至少，不好直接求，考虑转化成至多。即改成对于一个至多 <span class="math inline">\(k-1\)</span> 次都不能胡牌的状态，它对答案的贡献为 <span class="math inline">\(k\)</span>。而这个状态在 <span class="math inline">\(1\sim k-1\)</span> 次都不能胡牌。所以我们可以把贡献拆分到 <span class="math inline">\(1\sim k-1\)</span> 上面去，每个部分的权值为 <span class="math inline">\(1\)</span>。（或者说 <span class="math inline">\(k=\sum_{i=1}^k1\)</span>？）。</p><p>那么最终答案就是 <span class="math inline">\(\frac{\sum_{i=14}^{4n}\sum_{j=1}^{len}g_{n,i,j}(4n-i)!(i-13)![\text{ $j$ 不是胡牌节点 }]}{(4n-13)!}+1\)</span>。代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define debug(...) fprintf(stderr, __VA_ARGS__)</span><br><span class="line">#define RI register int</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">#define FILEIO(name) freopen(name&quot;.in&quot;, &quot;r&quot;, stdin), freopen(name&quot;.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Status &#123; &#x2F;&#x2F; 自动机中的状态</span><br><span class="line">  int f[3][3][2], cnt;</span><br><span class="line">  Status () &#123;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          f[i][j][k] &#x3D; -0x3f3f3f3f;</span><br><span class="line">    cnt &#x3D; f[0][0][0] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  void Trans(int res) &#123; &#x2F;&#x2F; 自动机状态的内部转移</span><br><span class="line">    Status nxt;</span><br><span class="line">    int win &#x3D; 0;</span><br><span class="line">    nxt.cnt &#x3D; cnt + (res &gt;&#x3D; 2);</span><br><span class="line">    win |&#x3D; (nxt.cnt &gt;&#x3D; 7);</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k) &#123;</span><br><span class="line">          for (RI lasi &#x3D; 0; lasi &lt;&#x3D; 2; ++lasi)</span><br><span class="line">            for (RI lask &#x3D; 0; lask &lt;&#x3D; k; ++lask) &#123;</span><br><span class="line">              int ned &#x3D; lasi + i + j + 2 * (k - lask);</span><br><span class="line">              if (ned &gt; res) continue;</span><br><span class="line">              nxt.f[i][j][k] &#x3D; min(4, max(nxt.f[i][j][k], f[lasi][i][lask] + j + (res - ned &gt;&#x3D; 3)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          if (nxt.f[i][j][k] &lt; 0)</span><br><span class="line">            nxt.f[i][j][k] &#x3D; -0x3f3f3f3f;</span><br><span class="line">    win |&#x3D; (nxt.f[0][0][1] &gt;&#x3D; 4);</span><br><span class="line">    if (win) &#x2F;&#x2F; 判胡牌</span><br><span class="line">      for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">        for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">          for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">            nxt.f[i][j][k] &#x3D; nxt.cnt &#x3D; -1;</span><br><span class="line">    *this &#x3D; nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  bool operator &lt; (const Status &amp;A) const &#123;</span><br><span class="line">    if (cnt !&#x3D; A.cnt) return cnt &lt; A.cnt;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          if (f[i][j][k] !&#x3D; A.f[i][j][k])</span><br><span class="line">            return f[i][j][k] &lt; A.f[i][j][k];</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">map &lt;Status, int&gt; mp;</span><br><span class="line">queue &lt;Status&gt; q;</span><br><span class="line">int const MAXN &#x3D; 2005, mod &#x3D; 998244353;</span><br><span class="line">int child[MAXN][5];</span><br><span class="line">int f[2][405][MAXN];</span><br><span class="line">int tong[105];</span><br><span class="line">int length;</span><br><span class="line">LL frac[MAXN], invfrac[MAXN];</span><br><span class="line"></span><br><span class="line">LL qpow(LL a, LL k) &#123;</span><br><span class="line">  LL re &#x3D; 1;</span><br><span class="line">  for (; k; k &gt;&gt;&#x3D; 1, a &#x3D; a * a % mod)</span><br><span class="line">    if (k &amp; 1) re &#x3D; re * a % mod;</span><br><span class="line">  return re;</span><br><span class="line">&#125;</span><br><span class="line">void Init(int Max) &#123;</span><br><span class="line">  frac[0] &#x3D; 1;</span><br><span class="line">  for (RI i &#x3D; 1; i &lt;&#x3D; Max; ++i)</span><br><span class="line">    frac[i] &#x3D; frac[i - 1] * i % mod;</span><br><span class="line">  invfrac[Max] &#x3D; qpow(frac[Max], mod - 2);</span><br><span class="line">  for (RI i &#x3D; Max; i &gt;&#x3D; 1; --i)</span><br><span class="line">    invfrac[i - 1] &#x3D; invfrac[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetStatus() &#123; &#x2F;&#x2F; 上文已经解释了</span><br><span class="line">  Status t, nxt;</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  q.push(t), mp[t] &#x3D; ++cnt;</span><br><span class="line">  while (t.cnt !&#x3D; -1) t.Trans(2);</span><br><span class="line">  mp[t] &#x3D; ++cnt;</span><br><span class="line">  for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i)</span><br><span class="line">    child[mp[t]][i] &#x3D; mp[t];</span><br><span class="line">  while (!q.empty()) &#123;</span><br><span class="line">    t &#x3D; q.front(); q.pop();</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i) &#123;</span><br><span class="line">      nxt &#x3D; t, nxt.Trans(i);</span><br><span class="line">      if (mp.find(nxt) &#x3D;&#x3D; mp.end())</span><br><span class="line">        q.push(nxt), mp[nxt] &#x3D; ++cnt;</span><br><span class="line">      child[mp[t]][i] &#x3D; mp[nxt];</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt; 100000) break; &#x2F;&#x2F; protection</span><br><span class="line">  &#125;</span><br><span class="line">  length &#x3D; mp.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void Add(int &amp;x, int y) &#123; x +&#x3D; y - mod; x +&#x3D; (x &gt;&gt; 31) &amp; mod; &#125;</span><br><span class="line"></span><br><span class="line">LL C[10][10];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  </span><br><span class="line">#ifdef LOCAL</span><br><span class="line">  FILEIO(&quot;a&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  GetStatus();</span><br><span class="line">  int n; cin &gt;&gt; n;</span><br><span class="line">  C[0][0] &#x3D; 1;</span><br><span class="line">  C[1][0] &#x3D; C[1][1] &#x3D; 1;</span><br><span class="line">  C[2][0] &#x3D; C[2][2] &#x3D; 1, C[2][1] &#x3D; 2;</span><br><span class="line">  C[3][0] &#x3D; C[3][3] &#x3D; 1, C[3][1] &#x3D; C[3][2] &#x3D; 3;</span><br><span class="line">  C[4][0] &#x3D; C[4][4] &#x3D; 1, C[4][1] &#x3D; C[4][3] &#x3D; 4, C[4][2] &#x3D; 6;</span><br><span class="line">  Init(4 * n);</span><br><span class="line">  for (RI i &#x3D; 1, x, y; i &lt;&#x3D; 13; ++i)</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y, ++tong[x];</span><br><span class="line">  int cur &#x3D; 0, nxt &#x3D; 1;</span><br><span class="line">  f[nxt][0][1] &#x3D; 1;</span><br><span class="line">  for (RI i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; &#x2F;&#x2F; 简单 DP</span><br><span class="line">    swap(cur, nxt);</span><br><span class="line">    memset(f[nxt], 0, sizeof(f[nxt]));</span><br><span class="line">    for (RI j &#x3D; 0; j &lt;&#x3D; 4 * (i - 1); ++j)</span><br><span class="line">      for (RI now &#x3D; 1; now &lt;&#x3D; length; ++now)</span><br><span class="line">        for (RI k &#x3D; tong[i]; k &lt;&#x3D; 4; ++k)</span><br><span class="line">          Add(f[nxt][j + k][child[now][k]], 1ll * f[cur][j][now] * C[4 - tong[i]][k - tong[i]] % mod);</span><br><span class="line">  &#125;</span><br><span class="line">  int ans &#x3D; 0;</span><br><span class="line">  for (RI i &#x3D; 14; i &lt;&#x3D; 4 * n; ++i)</span><br><span class="line">    for (RI j &#x3D; 1; j &lt;&#x3D; length; ++j)</span><br><span class="line">      if (j !&#x3D; 2)</span><br><span class="line">        Add(ans, 1ll * f[nxt][i][j] * frac[4 * n - i] % mod * frac[i - 13] % mod);</span><br><span class="line">  ans &#x3D; (1ll * ans * invfrac[4 * n - 13] % mod + 1) % mod;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; created by Daniel yuan</span><br><span class="line">&#x2F;*</span><br><span class="line">     ________</span><br><span class="line">    &#x2F;        \</span><br><span class="line">   &#x2F; &#x2F;      \ \</span><br><span class="line">  &#x2F; &#x2F;        \ \</span><br><span class="line">  \            &#x2F;</span><br><span class="line">   \  ______  &#x2F;</span><br><span class="line">    \________&#x2F;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先对于已有的一堆牌，我们应该要能确定它能不能胡。&lt;/p&gt;
&lt;p&gt;这部分具体的可以参考&lt;a href=&quot;https://daniel-yuan.github.io/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/#more&quot;&gt;我的另一篇博客&lt;/a&gt;，顺带说一句，[ZJOI2019] 麻将的前置知识居然被拿去 [GXOI/GZOI2019] 出了个宝牌一大堆&lt;del&gt;，ZJOI 恐怖如斯&lt;/del&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="自动机" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="DP of DP" scheme="http://example.com/tags/DP-of-DP/"/>
    
  </entry>
  
  <entry>
    <title>麻将相关</title>
    <link href="http://example.com/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/</id>
    <published>2021-01-19T13:39:20.000Z</published>
    <updated>2021-01-21T00:31:44.002Z</updated>
    
    <content type="html"><![CDATA[<p><del>不会打麻将的 OIer 不是好 ACMer。</del></p><p>虽然看完这篇博客你可能并不会变成雀神，但是你可能看到和麻将有关的题目就不会那么慌了。</p><a id="more"></a><p>麻将的一般规则本文就不再赘述，啥搜索引擎上都有。<del>实在不行下个雀魂玩玩也是可以的。</del></p><p>麻将题一般有两种做法：搜索和 DP。</p><h4 id="搜索">搜索：</h4><p>大多数时候是给出一副牌，看至少需要再摸几张牌才能胡。</p><p>考虑枚举合法终态，然后用牌数的差更新答案。</p><p>因为刻子和雀头都是多张同一个牌，所以这一块可以贪心，即从四张相同到一张相同的牌依次去匹配刻子和雀头，为了方便，可以设 <span class="math inline">\(dp_{i,j,k,l}\)</span> 表示有 <span class="math inline">\(i\)</span> 个四张，<span class="math inline">\(j\)</span> 个三张，<span class="math inline">\(k\)</span> 个二张拼成 <span class="math inline">\(l\)</span> 个面子加上一个雀头最少需要多少张牌，在搜索顺子的同时维护一下 <span class="math inline">\(i,j,k,l\)</span> 的值，然后直接更新答案即可。</p><p>然后考虑怎么搜索顺子，我们事先把所有的顺子预处理出来，共 <span class="math inline">\(27\)</span> 个，然后按层搜索枚举每个顺子有没有。这样复杂度是 <span class="math inline">\(O(27^4)\)</span>，显然不好。实际上，我们枚举的顺子在此刻至少要有两张牌存在于手牌中，因为如果只有一张，那么对额外牌数的贡献为 <span class="math inline">\(2\)</span>，而这张牌形成的刻子贡献的额外牌数也是 <span class="math inline">\(2\)</span>，这样可以把它算到刻子里面。</p><p>实际上这样优化下来判定是十分快的，博主认为其复杂度不会超过 <span class="math inline">\(10^4\)</span>。</p><h4 id="dp">DP：</h4><p>搜索写起来比较方便，但是搜索毕竟复杂度是指数级别的，它的速度还是慢了点，所以再介绍一种 DP 的做法。</p><p>依旧是考虑给出一副牌，看至少需要再摸几张牌才能胡。</p><p>设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1/2/3/4,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，以 <span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，以 <span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，面子一共有 <span class="math inline">\(0/1/2/3/4\)</span> 个，有 <span class="math inline">\(0/1\)</span> 个雀头的最小花费。转移的时候枚举下一种牌有几张即可。后面一堆东西看似有 <span class="math inline">\(90\)</span> 个，但是实际上仅有 <span class="math inline">\(50+\)</span> 个，且转移的时候转移边数不会很多。如果在这个上面再用上【搜索中的优化】，效率会更加高。（似乎这里不太严谨，但是跑得很快就对了）</p><p>从这也可以衍生出判定一个牌的集合中存不存在一个胡牌子集的方法，即设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，以 <span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，以 <span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，有 <span class="math inline">\(0/1\)</span> 个雀头的最大面子数。如果有一个有雀头的状态的面子数到了 <span class="math inline">\(4\)</span>，那么就可行。</p><hr /><p>想必看完之后你就已经会打麻将了，<a href="https://www.luogu.com.cn/problem/P5279">[ZJOI2019] 麻将</a>和<a href="https://www.luogu.com.cn/problem/P5301">[GXOI/GZOI2019]宝牌一大堆</a>自然不在话下（其实后者真心就是只考了上述内容）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;不会打麻将的 OIer 不是好 ACMer。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;虽然看完这篇博客你可能并不会变成雀神，但是你可能看到和麻将有关的题目就不会那么慌了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>[ZJOI2019]开关 题解</title>
    <link href="http://example.com/2021/01/19/ZJOI2019-%E5%BC%80%E5%85%B3-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2021/01/19/ZJOI2019-%E5%BC%80%E5%85%B3-%E9%A2%98%E8%A7%A3/</id>
    <published>2021-01-19T03:43:46.000Z</published>
    <updated>2021-01-19T08:50:34.645Z</updated>
    
    <content type="html"><![CDATA[<p>把初始状态和目标状态交换，题目不变。</p><p>为了方便，设 <span class="math inline">\(p_i\)</span> 为 <span class="math inline">\(i\)</span> 被选的概率，对应到输入即 <span class="math inline">\(\frac{p_i}{\sum_{j=1}^n p_j}\)</span> 。</p><p>设 <span class="math inline">\(f(S)\)</span> 表示从 <span class="math inline">\(S\)</span> 状态开始，期望走 <span class="math inline">\(f(S)\)</span> 步到达全零状态。为了方便，我们定义 <span class="math inline">\(\varnothing\)</span> 表示全零状态。</p><p>那么显然有<a id="more"></a> <span class="math inline">\(f(S)=\begin{cases}0&amp;S=\varnothing\\1+\sum p_if_{S \text{ xor } i}&amp;S\not=\varnothing\end{cases}\)</span>。</p><p>如果把 <span class="math inline">\(f(S)\)</span> 看做是集合幂级数 <span class="math inline">\(F=\sum_S f(S)x^S\)</span>，下半部分的 <span class="math inline">\(\sum\)</span> 可以看做是一个异或卷积（更多有关位运算的卷积，可以参考<a href="https://daniel-yuan.github.io/2021/01/19/FWT-%E5%B0%8F%E7%BB%93/#more">我的另一篇博客</a>），那么我们设另一个集合幂级数 <span class="math inline">\(G=\sum_S g(S)x^S\)</span>，其中 <span class="math inline">\(g(S)\)</span> 在 <span class="math inline">\(S\)</span> 中仅含一个元素 <span class="math inline">\(k\)</span> 的时候为 <span class="math inline">\(p_k\)</span>，否则为 <span class="math inline">\(0\)</span>。那么下半部分的 <span class="math inline">\(\sum\)</span> 就可以看做是 <span class="math inline">\(F*G\)</span>。</p><p>不看 <span class="math inline">\(\varnothing\)</span>，我们有 <span class="math inline">\(F*G+1=F\)</span>，即 <span class="math inline">\(F*(G-1)=-1\)</span>，为了方便，把 <span class="math inline">\(g(S)\)</span> 做一个微调，即 <span class="math inline">\(g(S)=\begin{cases}-1&amp;S=\varnothing\\p_i&amp;|S|=1,S\text{ 中的元素为 }i\\0&amp;|S|&gt;1\end{cases}\)</span>。这样在不考虑 <span class="math inline">\(\varnothing\)</span> 的时候，<span class="math inline">\(F*G=-1\)</span>。</p><p>考虑 <span class="math inline">\(F*G\)</span> 的 <span class="math inline">\(\varnothing\)</span> 项是什么，我们可以知道 <span class="math inline">\(\sum_i(F*G)(i)=\sum_{i,j} F(i)G(j)\)</span>，因为 <span class="math inline">\(\sum_iG(i)=0\)</span>，所以右边为 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(\sum_i(F*G)(i)=0\)</span>，所以可以推出 <span class="math inline">\((F*G)(\varnothing)=2^n-1\)</span>。</p><p>设 <span class="math inline">\(H=F*G\)</span>，那么就有 <span class="math inline">\(h(S)=\begin{cases}2^n-1&amp;S=\varnothing\\-1&amp;S\not=\varnothing\end{cases}\)</span>。</p><p><span class="math inline">\(G,H\)</span> 我们都知道，考虑反推 <span class="math inline">\(F\)</span>。</p><p>设 <span class="math inline">\(FWTX\)</span> 为集合幂级数 <span class="math inline">\(X\)</span> 在 <span class="math inline">\(FWT\)</span> 之后的结果。根据异或卷积 <span class="math inline">\(FWT\)</span> 的公式（在上面给出的博客有详细介绍）<span class="math inline">\(F(i)=\sum_j(-1)^{|i\text{ and }j|}F(j)\)</span>，不难得到 <span class="math inline">\(FWTG(S)=\begin{cases}0&amp;S=\varnothing\\\sum_{|T|=1}(-1)^{|S\text{ and T|}}p-1&amp;S\not=\varnothing\end{cases}\)</span>，<span class="math inline">\(FWTH(S)=\begin{cases}0&amp;S=\varnothing\\2^n&amp;S\not=\varnothing\end{cases}\)</span>。对于前者，就是照搬式子，然后在 <span class="math inline">\(S=\varnothing\)</span> 处特别展开一下。对于后者，<span class="math inline">\(S=\varnothing\)</span> 的部分是 <span class="math inline">\(H(S)\)</span> 全部相加显然为 <span class="math inline">\(0\)</span>，而其它位置，对 <span class="math inline">\(FWTH(S)\)</span> 贡献为正的 <span class="math inline">\(H(S)\)</span> 和负的 <span class="math inline">\(H(S)\)</span> 应该各占一半，而 <span class="math inline">\(H(\varnothing)\)</span> 的贡献为正，那么剩下的部分相加就应该是 <span class="math inline">\((-1)\times(-1)\)</span>，再加上 <span class="math inline">\(H(\varnothing)\)</span> 就为 <span class="math inline">\(2^n\)</span>。</p><p>那么我们可以很轻易的得到，在 <span class="math inline">\(S\not=\varnothing\)</span> 时， <span class="math inline">\(FWTF(S)=\frac{2^n}{\sum_{|T|=1}(-1)^{|S\text{ and T|}}p-1}\)</span>，而当 <span class="math inline">\(S=\varnothing\)</span> 的时候，<span class="math inline">\(FWTF(S)\)</span> 用除法求就 <span class="math inline">\(\text{nan}\)</span> 了，所以需要特别处理。</p><p>考虑在 <span class="math inline">\(\sum_SFWTF(S)\)</span> 中每个 <span class="math inline">\(F(S)\)</span> 的贡献，假设 <span class="math inline">\(|S|=X\)</span>，枚举 <span class="math inline">\(|S \text{ and } T|\)</span>，那么就有 <span class="math inline">\(\sum_k(-1)^kC_X^k2^{n-X}=2^{n-X}[X=0]\)</span>，其中 <span class="math inline">\(C_x^y\)</span> 表示组合数（后同）。所以 <span class="math inline">\(\sum_S FWTF(S)=2^nF(\varnothing)\)</span>，而上文有 <span class="math inline">\(F(\varnothing)=0\)</span>，所以 <span class="math inline">\(\sum_S FWTF(S)=0\)</span>。所以 <span class="math inline">\(FWTF(\varnothing)\)</span> 就是 <span class="math inline">\(-\sum_{S\not=\varnothing}FWTF(S)\)</span>。</p><p>根据上面推导，我们也可以知道 <span class="math inline">\(F(S)=\frac{1}{2^n}\sum_T(-1)^{|S\text{ and }T|}FWTF(T)\)</span>。（原理也是 <span class="math inline">\(\sum_k(-1)^kC_X^k=[X=0]\)</span>）。</p><p>把 <span class="math inline">\(\varnothing\)</span> 单独考虑，那么就有 <span class="math inline">\(F(S)=\sum_{T\not=\varnothing}(\frac{1}{1-\sum_{|U|=1}(-1)^{|U\text{ and }T|}p}-(-1)^{|S\text{ and }T|}\frac{1}{1-\sum_{|U|=1}(-1)^{|U\text{ and }T|}p})\)</span>。</p><p>把左右相抵的去掉，稍加整理，有 <span class="math inline">\(F(S)=\sum_{(-1)^{T\text{ and } S}=-1}\frac{2}{2\sum_{|U|=1}p[|U\text{ and }T|=1]}\)</span>。</p><p>最后就是一个简单 DP 了<del>（不会吧不会吧，推到这里还不会 DP？）</del>。</p><p>设 <span class="math inline">\(dp_{i,j,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 个开关，分子总和为 <span class="math inline">\(j\)</span>，交的奇偶性为 <span class="math inline">\(0/1\)</span> 的方案数。转移显然，总复杂度 <span class="math inline">\(O(n\sum p)\)</span>。</p><p>贴个代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> p[MAXN], s[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">50005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y - mod; x += (x &gt;&gt; <span class="number">31</span>) &amp; mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % mod)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = <span class="number">1l</span>l * re * a % mod;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p[i], sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (RI j = p[i]; j &lt;= sum[i]; ++j) &#123;</span><br><span class="line">      Add(f[i][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j - p[i]][<span class="number">0</span> ^ s[i]]);</span><br><span class="line">      Add(f[i][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - p[i]][<span class="number">1</span> ^ s[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt;= sum[i]; ++j) &#123;</span><br><span class="line">      Add(f[i][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">      Add(f[i][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt;= sum[n]; ++i)</span><br><span class="line">    Add(ans, <span class="number">1l</span>l * sum[n] * f[n][i][<span class="number">1</span>] % mod * qpow(i, mod - <span class="number">2</span>) % mod);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;把初始状态和目标状态交换，题目不变。&lt;/p&gt;
&lt;p&gt;为了方便，设 &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 被选的概率，对应到输入即 &lt;span class=&quot;math inline&quot;&gt;\(\frac{p_i}{\sum_{j=1}^n p_j}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(f(S)\)&lt;/span&gt; 表示从 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 状态开始，期望走 &lt;span class=&quot;math inline&quot;&gt;\(f(S)\)&lt;/span&gt; 步到达全零状态。为了方便，我们定义 &lt;span class=&quot;math inline&quot;&gt;\(\varnothing\)&lt;/span&gt; 表示全零状态。&lt;/p&gt;
&lt;p&gt;那么显然有</summary>
    
    
    
    
    <category term="FWT" scheme="http://example.com/tags/FWT/"/>
    
    <category term="多项式" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="期望概率" scheme="http://example.com/tags/%E6%9C%9F%E6%9C%9B%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>FWT 小结</title>
    <link href="http://example.com/2021/01/19/FWT-%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2021/01/19/FWT-%E5%B0%8F%E7%BB%93/</id>
    <published>2021-01-19T00:58:42.000Z</published>
    <updated>2021-01-21T01:19:24.268Z</updated>
    
    <content type="html"><![CDATA[<p>FWT 是快速求形如 <span class="math inline">\(C(x)=\sum_{i?j=x}A(i)B(j)\)</span> 的算法，其中 <span class="math inline">\(?\)</span> 表示一种二进制的位运算。</p><a id="more"></a><h4 id="原理">原理</h4><p>其实 FWT 背板挺容易的，但是因为考试趋向越来越本质化，所以我们要逐渐开始了解一些原来背板算法的原理。</p><p>类似于 FFT，我们考虑从最本源的地方来了解 FWT——构造一种线性变换 <span class="math inline">\(A\rightarrow A&#39;\)</span>，使得 <span class="math inline">\(C&#39;(x)=A&#39;(x)B&#39;(x)\)</span>，这样去掉线性变换的复杂度，总复杂度是 <span class="math inline">\(O(len)\)</span> 的。需要注意的是，这里的 <span class="math inline">\(A,B,C\)</span> 需要做同一种线性变换。</p><p>因为我们所做的是线性变换（即只存在加减），那么在 <span class="math inline">\(A&#39;\)</span> 中，我们可以把 <span class="math inline">\(A\)</span> 中每个数对它的贡献用一个系数表示，即 <span class="math inline">\(A&#39;(x)=\sum_i f(x,i)A(i)\)</span>。</p><p>那么 <span class="math inline">\(C&#39;(x)=\sum_i f(x,i)C(i)=\sum_if(x,i)\sum_{j?k=i}A(j)B(k)\)</span>，<span class="math inline">\(A&#39;(x)B&#39;(x)=\sum_if(x,i)A(i)\sum_jf(x,j)B(j)\)</span>。整理得 <span class="math inline">\(\sum_i\sum_jf(x,i?j)A(i)B(j)=\sum_i\sum_jf(x,i)f(x,j)A(i)B(j)\)</span>。故有 <span class="math inline">\(f(x,i?j)=f(x,i)f(x,j)\)</span>。</p><p>也就是说我们需要构造 <span class="math inline">\(f(x,i)\)</span>，使得它满足上述需求。</p><p>对于或操作，有 <span class="math inline">\(f(x,i \text{ or }j)=f(x,i)f(x,j)\)</span>，不难发现 <span class="math inline">\(i\text{ or }j\in x\Leftrightarrow i\in x\land j\in x\)</span>，那么设 <span class="math inline">\(f(x,i)=[i\in x]\)</span> 即可。</p><p>对于与操作，有 <span class="math inline">\(f(x,i\text{ and }j)=f(x,i)f(x,j)\)</span>，和或相似的，<span class="math inline">\(x\in i\text{ and }j\Leftrightarrow x\in i\land x\in j\)</span>。<span class="math inline">\(f(x,i)=[x\in i]\)</span>。</p><p>对于异或操作，这可能就有些麻烦。我们需要挖掘一些异或的性质。对于两个数 <span class="math inline">\(x,y\)</span>，显然 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(1\)</span> 的个数加上 <span class="math inline">\(y\)</span> 的 <span class="math inline">\(1\)</span> 的个数的奇偶性和 <span class="math inline">\(x \text{ xor } y\)</span> 的相同。而与和异或有恒等式 <span class="math inline">\((x\text{ xor } y)\text{ and } z=(x\text{ and }z)\text{ xor }(y\text{ and }z)\)</span>（不难证明），所以 <span class="math inline">\(i\text{ and }x\)</span> 的 <span class="math inline">\(1\)</span> 的个数加上 <span class="math inline">\(j\text{ and }x\)</span> 的 <span class="math inline">\(1\)</span> 的个数的奇偶性和 <span class="math inline">\((i\text{ and }x)\text{ xor }(j\text{ and }x)=(i\text{ xor } j)\text{ and } x\)</span> 的相同，而奇偶性的区分加减我们一般用 <span class="math inline">\((-1)^k\)</span> ，所以设 <span class="math inline">\(f(x,i)=(-1)^{|x \text { and }i|}\)</span> 即可。</p><h4 id="实现">实现</h4><p>下面只讨论 FWT，对于 IFWT，其就是 FWT 的逆向过程。</p><p>考虑按位计算贡献。</p><p>设 <span class="math inline">\(f_k(S)\)</span> 表示对于 <span class="math inline">\(S\)</span>，已经计算了前 <span class="math inline">\(k\)</span> 位任意，后面位数严格和 <span class="math inline">\(S\)</span> 相等且暂未考虑其对贡献的影响的贡献。考虑从 <span class="math inline">\(f_k(S)\)</span> 推到 <span class="math inline">\(f_{k+1}(S)\)</span>。</p><p>考虑每个数对 <span class="math inline">\(u,v\)</span> 互相的贡献，其中 <span class="math inline">\(u,v\)</span> 仅在第 <span class="math inline">\(k+1\)</span> 位不同，为了方便，设 <span class="math inline">\(u&lt;v\)</span>。</p><p>对于或，<span class="math inline">\(f_k(u)\)</span> 中存的是后面位数和 <span class="math inline">\(u\)</span> 相等，<span class="math inline">\(1\sim k\)</span> 位是 <span class="math inline">\(u\)</span> 子集的数的贡献，<span class="math inline">\(f_k(v)\)</span> 同理，那么显然考虑了第 <span class="math inline">\(k+1\)</span> 位后，<span class="math inline">\(f_{k+1}(u)=f_k(u)\)</span> ，<span class="math inline">\(f_{k+1}(v)=f_k(u)+f_k(v)\)</span>。</p><p>类似的，对于与，<span class="math inline">\(f_{k+1}(u)=f_k(u)+f_k(v)\)</span> ，<span class="math inline">\(f_{k+1}(v)=f_k(v)\)</span>。</p><p>对于异或，<span class="math inline">\(u\)</span> 在 <span class="math inline">\(k+1\)</span> 位对数的符号没有影响，而 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(k+1\)</span> 位对 <span class="math inline">\(k+1\)</span> 位为 <span class="math inline">\(1\)</span> 的数的符号有一个 <span class="math inline">\(-1\)</span> 的影响（因为之前没有考虑这一位对答案贡献的影响），所以 <span class="math inline">\(f_{k+1}(u)=f_k(u)+f_k(v)\)</span>，<span class="math inline">\(f_{k+1}(v)=f_k(u)-f_k(v)\)</span>。</p><p>这样就能在 <span class="math inline">\(O(len\log len)\)</span> 的时间内对于 <span class="math inline">\(A\)</span> 求得 <span class="math inline">\(A&#39;\)</span>。而逆变化就是正变化的相反操作，在此就不再赘述。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;FWT 是快速求形如 &lt;span class=&quot;math inline&quot;&gt;\(C(x)=\sum_{i?j=x}A(i)B(j)\)&lt;/span&gt; 的算法，其中 &lt;span class=&quot;math inline&quot;&gt;\(?\)&lt;/span&gt; 表示一种二进制的位运算。&lt;/p&gt;</summary>
    
    
    
    
    <category term="FWT" scheme="http://example.com/tags/FWT/"/>
    
    <category term="多项式" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络流进阶</title>
    <link href="http://example.com/2021/01/09/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2021/01/09/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BF%9B%E9%98%B6/</id>
    <published>2021-01-09T07:39:41.000Z</published>
    <updated>2021-01-12T03:53:07.974Z</updated>
    
    <content type="html"><![CDATA[<p>网络流进阶。主要是有上下界的各种网络流或费用流以及几个消负环的方法。</p><p>在看这个 Blog 之前你最好已经熟练掌握了 Dinic 网络流和 EK 费用流。</p><a id="more"></a><h4 id="无源汇有上下界的循环流">1. 无源汇有上下界的循环流</h4><p>这是最简单的一种有上下界的网络流，也是所有有上下界的网络流的基础。</p><p>其所求大意如下：对于一张网络流的图，每条边有一个流量限制 <span class="math inline">\([l,r]\)</span>，现在需要给每条边分配一个流量，使得每个点的流量平衡（即流入等于流出），且每条边的流量满足限制。</p><p>考虑先把每条边的流量设为其下界，设置完之后我们得到了一个初始流，这个流的流量都满足边的限制，但是不一定满足流量平衡。</p><p>考虑构造一个附加流，使得初始流加上附加流在满足边的限制的情况下满足流量平衡。</p><p>因为这个附加流仍需要满足边的限制，所以原来的一条边 <span class="math inline">\((u,v,l,r)\)</span>，可以看成是一条 <span class="math inline">\(u\)</span> 连向 <span class="math inline">\(v\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的边，这样在附加流中这条边的流量就只能是 <span class="math inline">\([0,r-l]\)</span>，一定会满足边的限制。</p><p>然后就只需要考虑流量平衡。对于一个点 <span class="math inline">\(x\)</span>，如果其流入大于流出，那么它就仍然需要流出一些流量。考虑新增一个虚拟起点 <span class="math inline">\(S&#39;\)</span>，连一条 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(x\)</span> 流量为流入和流出的差值的边。这条边每有 <span class="math inline">\(1\)</span> 个流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流出增加了 <span class="math inline">\(1\)</span>。类似的，如果点 <span class="math inline">\(x\)</span> 的流出大于流入，那么它就仍然需要流入一些流量，就新增一个虚拟终点 <span class="math inline">\(T&#39;\)</span>，连条 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(T&#39;\)</span> 流量为流出和流入的差值的边。这条边每有 <span class="math inline">\(1\)</span> 流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流入增加了 <span class="math inline">\(1\)</span>。</p><p>最后对新图 <span class="math inline">\(S&#39;-T&#39;\)</span> 跑一遍最大流，由前文的构造附加流的过程可知，可以使得其流量平衡当且仅当该图的最大流使得所有 <span class="math inline">\(S&#39;\)</span> 连出的边都满流（<span class="math inline">\(S&#39;\)</span> 连出的边都满流等价于 <span class="math inline">\(T&#39;\)</span> 连入的边都满流），否则的话无解。</p><p>最后每条边的流量就是下界加上附加流中该边的流量。</p><h4 id="有源汇有上下界的可行流">2. 有源汇有上下界的可行流</h4><p>有源汇和无源汇的最大的区别就是源点 <span class="math inline">\(S\)</span> 和汇点 <span class="math inline">\(T\)</span> 的流量不平衡。</p><p>考虑连一条 <span class="math inline">\(T\)</span> 连向 <span class="math inline">\(S\)</span> 流量下界为 <span class="math inline">\(0\)</span> 上界为 <span class="math inline">\(+\infty\)</span> 的边，这样 <span class="math inline">\(S\)</span> 的流出和 <span class="math inline">\(T\)</span> 的流入就都可以靠这条边来弥补，使得其流量平衡。</p><p>这时候就只需要求循环流了，即 1.。</p><p>不难发现，<span class="math inline">\(T\rightarrow S\)</span> 的流只可能走我们新加的边，所以附加流的总流量就是新加边的流量。但是这并不意味着新加边的流量等于 <span class="math inline">\(S&#39;\rightarrow T&#39;\)</span> 的最大流，因为原图中可能有环。</p><p>而可行流的流量就是 <span class="math inline">\(S\)</span> 的流出量（也就是 <span class="math inline">\(T\)</span> 的流入量），也等于新加边的流量。故可行流的流量等于附加流的流量。</p><h4 id="有源汇有上下界的最大流">3. 有源汇有上下界的最大流</h4><p>和 2. 类似的，我们可以先求出一个可行流。</p><p>此时对原图的残量网络再跑一次 <span class="math inline">\(S-T\)</span> 的最大流即可。</p><p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(S-T\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(S&#39;-T&#39;\)</span>。</p><p>如果你在跑 <span class="math inline">\(S-T\)</span> 最大流的时候，去掉了前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边，那么最大流就是残量网络上求出的最大流加上附加流的流量。否则，根据网络流的性质，此时可以通过所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边的反向边，直接从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 流附加流的流量，所以最大流就是残量网络上求出的最大流流量 。</p><h4 id="有源汇有上下界的最小流">4. 有源汇有上下界的最小流</h4><p>和 2. 类似的，我们可以先求出一个可行流。</p><p>然后考虑从 <span class="math inline">\(T\)</span> 向 <span class="math inline">\(S\)</span> 退流，这样就可以使得流量尽可能小。</p><p>即在残量网络上跑一遍 <span class="math inline">\(T-S\)</span> 的最大流。用附加流流量减去这个最大流的流量即最小流。</p><p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(T-S\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(T&#39;-S&#39;\)</span>。</p><p>此时前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边必须要去掉，不然会通过这条边退 <span class="math inline">\(+\infty\)</span> 的流导致求不到答案。</p><h4 id="有源汇有上下界的最小费用可行流最大流最小流">5. 有源汇有上下界的最小费用可行流/最大流/最小流</h4><p>为了方便，暂时不考虑负环，后面会提到两个消负环的算法。</p><p>最大费用和最小费用等价，所以暂且不考虑最大费用。</p><p>其实本质上就是在 2.3.4. 的基础上，加上一个最小费用。</p><p>即在一开始每条边强行流 <span class="math inline">\(l\)</span> 的流量的时候，把总费用加上 <span class="math inline">\(l\times cost\)</span>。</p><p>所有辅助边的费用都设为 <span class="math inline">\(0\)</span>。</p><p>在求附加流的时候是跑的最小费用最大流。最大流不满流仍然无解。</p><p>最后在残量网络上面跑的时候，如果是 <span class="math inline">\(S-T\)</span>，跑的是最小费用最大流，如果是 <span class="math inline">\(T-S\)</span>，跑的是最大费用最大流（正着流费用最小就是退的流费用最大）。</p><h4 id="有上下界的另一种连边方法">6. 有上下界的另一种连边方法</h4><p>为了省事，可以把边 <span class="math inline">\((u,v,l,r,c)\)</span> 拆成三条边。一条 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(r-l\)</span> 费用为 <span class="math inline">\(c\)</span>，一条虚拟起点 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>，一条 <span class="math inline">\(u\)</span> 到虚拟终点 <span class="math inline">\(T&#39;\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>。并把总费用加上 <span class="math inline">\(l\times c\)</span>。</p><p>不难发现这种连边方法和 1. 的连边方法本质相同。只是把之前所考虑的一个点总流入和总流出的差分解成了若干个部分，或者说可以看成是之前直接把所有形如 <span class="math inline">\(S&#39;\rightarrow x \rightarrow T&#39;\)</span> 的流全部流完了。</p><h4 id="消负环算法">7. 消负环算法</h4><p>对于一条负权边 <span class="math inline">\((u,v,l,r,c)\)</span>，我们可以先强行把这条负权边流满，并获得 <span class="math inline">\(r\times c\)</span> 的总费用，然后这条边就变成了从 <span class="math inline">\(v\)</span> 连向 <span class="math inline">\(u\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的费用为 <span class="math inline">\(-c\)</span> 的边。这样强制流之后显然不一定满足流量平衡，所以需要用上述的附加流的方法使其流量平衡。</p><p>因为在整个图中一开始没有出现负环，所以在整个过程中也不会产生负环（可能比较糊……暂时还没有证明，或许显然？）。</p><p>另外还有一种很神的消负环算法，可见<a href="https://www.cnblogs.com/lsq147/p/14232399.html">这位神仙的博客</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络流进阶。主要是有上下界的各种网络流或费用流以及几个消负环的方法。&lt;/p&gt;
&lt;p&gt;在看这个 Blog 之前你最好已经熟练掌握了 Dinic 网络流和 EK 费用流。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>字符串的回文划分</title>
    <link href="http://example.com/2021/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/"/>
    <id>http://example.com/2021/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/</id>
    <published>2021-01-07T07:44:43.000Z</published>
    <updated>2021-01-11T11:54:34.428Z</updated>
    
    <content type="html"><![CDATA[<p>定义一个串 <span class="math inline">\(S\)</span> 的划分 <span class="math inline">\(s_1,s_2...s_k\)</span> 为回文划分当且仅当 <span class="math inline">\(s_1,s_2...s_k\)</span> 都是回文串。</p><p>现在考虑求一个串 <span class="math inline">\(S\)</span> 的回文划分数。<span class="math inline">\(1\leq |S| \leq 10^6\)</span>。</p><a id="more"></a><hr /><p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始，且 <span class="math inline">\(S[l:r]\)</span> 为字符串 <span class="math inline">\(S\)</span> 中 <span class="math inline">\(s[l],s[l+1]...s[r]\)</span> 这个子串。</p><p>考虑设 <span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(i\)</span> 结尾的这个前缀的回文划分方案数。</p><p>转移显然，即 <span class="math inline">\(f[i]=\sum f[i-L]~(S[i-L+1:i] \text{是回文串})\)</span>。</p><p>如果枚举 <span class="math inline">\(i,L\)</span> 再暴力判断，复杂度会达到严格 <span class="math inline">\(O(|S|^3)\)</span>，如果用一些方法预处理快速判断一个串是不是回文串，可以做到严格 <span class="math inline">\(O(|S|^2)\)</span>。</p><p>考虑优化，对于快速找到回文 Border，可以使用回文自动机，这样每次在当前节点跳 <span class="math inline">\(parent\)</span> 边跳到的都是回文后缀，这样就可以直接转移。复杂度是 <span class="math inline">\(O(\sum_i \text{以 i 结尾的回文后缀个数})\)</span>，在随机数据下跑得很快。但是这样显然可以被 <span class="math inline">\(aa...aa\)</span> 卡到 <span class="math inline">\(O(|S|^2)\)</span>。故考虑进一步优化。</p><blockquote><p>引理 <span class="math inline">\(1\)</span> : 对于一个串 <span class="math inline">\(S\)</span> 的所有长度大于 <span class="math inline">\(\frac{|S|}{2}\)</span> 的回文 Border，它们的长度形成一个等差数列。</p></blockquote><p>证明：拿出最长的回文 Border <span class="math inline">\(T\)</span>，那么 <span class="math inline">\(S\)</span> 就存在周期 <span class="math inline">\(|S|-|T|\)</span>，所以长度为 <span class="math inline">\(|S|-2(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border，长度为 <span class="math inline">\(|S|-3(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border……把这一组 Border 去掉之后，剩下的回文 Border 长度一定小于等于 <span class="math inline">\(\frac{|S|}{2}\)</span>，不然的话 <span class="math inline">\(T\)</span> 就不会是最长的回文 Border。</p><p>这样在 DP 中可以转移的点也可以被分成 <span class="math inline">\(\log_2|S|\)</span> 个等差数列。我们就可以这么做：预处理 <span class="math inline">\(F[i][j]\)</span> 表示 <span class="math inline">\(f[i]+f[i-j]+...\)</span>，那么对于一个等差数列，如果其公差小于一个阈值，就直接查表，否则暴力跳。这样复杂度上限可以被优化到 <span class="math inline">\(O(|S|\sqrt{|S|\log_2|S|})\)</span>，实际效率未知。</p><p>我们把某个等差数列拿出来，看看它有什么性质。</p><p><img src="https://s3.ax1x.com/2021/01/07/smA5qg.png" /></p><p>这是 <span class="math inline">\(4\)</span> 个形成等差数列的 Border。</p><p>我们把每个 Border 按照比恰好比它长的 Border 的回文中心对称过去，可以发现它的开头是恰好比它长的 Border 的开头，结尾都在同一个位置。</p><p>如果设 <span class="math inline">\(g[x]\)</span> 为在回文自动机上以 <span class="math inline">\(x\)</span> 为末项的回文 Border 的 <span class="math inline">\(\sum f\)</span>，把上图的串从上到下依次编号成 <span class="math inline">\(1,2,3,4\)</span>，那么我们可以发现，对于现在要求的 <span class="math inline">\(g[4]\)</span>，有很大一部分已经被 <span class="math inline">\(g[3]\)</span> 算过了（<span class="math inline">\(g[3]\)</span> 即红色条纹部分，<span class="math inline">\(g[4]\)</span> 即黑色条纹部分），因为我们到现在这个位置计算 <span class="math inline">\(g[4]\)</span> 时，一定会先走过计算 <span class="math inline">\(g[3]\)</span> 的位置。所以就只需要使 <span class="math inline">\(g[4]=g[3]\)</span> 且把 <span class="math inline">\(g[4]\)</span> 额外加上【除掉当前等差数列最小的 Border 的那个 <span class="math inline">\(f\)</span> 】即可。</p><p>这样就可以在 <span class="math inline">\(O(n\log_2 n)\)</span> 的时间内解决该题。</p><!-- more --><p>直接讨论回文划分太抽象了，举个具体例子。</p><h5 id="cf932g-palindrome-partition">CF932G Palindrome Partition</h5><p>给定一个串 <span class="math inline">\(S\)</span>，把串分为偶数段。</p><p>假设分为了 <span class="math inline">\(s_1,s_2,s_3....s_k\)</span>。</p><p>求，满足 <span class="math inline">\(s_1=s_k,s_2=s_{k−1}.....\)</span> 的方案数。</p><p><span class="math inline">\(2\leq |S| \leq 10^6\)</span>，方案数对 <span class="math inline">\(10^9+7\)</span> 取模。</p><hr /><h5 id="solution">Solution:</h5><p>乍一看这个题和回文划分没有什么关系，但是我们不妨分析一手。</p><p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始。</p><p>考虑逐个考虑 <span class="math inline">\(s_1\)</span> 和 <span class="math inline">\(s_k\)</span>，<span class="math inline">\(s_2\)</span> 和 <span class="math inline">\(s_{k-1}\)</span> 这样的匹配对。我们发现当剩余串的长度固定的时候，留下的是中间某一个固定的段，这样就不是很好，因为我们很难得到中间某个串的信息。所以尝试把这个串修改一下使得每次分段都是一个连续的区间，即改成 <span class="math inline">\(s[1]s[n]s[2][n-1]...\)</span>，这样我们就可以发现，对于一个分段，它都是一个长度为偶数的连续区间，且该串为回文串。</p><p>这样问题就转化成了：把一个串 <span class="math inline">\(S\)</span> 分解成若干个长度为偶数的回文串的方案数。直接用上面的算法做即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN], t[MAXN];</span><br><span class="line"><span class="keyword">int</span> child[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], parent[MAXN &lt;&lt; <span class="number">1</span>], mxlen[MAXN &lt;&lt; <span class="number">1</span>], cnt = <span class="number">2</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN &lt;&lt; <span class="number">1</span>], bot[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFail</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (now &amp;&amp; s[pos] != s[pos - mxlen[now] - <span class="number">1</span>])</span><br><span class="line">    now = parent[now];</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = (i &amp; <span class="number">1</span>) ? t[i / <span class="number">2</span> + <span class="number">1</span>] : t[n - i / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">//  cerr &lt;&lt; (s + 1) &lt;&lt; endl;</span></span><br><span class="line">  parent[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  mxlen[<span class="number">1</span>] = <span class="number">0</span>, mxlen[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    child[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ch = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    last = GetFail(last, i);</span><br><span class="line">    <span class="keyword">if</span> (child[last][ch])</span><br><span class="line">      last = child[last][ch];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ++cnt;</span><br><span class="line">      child[last][ch] = cnt;</span><br><span class="line">      mxlen[cnt] = mxlen[last] + <span class="number">2</span>;</span><br><span class="line">      parent[cnt] = child[GetFail(parent[last], i)][ch];</span><br><span class="line">      last = cnt;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[parent[cnt]] * <span class="number">2</span> &gt; mxlen[cnt] &amp;&amp; (!d[parent[cnt]] || mxlen[cnt] - mxlen[parent[cnt]] == d[parent[cnt]])) &#123;</span><br><span class="line">        d[cnt] = mxlen[cnt] - mxlen[parent[cnt]], bot[cnt] = bot[parent[cnt]];</span><br><span class="line">        d[parent[cnt]] = mxlen[cnt] - mxlen[parent[cnt]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        d[cnt] = <span class="number">0</span>, bot[cnt] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI cur = last; cur; cur = parent[bot[cur]]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bot[cur] != cur)</span><br><span class="line">        g[cur] = g[parent[cur]];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g[cur] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[bot[cur]])</span><br><span class="line">        g[cur] = (g[cur] + f[i - mxlen[bot[cur]]]) % mod;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        f[i] = (f[i] + g[cur]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;定义一个串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的划分 &lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2...s_k\)&lt;/span&gt; 为回文划分当且仅当 &lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2...s_k\)&lt;/span&gt; 都是回文串。&lt;/p&gt;
&lt;p&gt;现在考虑求一个串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的回文划分数。&lt;span class=&quot;math inline&quot;&gt;\(1\leq |S| \leq 10^6\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="PAM" scheme="http://example.com/tags/PAM/"/>
    
  </entry>
  
  <entry>
    <title>Hall 定理学习笔记</title>
    <link href="http://example.com/2021/01/04/Hall-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/01/04/Hall-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-04T13:08:22.000Z</published>
    <updated>2021-01-05T09:01:12.694Z</updated>
    
    <content type="html"><![CDATA[<p>在网上学习了 Hall 定理后决定写这么个东西。</p><p>如有雷同或涉及侵权，请联系博主。</p><a id="more"></a><h3 id="定理内容">定理内容</h3><p>对于一个二分图，假设其左边节点个数小于等于右边节点个数，并设左边节点个数为 <span class="math inline">\(X\)</span>，右边为 <span class="math inline">\(Y\)</span>。</p><p>若从左边选出任意 <span class="math inline">\(k\)</span> 个节点，右边都有至少 <span class="math inline">\(k\)</span> 个节点与之相连，那么该二分图的最大匹配个数恰好为 <span class="math inline">\(X\)</span>。我们称满足这个条件的匹配为完美匹配。</p><p>为了方便，在下文中默认左边的节点数小于等于右边的节点数。</p><h3 id="证明">证明</h3><p>考虑从必要和充分两方面证明这个定理。</p><h4 id="必要性">1. 必要性</h4><p>如果一个二分图有完美匹配，且其不满足 Hall 定理。</p><p>那么对于左边某 <span class="math inline">\(k\)</span> 个节点，右边与之相连的点数小于 <span class="math inline">\(k\)</span>。</p><p>而根据假设，左边这 <span class="math inline">\(k\)</span> 个节点都匹配了右边 <span class="math inline">\(k\)</span> 个不同的节点，那么右边与之相连的点数至少为 <span class="math inline">\(k\)</span>。</p><p>前后两者是矛盾的，所以该假设不成立，故必要性得证。</p><h4 id="充分性">2. 充分性</h4><p>如果一个二分图满足 Hall 定理，且其没有完美匹配。</p><p>考虑分两个部分来证明它。</p><h5 id="part1.-若左边每个点的度数都大于等于-2">Part1. 若左边每个点的度数都大于等于 <span class="math inline">\(2\)</span>。</h5><p>我们在左边可以找到一个没有匹配的点 <span class="math inline">\(l_1\)</span>。它一定会连接到一个右边的节点 <span class="math inline">\(r_1\)</span>。</p><p>如果 <span class="math inline">\(r_1\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p><p>否则 <span class="math inline">\(r_1\)</span> 会匹配到一个左边的节点 <span class="math inline">\(l_2\)</span>。那么 <span class="math inline">\(l_2\)</span> 一定会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p><p>如果 <span class="math inline">\(r_2\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p><p>否则……</p><p>这样会一直循环下去，而点数有限，那么必然终止，所以整体与假设矛盾。</p><h5 id="part2.-若左边有点的度数等于-1">Part2. 若左边有点的度数等于 <span class="math inline">\(1\)</span></h5><p>有点的度数为 <span class="math inline">\(1\)</span> 就可能出现一个问题，就是上述证明的 <span class="math inline">\(l_2\)</span> 若度数为 <span class="math inline">\(1\)</span>，则不会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p><p>但其实这样也是可以证明的。假设 <span class="math inline">\(l_1\)</span> 的度数为 <span class="math inline">\(1\)</span>，那么若 <span class="math inline">\(l_2\)</span> 的度数也为 <span class="math inline">\(1\)</span>，就会因为它们连接着同一个点 <span class="math inline">\(r_1\)</span> 而不满足 Hall 定理矛盾（如果左边选择这两个点，右边只有一个点与之相连）</p><p>假设 <span class="math inline">\(l_1\)</span> 的度数大于等于 <span class="math inline">\(2\)</span>，而 <span class="math inline">\(l_2\)</span> 的度数为 <span class="math inline">\(1\)</span>。那么我们可以把这条增广路反向，这样 <span class="math inline">\(l_2\)</span> 就变成了 <span class="math inline">\(l_1\)</span>，再用上面的证明即可。</p><hr /><h3 id="引申">引申</h3><p>定义二分图的 K-完美匹配 为二分图有 <span class="math inline">\(K\)</span> 个完全不相交的完美匹配。</p><p>现在考虑该图要满足什么条件才有 K-完美匹配。</p><p>这个题是一个经典问题，有一个很经典的网络流做法，博主根据这个做法以及一些分析归纳出了下列定理：（可能是个经典定理，但是博主找不到）</p><p>对于一个二分图，如果可以通过删边的操作，使得左边的每个点的度数都为 <span class="math inline">\(K\)</span>，且右边的每个点的度数都小于等于 <span class="math inline">\(K\)</span>，那么一定存在 K-完美匹配。</p><h3 id="证明-1">证明</h3><p>还是从必要和充分两方面证明这个引理。</p><h4 id="充分性-1">1. 充分性</h4><p>考虑用归纳法证明。</p><h5 id="先证明-k1-成立">1. 先证明 <span class="math inline">\(K=1\)</span> 成立。</h5><p>从左边任选一个点，然后找到它相连的点，匹配。</p><p>根据前提条件，这条边是这两个点连出的唯一一条边。</p><p>这样这个问题就变成了一个条件不变规模更小的问题。</p><p>一直这么下去就可以得到一个完美匹配。</p><h5 id="假设证明了-kleq-x-1-成立再证明-kx-成立">2. 假设证明了 <span class="math inline">\(K\leq x-1\)</span> 成立，再证明 <span class="math inline">\(K=x\)</span> 成立。</h5><p>首先这个图满足 Hall 定理。因为对于左边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而右边的点的度数的上限是 <span class="math inline">\(x\)</span>，那么右边至少会有 <span class="math inline">\(k\)</span> 个点与其相连。</p><p>把左边所有点和右边所有的度数恰好为 <span class="math inline">\(x\)</span> 的点及它们之间的边拿出来构成一个新图，此时的这张图是<strong>右边的点数小于等于左边的点数的</strong>，那么对于右边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而左边的点的度数上限是 <span class="math inline">\(x\)</span>，那么至少左边会有 <span class="math inline">\(k\)</span> 个点与其相连。</p><p>这样的话对于这个新图，就存在一个完美匹配。构造出这个完美匹配后，回到原图，保留新图的匹配，再用匈牙利算法形成一个原图的完美匹配。然后把这个完美匹配删掉，剩下的图恰好满足 <span class="math inline">\(K=x-1\)</span> 的性质，而通过归纳，<span class="math inline">\(K=x-1\)</span> 已经被证明，故充分性得证。</p><h4 id="必要性-1">2. 必要性</h4><p>若左边存在一个点的度数小于 <span class="math inline">\(K\)</span>，那么显然不存在一个 K-完美匹配。不然一定存在一种删边方式使得左边的度数等于 <span class="math inline">\(K\)</span>。</p><p>如果删边之后左边存在一个点的度数大于 <span class="math inline">\(K\)</span>，那么 K-完美匹配 后一定会剩下一些边，那么把这些便删掉也不影响判断。</p><p>那么现在可能使得该定理必要性不存在的就只有：左边的所有点的度数为 <span class="math inline">\(K\)</span>，且右边存在一个点的度数大于 <span class="math inline">\(K\)</span>，且该二分图存在 K-完美匹配。</p><p>但是你会发现上述情况是不可能存在的，因为在删除 K-完美匹配 的边后，左边的点的度数就都变成了 <span class="math inline">\(0\)</span>，而右边此时会存在至少一个点的度数大于 <span class="math inline">\(0\)</span>（因为每一个匹配最多让一个点的度数减一），这是矛盾的。</p><p>故必要性得证。</p><p>这就能解释对于二分图的 K-完美匹配 的判定，为何可以用【 <span class="math inline">\(S\)</span> 向左边的点连流量为 <span class="math inline">\(K\)</span> 的边，在每个二分图上的边中左边的点向右边的点连流量为 <span class="math inline">\(1\)</span> 的边，右边的点向 <span class="math inline">\(T\)</span> 连流量为 <span class="math inline">\(K\)</span> 的边，看网络流的结果中左边的点是否都满流】来判断了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网上学习了 Hall 定理后决定写这么个东西。&lt;/p&gt;
&lt;p&gt;如有雷同或涉及侵权，请联系博主。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="二分图" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[HNOI2019]JOJO 题解</title>
    <link href="http://example.com/2020/12/29/HNOI2019-JOJO-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2020/12/29/HNOI2019-JOJO-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-12-29T07:40:47.000Z</published>
    <updated>2021-01-02T00:26:27.773Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目的 <span class="math inline">\(2\)</span> 操作代表着需要维护一个可持久化的东西。</p><p>但是因为它没有强制在线，根据常识，可以离线生成一个操作树来降低思考难度。</p><p>不难发现最终的字符串的长度可能会非常长，可以达到 <span class="math inline">\(n\cdot x=10^9\)</span> 级别，这提示我们不能从字符串本身入手。</p><a id="more"></a><p>考虑一个后缀是 Border 需要满足什么条件，假设现在有字符串 <span class="math inline">\(aa|c|bb|aaa|c|b\)</span>，其中的一个 Border 就是 <span class="math inline">\(aacb\)</span>。我们把它的对应段拿出来，即 <span class="math inline">\((a,2)(c,1)(b,2)\)</span> 和 <span class="math inline">\((a,3)(c,1)(b,1)\)</span>，可以发现的是，它的第一段的长度必须大于等于整个字符串的第一段的长度，它的最后一段的长度必须要小于等于对应段的长度，而中间部分必须完全相同。</p><p>所以我们可以考虑把每个操作看成是 <span class="math inline">\((c_i,x_i)\)</span> ，并且用 KMP 维护这个过程。</p><p>首先考虑怎么维护 <span class="math inline">\(fail\)</span> 数组。需要特别注意的是，因为我们现在使用增量法求答案（树结构的性质使然），所以这里的 <span class="math inline">\(fail\)</span> 定义为一个最长的后缀，使得该后缀的第一段的长度大于等于整个字符串的第一段的长度，且剩下部分和整个字符串后面部分<strong>完全相同</strong>。这和一般的 <span class="math inline">\(fail\)</span> 略微有点区别。</p><p>我们现在的操作是一个<strong>树结构</strong>，而 KMP <strong>暴力</strong>找 <span class="math inline">\(fail\)</span> 的复杂度是<strong>均摊</strong>的，所以我们在加入一个段的时候并不能直接暴力跳 <span class="math inline">\(fail\)</span> 指针。考虑设 <span class="math inline">\(nxt_{now,c,x}\)</span> 表示在节点 <span class="math inline">\(now\)</span>，加上 <span class="math inline">\(x\)</span> 的字符 <span class="math inline">\(c\)</span> 会跳到哪里，可以用主席树维护这个东西，即把 <span class="math inline">\(nxt_{now,c}\)</span> 看成是一个线段树，每次扫到一个儿子时把 <span class="math inline">\(nxt_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(nxt_{now,C}\)</span> 中的 <span class="math inline">\(X\)</span> 赋值成这个儿子即可。</p><p>需要特别注意的是，我们前面有【Border 的第一段的长度必须大于等于整个串的第一段的长度】，也就是说对于一个串，如果它的 <span class="math inline">\(fail\)</span> 需要考虑整个串的第一段的时候稍微有点特殊，直接把整个串的第一段看成是 <span class="math inline">\((c,x\sim 10000)\)</span> 的段即可。</p><p>这样我们就动态维护出了 <span class="math inline">\(fail\)</span> 数组，考虑通过这个来维护答案。</p><p>假设现在加入的段是 <span class="math inline">\((c,x)\)</span>。</p><p>把它的 <span class="math inline">\(fail\)</span> 树上到根的链拿出来，假设是一个这样的结构。其中 <span class="math inline">\((c,x_i)\)</span> 表示这个点下面有一个 <span class="math inline">\((c,x_i)\)</span> 的操作。<span class="math inline">\(length\)</span> 表示整个字符串到它这里的长度。</p><p><img src="https://s3.ax1x.com/2020/12/29/rbk5Mq.png" /></p><p>可以发现对于长度为 <span class="math inline">\([1,x1]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的 <span class="math inline">\(nxt\)</span> 长度是 <span class="math inline">\(length_{fail1}+i\)</span>。对于 <span class="math inline">\([x1+1,x2]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的<span class="math inline">\(nxt\)</span> 的长度是 <span class="math inline">\(length_{fail2}+i\)</span>，以此类推。我们把这个长度给拆开，那么一部分是 <span class="math inline">\(length\)</span> 的和，一部分是 <span class="math inline">\(i\)</span> 的和。对于后者，只要求出其 <span class="math inline">\(fail\)</span> 链上最长的一个 <span class="math inline">\(x\)</span>，总和就是 <span class="math inline">\(\frac{x(x+1)}{2}\)</span>。对于前者，可以发现如果一个地方有多个选择，一定选择 <span class="math inline">\(length\)</span> 最长的一个，而我们整个过程是在树上遍历，每次往下走 <span class="math inline">\(length\)</span> 是单调不减的，所以可以类似于维护 <span class="math inline">\(fail\)</span>，用 <span class="math inline">\(len_{now,c,x}\)</span> 表示这个点 <span class="math inline">\(now\)</span> 一直往上跳 <span class="math inline">\(fail\)</span> 树，往下加 <span class="math inline">\(x\)</span> 的最大 <span class="math inline">\(length\)</span>，用主席树维护 <span class="math inline">\(len_{now,c}\)</span>，每次扫的一个儿子时把 <span class="math inline">\(len_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(len_{now,c}\)</span> 中的 <span class="math inline">\(1\sim X\)</span> 赋值成 <span class="math inline">\(length_{now}\)</span>。</p><p>需要注意的是，如果这个加入的段可以匹配整个串的第一段，如 <span class="math inline">\(abaa\)</span>，最后的那个 <span class="math inline">\(a\)</span> 就需要特判。稍加讨论即可。</p><p>这样就可以直接做了。时空复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个题目的 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 操作代表着需要维护一个可持久化的东西。&lt;/p&gt;
&lt;p&gt;但是因为它没有强制在线，根据常识，可以离线生成一个操作树来降低思考难度。&lt;/p&gt;
&lt;p&gt;不难发现最终的字符串的长度可能会非常长，可以达到 &lt;span class=&quot;math inline&quot;&gt;\(n\cdot x=10^9\)&lt;/span&gt; 级别，这提示我们不能从字符串本身入手。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="可持久化数据结构" scheme="http://example.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>简单模拟费用流</title>
    <link href="http://example.com/2020/12/27/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://example.com/2020/12/27/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/</id>
    <published>2020-12-27T13:14:45.000Z</published>
    <updated>2020-12-27T14:06:00.060Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，只要把模建好，什么题都可以用网络流/费用流跑。</p><p>随着这些算法普及度的提高，出题人也就不再局限于单纯的网络流/费用流，而模拟费用流就是其中衍生出来的一个上限很高的算法。</p><p>由于博主水平有限，在此记录一些比较简单的模拟费用流问题和思路。</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，只要把模建好，什么题都可以用网络流/费用流跑。&lt;/p&gt;
&lt;p&gt;随着这些算法普及度的提高，出题人也就不再局限于单纯的网络流/费用流，而模拟费用流就是其中衍生出来的一个上限很高的算法。&lt;/p&gt;
&lt;p&gt;由于博主水平有限，在此记录一些比较简单的模拟费用流问题和思路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="费用流" scheme="http://example.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>NOIP 2020 游记</title>
    <link href="http://example.com/2020/12/02/NOIP-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2020/12/02/NOIP-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-12-02T06:27:43.000Z</published>
    <updated>2020-12-08T14:19:13.655Z</updated>
    
    <content type="html"><![CDATA[<h4 id="day--inf">Day -INF</h4><a id="more"></a><p>已经记不清什么时候的事情了。</p><p>组内进行了分小组出题互测。</p><p>Clamee 出了一道让队爷都拍手称赞的题，还给丢 T3 了。</p><p>自从那一天被 T3 搞自闭开始，T3 就再也没有切过了【悲伤】。</p><h4 id="day--5">Day -5</h4><p>我说 Codeforces 它不讲武德，当时它一个 Div1A，一个 Div1B，一个 Div1C，我全部都切掉了啊。</p><p>切掉之后自然是点到为止，Pretest passed 后就不管了，因为这时按照传统规矩它已经被切了。</p><p>它也承认我是先切了它，但它突然就是一个数据怼上来，我大意了啊，没有特判，直接就给 FST 了。</p><p>它偷袭一个 2000 多分的蒟蒻这好吗？这不好。OI 界要以和为贵，加强 pretest。</p><p>最后掉分了。（</p><h4 id="day--4">Day -4</h4><p>Kewth 给我们出模拟赛了！！！</p><p>开局四个 <span class="math inline">\(998244353\)</span> 当场自闭。</p><p>数学蒟蒻在线惊恐。</p><p>又被 T3 卡了，T4 比 T3 难多了还给切了，我真就 &amp;@#$&amp;%#&amp;。</p><p>又刷了好久知乎，感觉颓死了。</p><p>好羡慕那些 win 啊。</p><h4 id="day--3">Day -3</h4><p>CYJian 给我们出模拟赛了！！！</p><p>感觉一开始状态挺好的，前三题一下就做完了（虽然 T3 假了）。</p><p>结果 T4 不知道抽了什么筋，想到一个换根+树剖+带修主席树的做法，还开始写了。</p><p>写到后面越陷越深，最后 10k 都没写完惨变暴力分。</p><p>在 CYJian 这届，切了 T4 就有 0.667 的概率进国家集训队，而没有切进的概率为 0。</p><p><strong>在此提前恭喜 xiaolilsqs 进队！！！</strong></p><p>Clamee 又改了它出的神仙 T3，不过还好有前车之鉴没有被踩。</p><h4 id="day--2">Day -2</h4><p>Ysu 给组内开了个会。</p><p>自然是考前给大家加信心。（然而考前就要求写退役记）</p><p>他说他在高考之前和喜欢的妹子一起刷了一周题，然后就考上了北航。</p><p>要是我 NOIP 前可以和喜欢的妹子一起刷一周题，那 400 分不手到擒来？！（因为前提无法实现，所以后面的结果就写得奇怪一点）</p><p>又双叒叕开始颓了……还似乎被 Ysu 看到了。</p><p>神游了一段时间之后决定开始搞学。</p><p>写退役记的时候想到了很多往事，下午加晚上就这么过去了。</p><h4 id="day--1">Day -1</h4><p>NOIP 前的最后一次模拟赛。</p><p>tiger0132 会出题的消息不胫而走，在赛前引起了很多人的恐慌。</p><p>最终是 tiger 的两道题拼上另外两题，有一说一，tiger 的题目还是很良心的。毒瘤还是毒瘤在拼的题目上。</p><p>最后 3h AK 了。</p><p>Ysu 说要把这次当 NOIP，NOIP 当考后放松赛（要是 NOIP 能像今天一样就好了）。</p><p>又颓了好一会……后面觉得这样不太行就开始捣鼓 Linux。</p><h4 id="day-0">Day 0</h4><p>被叫出去<strong>爬</strong>（山）了。</p><p>回来之后搞了一次机房团建（雾。</p><p>晚上开了场 Div.2 VP，卡 E 了，感觉药丸。</p><h4 id="day1">Day1</h4><p>Ysu 喝奶茶导致喉咙发炎了（听说被珍珠呛到？？？），心疼 30s。</p><p>早上 5:30 惊醒，看了下表一时间不能确定是五点还是六点，调了一下表盘，看数字表盘发现才 5:30，就躺下打算继续睡。</p><p>结果每 7-8 min 就惊醒一次，浑浑噩噩熬到 6:10 就起床了。</p><p>随便买了些东西当早餐，顺便捎了个薄荷糖防睡觉。</p><p>7:30 到制定地点，7:40+ 就进考场了，下完题目和配置就开始发呆。</p><p>解压密码 <code>1Xuan2Shou0Jia5You</code>，太谢谢 CCF 的祝福了（雾。</p><p>T1 送分，T2 字符串……？想了会发现不是太难。T3 构造，T4 计数。</p><p>似乎又没有数据结构和树据结构……又组些什么阴间题啊……</p><p>1h rush 完 T1,T2，发现 T2 <span class="math inline">\(O(T(27n+n\log n))\)</span> 有亿点点卡常，花了 30min 优化常数后发现还是有点点慢，但是感觉卡下去没有什么意义，就放弃了。</p><p>回头看了一下 T1，突然一下没看到 <span class="math inline">\(d\leq 5\)</span>，然后就 NT 地构造了一种 <span class="math inline">\(10000^{10}\)</span> 的图就卡没了。</p><p>一万头草泥马奔腾而过……后来猛然发现 <span class="math inline">\(d\leq 5\)</span>，再加上之前一直不相信 NOIP 会出这种恶心的高精度 <span class="math inline">\(\gcd\)</span>，然后就直接肝 T3 了。</p><p>想到一种似乎有点优秀的算法，就上手了，中途修修补补了很多下，差不多 12:00 过大样例，写了个随机 generator 就放后台和 SPJ 拍了。</p><p>T4 也直接没管正解，想到一个 <span class="math inline">\(O(\sum_i^kw_i(\log w_i+k))\)</span> 就直接上手了，没有注意一些边界，卡了好久，最后在 12:50 过了大样例，可惜有亿点点慢。</p><p>然后就下考了，感觉考试很匆忙过得及其不真实，下考之后脑子就一片空白了。</p><p>出考场之后感觉大家都说题目难，似乎我的预计得分还比较可观。</p><p>和好基友一起吃了中饭，回学校看洛谷发现 T1 似乎真的要写高精？？？我可 $#%^#&amp;@。</p><p>当然这点点小插曲还是不能挡住我颓的，回家直接上号开干了。</p><h4 id="day3">Day3</h4><p>回归文化课的第一天，文化课还是那么拉胯。</p><p>晚上搞到了自己的程序，测了一下民间数据，90+96+100+60，似乎挺高，好像本省 rk2……？反正还是要被文化课踩。</p><h4 id="day4">Day4</h4><p>真·CCF·成绩出来了，60+92+100+65，这波 T1 是真的阴间了。</p><p>有亿点点怀念停课的时光，被文化课踩得有亿点点难受啊……</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;day--inf&quot;&gt;Day -INF&lt;/h4&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>莫队的奇技淫巧</title>
    <link href="http://example.com/2020/12/02/%E8%8E%AB%E9%98%9F%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>http://example.com/2020/12/02/%E8%8E%AB%E9%98%9F%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</id>
    <published>2020-12-02T03:57:08.000Z</published>
    <updated>2020-12-02T06:20:32.548Z</updated>
    
    <content type="html"><![CDATA[<p>莫队算法是一个很妙的算法，它可以通过对查询离线分块来降低算法复杂度。</p><p>但是仔细分析你会发现，莫队所有的复杂度都是修改左右端点造成的，而查询是 <span class="math inline">\(O(1)\)</span> 的。</p><p>也就是说我们可以在莫队中套一个修改 <span class="math inline">\(O(1)\)</span>，查询 <span class="math inline">\(O(1\sim \sqrt{n})\)</span> 的数据结构，这样总复杂度依旧是 <span class="math inline">\(O(n \sqrt{n})\)</span> 的，但是它却可以做更多的事情。</p><a id="more"></a><blockquote><p>例：有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a_1,a_2...a_n\}\)</span>。<span class="math inline">\(m\)</span> 次询问，每次询问一个区间内最小没有出现过的自然数。</p></blockquote><p>这个题目是洛谷的 P4137。</p><p>这个题的经典做法是主席树或者回滚莫队，我们现在考虑另一种做法。</p><p>先直接上莫队，这样我们是不好维护删除数的操作的。</p><p>考虑在莫队里面套上一个值域分块，修改的时候 <span class="math inline">\(O(1)\)</span> 修改，查询的时候 <span class="math inline">\(O(\sqrt{n})\)</span> 一个块一个块的跳。</p><p>虽然套了一个分块，但是复杂度是加在查询上面的 ，总复杂度仍然是 <span class="math inline">\(O(n\sqrt{n})\)</span> 的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;莫队算法是一个很妙的算法，它可以通过对查询离线分块来降低算法复杂度。&lt;/p&gt;
&lt;p&gt;但是仔细分析你会发现，莫队所有的复杂度都是修改左右端点造成的，而查询是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;也就是说我们可以在莫队中套一个修改 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，查询 &lt;span class=&quot;math inline&quot;&gt;\(O(1\sim \sqrt{n})\)&lt;/span&gt; 的数据结构，这样总复杂度依旧是 &lt;span class=&quot;math inline&quot;&gt;\(O(n \sqrt{n})\)&lt;/span&gt; 的，但是它却可以做更多的事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="莫队" scheme="http://example.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="分块" scheme="http://example.com/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列相关</title>
    <link href="http://example.com/2020/11/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2020/11/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/</id>
    <published>2020-11-27T12:36:56.000Z</published>
    <updated>2020-11-27T12:57:02.762Z</updated>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(F\)</span> 是斐波那契数列，其定义是对于 <span class="math inline">\(x\leq 2\)</span>，<span class="math inline">\(F(x)=1\)</span>；对于 <span class="math inline">\(x\geq 3\)</span>，<span class="math inline">\(F(x)=F(x-1)+F(x-2)\)</span>。</p><a id="more"></a><h4 id="gcdfxfyfgcdxy">1. <span class="math inline">\(\gcd(F(x),F(y))=F(gcd(x,y))\)</span> 。</h4><p>一个非常实用的结论。下面考虑证明。</p><h5 id="引理-1fxfytimes-fx-y1fy-1times-fx-y">引理 1：<span class="math inline">\(F(x)=F(y)\times F(x-y+1)+F(y-1)\times F(x-y)\)</span>。</h5><p>        把递推式逐级展开就可以得到这个式子。</p><p>        即 <span class="math inline">\(F(x)=F(x-1)+F(x-2)\Rightarrow F(x)=2F(x-2)+F(x-3)\Rightarrow F(x)=3F(x-3)+2F(x-4)...\)</span></p><h5 id="引理-2gcdfxfx-11">引理 2：<span class="math inline">\(\gcd(F(x),F(x-1))=1\)</span>。</h5><p>        仍然是把递推式展开迭代。</p><p>        即 <span class="math inline">\(\gcd(F(x),F(x-1))=\gcd(F(x-2)+F(x-1), F(x-1))=\gcd(F(x-2),F(x-1))...\)</span>。最后就可以得到 <span class="math inline">\(\gcd(F(2),F(1))\)</span>，这时结果显然是 <span class="math inline">\(1\)</span>。</p><p>有了这两个引理就可以证明上述结论了。</p><p>先假设 <span class="math inline">\(x&gt;y\)</span>，那么 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(y)\times F(x-y+1)+F(y-1)\times F(x-y),F(y))\)</span>。把这个式子套用上述两个引理，就有 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(x-y),F(y))\)</span>。可以发现这就是一个辗转相减的形式，直接套用欧几里得就有 <span class="math inline">\(\gcd(F(x),F(y))=F(\gcd(x,y))\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt; 是斐波那契数列，其定义是对于 &lt;span class=&quot;math inline&quot;&gt;\(x\leq 2\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(F(x)=1\)&lt;/span&gt;；对于 &lt;span class=&quot;math inline&quot;&gt;\(x\geq 3\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(F(x)=F(x-1)+F(x-2)\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数列" scheme="http://example.com/tags/%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线性基的瞎操作</title>
    <link href="http://example.com/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-11T08:03:04.000Z</published>
    <updated>2020-12-02T06:14:41.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查找某个数-x-可以被给出基底-a-如何异或得到">1. 查找某个数 <span class="math inline">\(x\)</span> 可以被给出基底 <span class="math inline">\(A\)</span> 如何异或得到</h4><p>把基底 <span class="math inline">\(A\)</span> 做线性基，并且在线性基的同时维护线性基中每个元素是由基底中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>，那么在查询的时候，把对应位置的 <span class="math inline">\(S\)</span> 也一起异或，就可以得到最终所求。</p><h4 id="把基底-a-的一个数-a_i-与另一个数-x-交换保证交换后基底-a-仍然满足基底的性质">2. 把基底 <span class="math inline">\(A\)</span> 的一个数 <span class="math inline">\(A_i\)</span> 与另一个数 <span class="math inline">\(x\)</span> 交换，保证交换后基底 <span class="math inline">\(A&#39;\)</span> 仍然满足基底的性质</h4><p>同上，在线性基的同时维护线性基中每个元素是由 <span class="math inline">\(A\)</span> 中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>。先查询 <span class="math inline">\(x\)</span> 怎么被 <span class="math inline">\(A\)</span> 表示，因为 <span class="math inline">\(A&#39;\)</span> 依旧满足基底的性质，那么如果用 <span class="math inline">\(A\)</span> 来表示 <span class="math inline">\(x\)</span>，那么 <span class="math inline">\(A_i\)</span> 一定会被用到。所以 <span class="math inline">\(A_i\)</span> 也可以用 <span class="math inline">\(A\)</span> 中的数和 <span class="math inline">\(x\)</span> 一起表示，那么就可以直接交换 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(A_i\)</span>，然后去更新线性基中的每个位置的 <span class="math inline">\(S\)</span> 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;查找某个数-x-可以被给出基底-a-如何异或得到&quot;&gt;1. 查找某个数 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 可以被给出基底 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 如何异或得到&lt;/h4&gt;</summary>
      
    
    
    
    
    <category term="数位" scheme="http://example.com/tags/%E6%95%B0%E4%BD%8D/"/>
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>用二进制模拟 K 进制</title>
    <link href="http://example.com/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/"/>
    <id>http://example.com/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/</id>
    <published>2020-11-11T03:39:21.000Z</published>
    <updated>2020-11-11T08:03:46.096Z</updated>
    
    <content type="html"><![CDATA[<p>被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。</p><a id="more"></a><p>先考虑怎么用二进制模拟三进制。</p><p>用 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s_0,s_1,s_2\)</span> 依次表示某数在三进制下，数位为 <span class="math inline">\(0,1,2\)</span> 的位的集合。</p><p>不难发现 <span class="math inline">\(s_0,s_1,s_2\)</span> 两两无交。</p><p>那么对于两个数的三进制下位运算，就可以通过枚举两数的 <span class="math inline">\(s_0,s_1,s_2\)</span>，得到两数在三进制下数位为 <span class="math inline">\(0,1,2,3,4\)</span> 的位的集合。且这些集合也两两无交。</p><p>之后再通过位运算的定义，把五个集合重新整理成新的 <span class="math inline">\(s_0,s_1,s_2\)</span>。</p><p>复杂度是 <span class="math inline">\(O(9)\)</span> 的（因为需要枚举 <span class="math inline">\(s_0,s_1,s_2\)</span>）。</p><p>类似的，这种做法也可以推广到 K 进制下，复杂度是 <span class="math inline">\(O(K^2)\)</span> 的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数位" scheme="http://example.com/tags/%E6%95%B0%E4%BD%8D/"/>
    
    <category term="进制" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S2 2020 游记</title>
    <link href="http://example.com/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-11-08T06:06:03.000Z</published>
    <updated>2020-12-02T06:26:21.642Z</updated>
    
    <content type="html"><![CDATA[<h4 id="day--1">Day -1</h4><a id="more"></a><p>考了一场很秀的模拟赛。</p><p>开局看题，发现 T1,T2,T4 都是一眼题，代码难度 T1&lt;T4&lt;T2。于是 rush 完 T1 之后直接肝 T3。</p><p>肝了 1.5h 没肝出来，决定先稳一波 rush 一手 T4，rush 完写对拍的时候监考老师绕到了我的后面。</p><p>“这是第四题吗？”</p><p>“嗯。”</p><p>“这是什么？对拍吗？”</p><p>“嗯。”</p><p>“那你是不是都做完了？”</p><p>“没有，只写了 T1,T4。”</p><p>"哦~"</p><p>似乎这只是一个平平无奇的对话，但不久后监考老师冷不丁来一句：“其实这套题目并不完全是按照难度排序，T3 应该要比 T2 简单。”</p><p>一只南美洲亚马逊河流域热带雨林中的蝴蝶，偶尔扇动几下翅膀，可以在两周以后引起美国得克萨斯州的一场龙卷风。监考老师的一句提醒，也可以引起很多人做题策略的改变。</p><p>我听完之后虽然有点小慌，但是之前就已经止损过了，所以还是稳着先把 T2 写了，最后才去肝 T3。</p><p>但是很多人都因为这一句话，直接硬肝 T3，结果全盘皆崩。</p><p>我们称这个事件为【Y 郎妙计安天下】。</p><h4 id="day-0">Day 0</h4><p>又是一场披着 CSP 皮的毒瘤模拟赛。</p><p>真想拿个仙人掌拍出题人头上让他见识一下什么才是真正的仙人掌。</p><p>不过有一说一，感觉现在码力变强了好多，一开始误认为仙人掌是点不重复，rush 了 4k 多，发现错了之后又重新 ruch 了 4k 多结果还一遍过……</p><p>考前毒奶：因为 CSP 毕竟是合格性考试，所以不会太难，T1,T2 应该都是送分，T3,T4 略难一点。</p><h4 id="day-1">Day 1</h4><p>为了考前不颓废，VP 了一场 CF Div.1。</p><p>Rush 完 A,B 后，发现 C 是一个计算几何，D 是一个比较麻烦的 DP，瞬间失去了写代码的欲望。</p><p>结果剩下的时间差不多都在知乎、2020 US Election、Typeracer、Pokemonshowdown 之间徘徊。<del>考前颓废是 OIER 的传统艺能。</del></p><p>吃完中饭就去考场了。因为自己动作比较憨，上车的时候就只有后排中间的 C 位了，于是就有了名场面【Dan 皇登基】（雾</p><p>考前集体毒奶：早出来一小时就可以多休息一小时，今天下午直接车队走起。</p><p>考试体验依旧很 nice，座位很舒适，键盘很丝滑，配置很体贴。</p><p>但是……题目很毒瘤。</p><p>浏览一遍题目之后直接想自闭离场了。</p><p>打个比方，切题就类似于在山里找宝藏，有些宝藏是藏得很深，需要你依靠自己的能力找到宝藏的位置<del>（宝藏猎人）</del>。而有些宝藏就直接给扔山顶，一眼就看得到，不过如果想得到它就需要花大功夫。</p><p>T1 就是后者，而且山顶还不是普通山的山顶，那是珠穆朗玛峰的山顶。</p><p>硬着头皮肝 T1，40min，一遍过。</p><p>硬着头皮肝 T2，20min，一遍过。</p><p>T3 一开始一点思路都没有，结果就直接想睡觉了……<del>（强烈抗议 CSP-S2 又耽误我睡觉）</del>。</p><p>迷迷糊糊了 30min，状态回暖之后直接把 T4 70 分暴力 rush 了，然后继续肝 T3。</p><p>离下考还有 50min 了时候隐隐约约有了一个算法，然后直接 rush，30 min 写完一遍过样例。</p><p>剩下的时间感觉 T4 优化无望，于是就各种检查。</p><p>预计 100+100+100+70=370，似乎不低的样子。</p><p>考完之后就是颓颓颓！！！</p><h4 id="day-2">Day 2</h4><p>CSP 已经没有 Day 2 了……又要继续为 NOIP 奋斗了。</p><p>测了一下民间数据，T1,T2,T4 100+100+70 稳了，但是 T3 有点点问题。</p><p>后来发现我本质上要维护的是后缀积，但是我的做法是维护整体积除前缀积，然而数据范围是 <span class="math inline">\(0\leq V_j\leq 10^4\)</span>……</p><p>现在我的成绩完全掌握在 T3 出题人的手中了……希望 TA 能大发慈悲，可怜可怜没注意 <span class="math inline">\(V_j=0\)</span> 的孩子吧。</p><h4 id="day-inf">Day INF</h4><p>呐~命运被掌握在别人手中的感觉真是很不好呢。</p><p>最后 100+100+70+70 了，T3 被卡到还不如指数级暴力 <code>(* ￣︿￣)</code>。</p><p>最后当然是 NOIP 2020 RP++。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;day--1&quot;&gt;Day -1&lt;/h4&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
