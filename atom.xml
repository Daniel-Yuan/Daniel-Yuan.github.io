<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel_yuan&#39;s Blog</title>
  
  <subtitle>芙卡米天下第一可爱 n(*≧▽≦*)n</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-12T03:53:07.974Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Daniel_yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络流进阶</title>
    <link href="http://example.com/2021/01/09/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2021/01/09/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BF%9B%E9%98%B6/</id>
    <published>2021-01-09T07:39:41.000Z</published>
    <updated>2021-01-12T03:53:07.974Z</updated>
    
    <content type="html"><![CDATA[<p>网络流进阶。主要是有上下界的各种网络流或费用流以及几个消负环的方法。</p><p>在看这个 Blog 之前你最好已经熟练掌握了 Dinic 网络流和 EK 费用流。</p><a id="more"></a><h4 id="无源汇有上下界的循环流">1. 无源汇有上下界的循环流</h4><p>这是最简单的一种有上下界的网络流，也是所有有上下界的网络流的基础。</p><p>其所求大意如下：对于一张网络流的图，每条边有一个流量限制 <span class="math inline">\([l,r]\)</span>，现在需要给每条边分配一个流量，使得每个点的流量平衡（即流入等于流出），且每条边的流量满足限制。</p><p>考虑先把每条边的流量设为其下界，设置完之后我们得到了一个初始流，这个流的流量都满足边的限制，但是不一定满足流量平衡。</p><p>考虑构造一个附加流，使得初始流加上附加流在满足边的限制的情况下满足流量平衡。</p><p>因为这个附加流仍需要满足边的限制，所以原来的一条边 <span class="math inline">\((u,v,l,r)\)</span>，可以看成是一条 <span class="math inline">\(u\)</span> 连向 <span class="math inline">\(v\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的边，这样在附加流中这条边的流量就只能是 <span class="math inline">\([0,r-l]\)</span>，一定会满足边的限制。</p><p>然后就只需要考虑流量平衡。对于一个点 <span class="math inline">\(x\)</span>，如果其流入大于流出，那么它就仍然需要流出一些流量。考虑新增一个虚拟起点 <span class="math inline">\(S&#39;\)</span>，连一条 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(x\)</span> 流量为流入和流出的差值的边。这条边每有 <span class="math inline">\(1\)</span> 个流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流出增加了 <span class="math inline">\(1\)</span>。类似的，如果点 <span class="math inline">\(x\)</span> 的流出大于流入，那么它就仍然需要流入一些流量，就新增一个虚拟终点 <span class="math inline">\(T&#39;\)</span>，连条 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(T&#39;\)</span> 流量为流出和流入的差值的边。这条边每有 <span class="math inline">\(1\)</span> 流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流入增加了 <span class="math inline">\(1\)</span>。</p><p>最后对新图 <span class="math inline">\(S&#39;-T&#39;\)</span> 跑一遍最大流，由前文的构造附加流的过程可知，可以使得其流量平衡当且仅当该图的最大流使得所有 <span class="math inline">\(S&#39;\)</span> 连出的边都满流（<span class="math inline">\(S&#39;\)</span> 连出的边都满流等价于 <span class="math inline">\(T&#39;\)</span> 连入的边都满流），否则的话无解。</p><p>最后每条边的流量就是下界加上附加流中该边的流量。</p><h4 id="有源汇有上下界的可行流">2. 有源汇有上下界的可行流</h4><p>有源汇和无源汇的最大的区别就是源点 <span class="math inline">\(S\)</span> 和汇点 <span class="math inline">\(T\)</span> 的流量不平衡。</p><p>考虑连一条 <span class="math inline">\(T\)</span> 连向 <span class="math inline">\(S\)</span> 流量下界为 <span class="math inline">\(0\)</span> 上界为 <span class="math inline">\(+\infty\)</span> 的边，这样 <span class="math inline">\(S\)</span> 的流出和 <span class="math inline">\(T\)</span> 的流入就都可以靠这条边来弥补，使得其流量平衡。</p><p>这时候就只需要求循环流了，即 1.。</p><p>不难发现，<span class="math inline">\(T\rightarrow S\)</span> 的流只可能走我们新加的边，所以附加流的总流量就是新加边的流量。但是这并不意味着新加边的流量等于 <span class="math inline">\(S&#39;\rightarrow T&#39;\)</span> 的最大流，因为原图中可能有环。</p><p>而可行流的流量就是 <span class="math inline">\(S\)</span> 的流出量（也就是 <span class="math inline">\(T\)</span> 的流入量），也等于新加边的流量。故可行流的流量等于附加流的流量。</p><h4 id="有源汇有上下界的最大流">3. 有源汇有上下界的最大流</h4><p>和 2. 类似的，我们可以先求出一个可行流。</p><p>此时对原图的残量网络再跑一次 <span class="math inline">\(S-T\)</span> 的最大流即可。</p><p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(S-T\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(S&#39;-T&#39;\)</span>。</p><p>如果你在跑 <span class="math inline">\(S-T\)</span> 最大流的时候，去掉了前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边，那么最大流就是残量网络上求出的最大流加上附加流的流量。否则，根据网络流的性质，此时可以通过所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边的反向边，直接从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 流附加流的流量，所以最大流就是残量网络上求出的最大流流量 。</p><h4 id="有源汇有上下界的最小流">4. 有源汇有上下界的最小流</h4><p>和 2. 类似的，我们可以先求出一个可行流。</p><p>然后考虑从 <span class="math inline">\(T\)</span> 向 <span class="math inline">\(S\)</span> 退流，这样就可以使得流量尽可能小。</p><p>即在残量网络上跑一遍 <span class="math inline">\(T-S\)</span> 的最大流。用附加流流量减去这个最大流的流量即最小流。</p><p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(T-S\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(T&#39;-S&#39;\)</span>。</p><p>此时前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边必须要去掉，不然会通过这条边退 <span class="math inline">\(+\infty\)</span> 的流导致求不到答案。</p><h4 id="有源汇有上下界的最小费用可行流最大流最小流">5. 有源汇有上下界的最小费用可行流/最大流/最小流</h4><p>为了方便，暂时不考虑负环，后面会提到两个消负环的算法。</p><p>最大费用和最小费用等价，所以暂且不考虑最大费用。</p><p>其实本质上就是在 2.3.4. 的基础上，加上一个最小费用。</p><p>即在一开始每条边强行流 <span class="math inline">\(l\)</span> 的流量的时候，把总费用加上 <span class="math inline">\(l\times cost\)</span>。</p><p>所有辅助边的费用都设为 <span class="math inline">\(0\)</span>。</p><p>在求附加流的时候是跑的最小费用最大流。最大流不满流仍然无解。</p><p>最后在残量网络上面跑的时候，如果是 <span class="math inline">\(S-T\)</span>，跑的是最小费用最大流，如果是 <span class="math inline">\(T-S\)</span>，跑的是最大费用最大流（正着流费用最小就是退的流费用最大）。</p><h4 id="有上下界的另一种连边方法">6. 有上下界的另一种连边方法</h4><p>为了省事，可以把边 <span class="math inline">\((u,v,l,r,c)\)</span> 拆成三条边。一条 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(r-l\)</span> 费用为 <span class="math inline">\(c\)</span>，一条虚拟起点 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>，一条 <span class="math inline">\(u\)</span> 到虚拟终点 <span class="math inline">\(T&#39;\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>。并把总费用加上 <span class="math inline">\(l\times c\)</span>。</p><p>不难发现这种连边方法和 1. 的连边方法本质相同。只是把之前所考虑的一个点总流入和总流出的差分解成了若干个部分，或者说可以看成是之前直接把所有形如 <span class="math inline">\(S&#39;\rightarrow x \rightarrow T&#39;\)</span> 的流全部流完了。</p><h4 id="消负环算法">7. 消负环算法</h4><p>对于一条负权边 <span class="math inline">\((u,v,l,r,c)\)</span>，我们可以先强行把这条负权边流满，并获得 <span class="math inline">\(r\times c\)</span> 的总费用，然后这条边就变成了从 <span class="math inline">\(v\)</span> 连向 <span class="math inline">\(u\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的费用为 <span class="math inline">\(-c\)</span> 的边。这样强制流之后显然不一定满足流量平衡，所以需要用上述的附加流的方法使其流量平衡。</p><p>因为在整个图中一开始没有出现负环，所以在整个过程中也不会产生负环（可能比较糊……暂时还没有证明，或许显然？）。</p><p>另外还有一种很神的消负环算法，可见<a href="https://www.cnblogs.com/lsq147/p/14232399.html">这位神仙的博客</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络流进阶。主要是有上下界的各种网络流或费用流以及几个消负环的方法。&lt;/p&gt;
&lt;p&gt;在看这个 Blog 之前你最好已经熟练掌握了 Dinic 网络流和 EK 费用流。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>字符串的回文划分</title>
    <link href="http://example.com/2021/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/"/>
    <id>http://example.com/2021/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/</id>
    <published>2021-01-07T07:44:43.000Z</published>
    <updated>2021-01-11T11:54:34.428Z</updated>
    
    <content type="html"><![CDATA[<p>定义一个串 <span class="math inline">\(S\)</span> 的划分 <span class="math inline">\(s_1,s_2...s_k\)</span> 为回文划分当且仅当 <span class="math inline">\(s_1,s_2...s_k\)</span> 都是回文串。</p><p>现在考虑求一个串 <span class="math inline">\(S\)</span> 的回文划分数。<span class="math inline">\(1\leq |S| \leq 10^6\)</span>。</p><a id="more"></a><hr /><p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始，且 <span class="math inline">\(S[l:r]\)</span> 为字符串 <span class="math inline">\(S\)</span> 中 <span class="math inline">\(s[l],s[l+1]...s[r]\)</span> 这个子串。</p><p>考虑设 <span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(i\)</span> 结尾的这个前缀的回文划分方案数。</p><p>转移显然，即 <span class="math inline">\(f[i]=\sum f[i-L]~(S[i-L+1:i] \text{是回文串})\)</span>。</p><p>如果枚举 <span class="math inline">\(i,L\)</span> 再暴力判断，复杂度会达到严格 <span class="math inline">\(O(|S|^3)\)</span>，如果用一些方法预处理快速判断一个串是不是回文串，可以做到严格 <span class="math inline">\(O(|S|^2)\)</span>。</p><p>考虑优化，对于快速找到回文 Border，可以使用回文自动机，这样每次在当前节点跳 <span class="math inline">\(parent\)</span> 边跳到的都是回文后缀，这样就可以直接转移。复杂度是 <span class="math inline">\(O(\sum_i \text{以 i 结尾的回文后缀个数})\)</span>，在随机数据下跑得很快。但是这样显然可以被 <span class="math inline">\(aa...aa\)</span> 卡到 <span class="math inline">\(O(|S|^2)\)</span>。故考虑进一步优化。</p><blockquote><p>引理 <span class="math inline">\(1\)</span> : 对于一个串 <span class="math inline">\(S\)</span> 的所有长度大于 <span class="math inline">\(\frac{|S|}{2}\)</span> 的回文 Border，它们的长度形成一个等差数列。</p></blockquote><p>证明：拿出最长的回文 Border <span class="math inline">\(T\)</span>，那么 <span class="math inline">\(S\)</span> 就存在周期 <span class="math inline">\(|S|-|T|\)</span>，所以长度为 <span class="math inline">\(|S|-2(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border，长度为 <span class="math inline">\(|S|-3(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border……把这一组 Border 去掉之后，剩下的回文 Border 长度一定小于等于 <span class="math inline">\(\frac{|S|}{2}\)</span>，不然的话 <span class="math inline">\(T\)</span> 就不会是最长的回文 Border。</p><p>这样在 DP 中可以转移的点也可以被分成 <span class="math inline">\(\log_2|S|\)</span> 个等差数列。我们就可以这么做：预处理 <span class="math inline">\(F[i][j]\)</span> 表示 <span class="math inline">\(f[i]+f[i-j]+...\)</span>，那么对于一个等差数列，如果其公差小于一个阈值，就直接查表，否则暴力跳。这样复杂度上限可以被优化到 <span class="math inline">\(O(|S|\sqrt{|S|\log_2|S|})\)</span>，实际效率未知。</p><p>我们把某个等差数列拿出来，看看它有什么性质。</p><p><img src="https://s3.ax1x.com/2021/01/07/smA5qg.png" /></p><p>这是 <span class="math inline">\(4\)</span> 个形成等差数列的 Border。</p><p>我们把每个 Border 按照比恰好比它长的 Border 的回文中心对称过去，可以发现它的开头是恰好比它长的 Border 的开头，结尾都在同一个位置。</p><p>如果设 <span class="math inline">\(g[x]\)</span> 为在回文自动机上以 <span class="math inline">\(x\)</span> 为末项的回文 Border 的 <span class="math inline">\(\sum f\)</span>，把上图的串从上到下依次编号成 <span class="math inline">\(1,2,3,4\)</span>，那么我们可以发现，对于现在要求的 <span class="math inline">\(g[4]\)</span>，有很大一部分已经被 <span class="math inline">\(g[3]\)</span> 算过了（<span class="math inline">\(g[3]\)</span> 即红色条纹部分，<span class="math inline">\(g[4]\)</span> 即黑色条纹部分），因为我们到现在这个位置计算 <span class="math inline">\(g[4]\)</span> 时，一定会先走过计算 <span class="math inline">\(g[3]\)</span> 的位置。所以就只需要使 <span class="math inline">\(g[4]=g[3]\)</span> 且把 <span class="math inline">\(g[4]\)</span> 额外加上【除掉当前等差数列最小的 Border 的那个 <span class="math inline">\(f\)</span> 】即可。</p><p>这样就可以在 <span class="math inline">\(O(n\log_2 n)\)</span> 的时间内解决该题。</p><!-- more --><p>直接讨论回文划分太抽象了，举个具体例子。</p><h5 id="cf932g-palindrome-partition">CF932G Palindrome Partition</h5><p>给定一个串 <span class="math inline">\(S\)</span>，把串分为偶数段。</p><p>假设分为了 <span class="math inline">\(s_1,s_2,s_3....s_k\)</span>。</p><p>求，满足 <span class="math inline">\(s_1=s_k,s_2=s_{k−1}.....\)</span> 的方案数。</p><p><span class="math inline">\(2\leq |S| \leq 10^6\)</span>，方案数对 <span class="math inline">\(10^9+7\)</span> 取模。</p><hr /><h5 id="solution">Solution:</h5><p>乍一看这个题和回文划分没有什么关系，但是我们不妨分析一手。</p><p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始。</p><p>考虑逐个考虑 <span class="math inline">\(s_1\)</span> 和 <span class="math inline">\(s_k\)</span>，<span class="math inline">\(s_2\)</span> 和 <span class="math inline">\(s_{k-1}\)</span> 这样的匹配对。我们发现当剩余串的长度固定的时候，留下的是中间某一个固定的段，这样就不是很好，因为我们很难得到中间某个串的信息。所以尝试把这个串修改一下使得每次分段都是一个连续的区间，即改成 <span class="math inline">\(s[1]s[n]s[2][n-1]...\)</span>，这样我们就可以发现，对于一个分段，它都是一个长度为偶数的连续区间，且该串为回文串。</p><p>这样问题就转化成了：把一个串 <span class="math inline">\(S\)</span> 分解成若干个长度为偶数的回文串的方案数。直接用上面的算法做即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN], t[MAXN];</span><br><span class="line"><span class="keyword">int</span> child[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], parent[MAXN &lt;&lt; <span class="number">1</span>], mxlen[MAXN &lt;&lt; <span class="number">1</span>], cnt = <span class="number">2</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN &lt;&lt; <span class="number">1</span>], bot[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFail</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (now &amp;&amp; s[pos] != s[pos - mxlen[now] - <span class="number">1</span>])</span><br><span class="line">    now = parent[now];</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = (i &amp; <span class="number">1</span>) ? t[i / <span class="number">2</span> + <span class="number">1</span>] : t[n - i / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">//  cerr &lt;&lt; (s + 1) &lt;&lt; endl;</span></span><br><span class="line">  parent[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  mxlen[<span class="number">1</span>] = <span class="number">0</span>, mxlen[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    child[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ch = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    last = GetFail(last, i);</span><br><span class="line">    <span class="keyword">if</span> (child[last][ch])</span><br><span class="line">      last = child[last][ch];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ++cnt;</span><br><span class="line">      child[last][ch] = cnt;</span><br><span class="line">      mxlen[cnt] = mxlen[last] + <span class="number">2</span>;</span><br><span class="line">      parent[cnt] = child[GetFail(parent[last], i)][ch];</span><br><span class="line">      last = cnt;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[parent[cnt]] * <span class="number">2</span> &gt; mxlen[cnt] &amp;&amp; (!d[parent[cnt]] || mxlen[cnt] - mxlen[parent[cnt]] == d[parent[cnt]])) &#123;</span><br><span class="line">        d[cnt] = mxlen[cnt] - mxlen[parent[cnt]], bot[cnt] = bot[parent[cnt]];</span><br><span class="line">        d[parent[cnt]] = mxlen[cnt] - mxlen[parent[cnt]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        d[cnt] = <span class="number">0</span>, bot[cnt] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI cur = last; cur; cur = parent[bot[cur]]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bot[cur] != cur)</span><br><span class="line">        g[cur] = g[parent[cur]];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g[cur] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[bot[cur]])</span><br><span class="line">        g[cur] = (g[cur] + f[i - mxlen[bot[cur]]]) % mod;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        f[i] = (f[i] + g[cur]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;定义一个串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的划分 &lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2...s_k\)&lt;/span&gt; 为回文划分当且仅当 &lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2...s_k\)&lt;/span&gt; 都是回文串。&lt;/p&gt;
&lt;p&gt;现在考虑求一个串 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 的回文划分数。&lt;span class=&quot;math inline&quot;&gt;\(1\leq |S| \leq 10^6\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="PAM" scheme="http://example.com/tags/PAM/"/>
    
  </entry>
  
  <entry>
    <title>Hall 定理学习笔记</title>
    <link href="http://example.com/2021/01/04/Hall-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/01/04/Hall-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-04T13:08:22.000Z</published>
    <updated>2021-01-05T09:01:12.694Z</updated>
    
    <content type="html"><![CDATA[<p>在网上学习了 Hall 定理后决定写这么个东西。</p><p>如有雷同或涉及侵权，请联系博主。</p><a id="more"></a><h3 id="定理内容">定理内容</h3><p>对于一个二分图，假设其左边节点个数小于等于右边节点个数，并设左边节点个数为 <span class="math inline">\(X\)</span>，右边为 <span class="math inline">\(Y\)</span>。</p><p>若从左边选出任意 <span class="math inline">\(k\)</span> 个节点，右边都有至少 <span class="math inline">\(k\)</span> 个节点与之相连，那么该二分图的最大匹配个数恰好为 <span class="math inline">\(X\)</span>。我们称满足这个条件的匹配为完美匹配。</p><p>为了方便，在下文中默认左边的节点数小于等于右边的节点数。</p><h3 id="证明">证明</h3><p>考虑从必要和充分两方面证明这个定理。</p><h4 id="必要性">1. 必要性</h4><p>如果一个二分图有完美匹配，且其不满足 Hall 定理。</p><p>那么对于左边某 <span class="math inline">\(k\)</span> 个节点，右边与之相连的点数小于 <span class="math inline">\(k\)</span>。</p><p>而根据假设，左边这 <span class="math inline">\(k\)</span> 个节点都匹配了右边 <span class="math inline">\(k\)</span> 个不同的节点，那么右边与之相连的点数至少为 <span class="math inline">\(k\)</span>。</p><p>前后两者是矛盾的，所以该假设不成立，故必要性得证。</p><h4 id="充分性">2. 充分性</h4><p>如果一个二分图满足 Hall 定理，且其没有完美匹配。</p><p>考虑分两个部分来证明它。</p><h5 id="part1.-若左边每个点的度数都大于等于-2">Part1. 若左边每个点的度数都大于等于 <span class="math inline">\(2\)</span>。</h5><p>我们在左边可以找到一个没有匹配的点 <span class="math inline">\(l_1\)</span>。它一定会连接到一个右边的节点 <span class="math inline">\(r_1\)</span>。</p><p>如果 <span class="math inline">\(r_1\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p><p>否则 <span class="math inline">\(r_1\)</span> 会匹配到一个左边的节点 <span class="math inline">\(l_2\)</span>。那么 <span class="math inline">\(l_2\)</span> 一定会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p><p>如果 <span class="math inline">\(r_2\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p><p>否则……</p><p>这样会一直循环下去，而点数有限，那么必然终止，所以整体与假设矛盾。</p><h5 id="part2.-若左边有点的度数等于-1">Part2. 若左边有点的度数等于 <span class="math inline">\(1\)</span></h5><p>有点的度数为 <span class="math inline">\(1\)</span> 就可能出现一个问题，就是上述证明的 <span class="math inline">\(l_2\)</span> 若度数为 <span class="math inline">\(1\)</span>，则不会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p><p>但其实这样也是可以证明的。假设 <span class="math inline">\(l_1\)</span> 的度数为 <span class="math inline">\(1\)</span>，那么若 <span class="math inline">\(l_2\)</span> 的度数也为 <span class="math inline">\(1\)</span>，就会因为它们连接着同一个点 <span class="math inline">\(r_1\)</span> 而不满足 Hall 定理矛盾（如果左边选择这两个点，右边只有一个点与之相连）</p><p>假设 <span class="math inline">\(l_1\)</span> 的度数大于等于 <span class="math inline">\(2\)</span>，而 <span class="math inline">\(l_2\)</span> 的度数为 <span class="math inline">\(1\)</span>。那么我们可以把这条增广路反向，这样 <span class="math inline">\(l_2\)</span> 就变成了 <span class="math inline">\(l_1\)</span>，再用上面的证明即可。</p><hr /><h3 id="引申">引申</h3><p>定义二分图的 K-完美匹配 为二分图有 <span class="math inline">\(K\)</span> 个完全不相交的完美匹配。</p><p>现在考虑该图要满足什么条件才有 K-完美匹配。</p><p>这个题是一个经典问题，有一个很经典的网络流做法，博主根据这个做法以及一些分析归纳出了下列定理：（可能是个经典定理，但是博主找不到）</p><p>对于一个二分图，如果可以通过删边的操作，使得左边的每个点的度数都为 <span class="math inline">\(K\)</span>，且右边的每个点的度数都小于等于 <span class="math inline">\(K\)</span>，那么一定存在 K-完美匹配。</p><h3 id="证明-1">证明</h3><p>还是从必要和充分两方面证明这个引理。</p><h4 id="充分性-1">1. 充分性</h4><p>考虑用归纳法证明。</p><h5 id="先证明-k1-成立">1. 先证明 <span class="math inline">\(K=1\)</span> 成立。</h5><p>从左边任选一个点，然后找到它相连的点，匹配。</p><p>根据前提条件，这条边是这两个点连出的唯一一条边。</p><p>这样这个问题就变成了一个条件不变规模更小的问题。</p><p>一直这么下去就可以得到一个完美匹配。</p><h5 id="假设证明了-kleq-x-1-成立再证明-kx-成立">2. 假设证明了 <span class="math inline">\(K\leq x-1\)</span> 成立，再证明 <span class="math inline">\(K=x\)</span> 成立。</h5><p>首先这个图满足 Hall 定理。因为对于左边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而右边的点的度数的上限是 <span class="math inline">\(x\)</span>，那么右边至少会有 <span class="math inline">\(k\)</span> 个点与其相连。</p><p>把左边所有点和右边所有的度数恰好为 <span class="math inline">\(x\)</span> 的点及它们之间的边拿出来构成一个新图，此时的这张图是<strong>右边的点数小于等于左边的点数的</strong>，那么对于右边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而左边的点的度数上限是 <span class="math inline">\(x\)</span>，那么至少左边会有 <span class="math inline">\(k\)</span> 个点与其相连。</p><p>这样的话对于这个新图，就存在一个完美匹配。构造出这个完美匹配后，回到原图，保留新图的匹配，再用匈牙利算法形成一个原图的完美匹配。然后把这个完美匹配删掉，剩下的图恰好满足 <span class="math inline">\(K=x-1\)</span> 的性质，而通过归纳，<span class="math inline">\(K=x-1\)</span> 已经被证明，故充分性得证。</p><h4 id="必要性-1">2. 必要性</h4><p>若左边存在一个点的度数小于 <span class="math inline">\(K\)</span>，那么显然不存在一个 K-完美匹配。不然一定存在一种删边方式使得左边的度数等于 <span class="math inline">\(K\)</span>。</p><p>如果删边之后左边存在一个点的度数大于 <span class="math inline">\(K\)</span>，那么 K-完美匹配 后一定会剩下一些边，那么把这些便删掉也不影响判断。</p><p>那么现在可能使得该定理必要性不存在的就只有：左边的所有点的度数为 <span class="math inline">\(K\)</span>，且右边存在一个点的度数大于 <span class="math inline">\(K\)</span>，且该二分图存在 K-完美匹配。</p><p>但是你会发现上述情况是不可能存在的，因为在删除 K-完美匹配 的边后，左边的点的度数就都变成了 <span class="math inline">\(0\)</span>，而右边此时会存在至少一个点的度数大于 <span class="math inline">\(0\)</span>（因为每一个匹配最多让一个点的度数减一），这是矛盾的。</p><p>故必要性得证。</p><p>这就能解释对于二分图的 K-完美匹配 的判定，为何可以用【 <span class="math inline">\(S\)</span> 向左边的点连流量为 <span class="math inline">\(K\)</span> 的边，在每个二分图上的边中左边的点向右边的点连流量为 <span class="math inline">\(1\)</span> 的边，右边的点向 <span class="math inline">\(T\)</span> 连流量为 <span class="math inline">\(K\)</span> 的边，看网络流的结果中左边的点是否都满流】来判断了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网上学习了 Hall 定理后决定写这么个东西。&lt;/p&gt;
&lt;p&gt;如有雷同或涉及侵权，请联系博主。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络流" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="二分图" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>[HNOI2019]JOJO 题解</title>
    <link href="http://example.com/2020/12/29/HNOI2019-JOJO-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2020/12/29/HNOI2019-JOJO-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-12-29T07:40:47.000Z</published>
    <updated>2021-01-02T00:26:27.773Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目的 <span class="math inline">\(2\)</span> 操作代表着需要维护一个可持久化的东西。</p><p>但是因为它没有强制在线，根据常识，可以离线生成一个操作树来降低思考难度。</p><p>不难发现最终的字符串的长度可能会非常长，可以达到 <span class="math inline">\(n\cdot x=10^9\)</span> 级别，这提示我们不能从字符串本身入手。</p><a id="more"></a><p>考虑一个后缀是 Border 需要满足什么条件，假设现在有字符串 <span class="math inline">\(aa|c|bb|aaa|c|b\)</span>，其中的一个 Border 就是 <span class="math inline">\(aacb\)</span>。我们把它的对应段拿出来，即 <span class="math inline">\((a,2)(c,1)(b,2)\)</span> 和 <span class="math inline">\((a,3)(c,1)(b,1)\)</span>，可以发现的是，它的第一段的长度必须大于等于整个字符串的第一段的长度，它的最后一段的长度必须要小于等于对应段的长度，而中间部分必须完全相同。</p><p>所以我们可以考虑把每个操作看成是 <span class="math inline">\((c_i,x_i)\)</span> ，并且用 KMP 维护这个过程。</p><p>首先考虑怎么维护 <span class="math inline">\(fail\)</span> 数组。需要特别注意的是，因为我们现在使用增量法求答案（树结构的性质使然），所以这里的 <span class="math inline">\(fail\)</span> 定义为一个最长的后缀，使得该后缀的第一段的长度大于等于整个字符串的第一段的长度，且剩下部分和整个字符串后面部分<strong>完全相同</strong>。这和一般的 <span class="math inline">\(fail\)</span> 略微有点区别。</p><p>我们现在的操作是一个<strong>树结构</strong>，而 KMP <strong>暴力</strong>找 <span class="math inline">\(fail\)</span> 的复杂度是<strong>均摊</strong>的，所以我们在加入一个段的时候并不能直接暴力跳 <span class="math inline">\(fail\)</span> 指针。考虑设 <span class="math inline">\(nxt_{now,c,x}\)</span> 表示在节点 <span class="math inline">\(now\)</span>，加上 <span class="math inline">\(x\)</span> 的字符 <span class="math inline">\(c\)</span> 会跳到哪里，可以用主席树维护这个东西，即把 <span class="math inline">\(nxt_{now,c}\)</span> 看成是一个线段树，每次扫到一个儿子时把 <span class="math inline">\(nxt_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(nxt_{now,C}\)</span> 中的 <span class="math inline">\(X\)</span> 赋值成这个儿子即可。</p><p>需要特别注意的是，我们前面有【Border 的第一段的长度必须大于等于整个串的第一段的长度】，也就是说对于一个串，如果它的 <span class="math inline">\(fail\)</span> 需要考虑整个串的第一段的时候稍微有点特殊，直接把整个串的第一段看成是 <span class="math inline">\((c,x\sim 10000)\)</span> 的段即可。</p><p>这样我们就动态维护出了 <span class="math inline">\(fail\)</span> 数组，考虑通过这个来维护答案。</p><p>假设现在加入的段是 <span class="math inline">\((c,x)\)</span>。</p><p>把它的 <span class="math inline">\(fail\)</span> 树上到根的链拿出来，假设是一个这样的结构。其中 <span class="math inline">\((c,x_i)\)</span> 表示这个点下面有一个 <span class="math inline">\((c,x_i)\)</span> 的操作。<span class="math inline">\(length\)</span> 表示整个字符串到它这里的长度。</p><p><img src="https://s3.ax1x.com/2020/12/29/rbk5Mq.png" /></p><p>可以发现对于长度为 <span class="math inline">\([1,x1]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的 <span class="math inline">\(nxt\)</span> 长度是 <span class="math inline">\(length_{fail1}+i\)</span>。对于 <span class="math inline">\([x1+1,x2]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的<span class="math inline">\(nxt\)</span> 的长度是 <span class="math inline">\(length_{fail2}+i\)</span>，以此类推。我们把这个长度给拆开，那么一部分是 <span class="math inline">\(length\)</span> 的和，一部分是 <span class="math inline">\(i\)</span> 的和。对于后者，只要求出其 <span class="math inline">\(fail\)</span> 链上最长的一个 <span class="math inline">\(x\)</span>，总和就是 <span class="math inline">\(\frac{x(x+1)}{2}\)</span>。对于前者，可以发现如果一个地方有多个选择，一定选择 <span class="math inline">\(length\)</span> 最长的一个，而我们整个过程是在树上遍历，每次往下走 <span class="math inline">\(length\)</span> 是单调不减的，所以可以类似于维护 <span class="math inline">\(fail\)</span>，用 <span class="math inline">\(len_{now,c,x}\)</span> 表示这个点 <span class="math inline">\(now\)</span> 一直往上跳 <span class="math inline">\(fail\)</span> 树，往下加 <span class="math inline">\(x\)</span> 的最大 <span class="math inline">\(length\)</span>，用主席树维护 <span class="math inline">\(len_{now,c}\)</span>，每次扫的一个儿子时把 <span class="math inline">\(len_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(len_{now,c}\)</span> 中的 <span class="math inline">\(1\sim X\)</span> 赋值成 <span class="math inline">\(length_{now}\)</span>。</p><p>需要注意的是，如果这个加入的段可以匹配整个串的第一段，如 <span class="math inline">\(abaa\)</span>，最后的那个 <span class="math inline">\(a\)</span> 就需要特判。稍加讨论即可。</p><p>这样就可以直接做了。时空复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个题目的 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 操作代表着需要维护一个可持久化的东西。&lt;/p&gt;
&lt;p&gt;但是因为它没有强制在线，根据常识，可以离线生成一个操作树来降低思考难度。&lt;/p&gt;
&lt;p&gt;不难发现最终的字符串的长度可能会非常长，可以达到 &lt;span class=&quot;math inline&quot;&gt;\(n\cdot x=10^9\)&lt;/span&gt; 级别，这提示我们不能从字符串本身入手。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="可持久化数据结构" scheme="http://example.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="KMP" scheme="http://example.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>简单模拟费用流</title>
    <link href="http://example.com/2020/12/27/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://example.com/2020/12/27/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/</id>
    <published>2020-12-27T13:14:45.000Z</published>
    <updated>2020-12-27T14:06:00.060Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，只要把模建好，什么题都可以用网络流/费用流跑。</p><p>随着这些算法普及度的提高，出题人也就不再局限于单纯的网络流/费用流，而模拟费用流就是其中衍生出来的一个上限很高的算法。</p><p>由于博主水平有限，在此记录一些比较简单的模拟费用流问题和思路。</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，只要把模建好，什么题都可以用网络流/费用流跑。&lt;/p&gt;
&lt;p&gt;随着这些算法普及度的提高，出题人也就不再局限于单纯的网络流/费用流，而模拟费用流就是其中衍生出来的一个上限很高的算法。&lt;/p&gt;
&lt;p&gt;由于博主水平有限，在此记录一些比较简单的模拟费用流问题和思路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="费用流" scheme="http://example.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>NOIP 2020 游记</title>
    <link href="http://example.com/2020/12/02/NOIP-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2020/12/02/NOIP-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-12-02T06:27:43.000Z</published>
    <updated>2020-12-08T14:19:13.655Z</updated>
    
    <content type="html"><![CDATA[<h4 id="day--inf">Day -INF</h4><a id="more"></a><p>已经记不清什么时候的事情了。</p><p>组内进行了分小组出题互测。</p><p>Clamee 出了一道让队爷都拍手称赞的题，还给丢 T3 了。</p><p>自从那一天被 T3 搞自闭开始，T3 就再也没有切过了【悲伤】。</p><h4 id="day--5">Day -5</h4><p>我说 Codeforces 它不讲武德，当时它一个 Div1A，一个 Div1B，一个 Div1C，我全部都切掉了啊。</p><p>切掉之后自然是点到为止，Pretest passed 后就不管了，因为这时按照传统规矩它已经被切了。</p><p>它也承认我是先切了它，但它突然就是一个数据怼上来，我大意了啊，没有特判，直接就给 FST 了。</p><p>它偷袭一个 2000 多分的蒟蒻这好吗？这不好。OI 界要以和为贵，加强 pretest。</p><p>最后掉分了。（</p><h4 id="day--4">Day -4</h4><p>Kewth 给我们出模拟赛了！！！</p><p>开局四个 <span class="math inline">\(998244353\)</span> 当场自闭。</p><p>数学蒟蒻在线惊恐。</p><p>又被 T3 卡了，T4 比 T3 难多了还给切了，我真就 &amp;@#$&amp;%#&amp;。</p><p>又刷了好久知乎，感觉颓死了。</p><p>好羡慕那些 win 啊。</p><h4 id="day--3">Day -3</h4><p>CYJian 给我们出模拟赛了！！！</p><p>感觉一开始状态挺好的，前三题一下就做完了（虽然 T3 假了）。</p><p>结果 T4 不知道抽了什么筋，想到一个换根+树剖+带修主席树的做法，还开始写了。</p><p>写到后面越陷越深，最后 10k 都没写完惨变暴力分。</p><p>在 CYJian 这届，切了 T4 就有 0.667 的概率进国家集训队，而没有切进的概率为 0。</p><p><strong>在此提前恭喜 xiaolilsqs 进队！！！</strong></p><p>Clamee 又改了它出的神仙 T3，不过还好有前车之鉴没有被踩。</p><h4 id="day--2">Day -2</h4><p>Ysu 给组内开了个会。</p><p>自然是考前给大家加信心。（然而考前就要求写退役记）</p><p>他说他在高考之前和喜欢的妹子一起刷了一周题，然后就考上了北航。</p><p>要是我 NOIP 前可以和喜欢的妹子一起刷一周题，那 400 分不手到擒来？！（因为前提无法实现，所以后面的结果就写得奇怪一点）</p><p>又双叒叕开始颓了……还似乎被 Ysu 看到了。</p><p>神游了一段时间之后决定开始搞学。</p><p>写退役记的时候想到了很多往事，下午加晚上就这么过去了。</p><h4 id="day--1">Day -1</h4><p>NOIP 前的最后一次模拟赛。</p><p>tiger0132 会出题的消息不胫而走，在赛前引起了很多人的恐慌。</p><p>最终是 tiger 的两道题拼上另外两题，有一说一，tiger 的题目还是很良心的。毒瘤还是毒瘤在拼的题目上。</p><p>最后 3h AK 了。</p><p>Ysu 说要把这次当 NOIP，NOIP 当考后放松赛（要是 NOIP 能像今天一样就好了）。</p><p>又颓了好一会……后面觉得这样不太行就开始捣鼓 Linux。</p><h4 id="day-0">Day 0</h4><p>被叫出去<strong>爬</strong>（山）了。</p><p>回来之后搞了一次机房团建（雾。</p><p>晚上开了场 Div.2 VP，卡 E 了，感觉药丸。</p><h4 id="day1">Day1</h4><p>Ysu 喝奶茶导致喉咙发炎了（听说被珍珠呛到？？？），心疼 30s。</p><p>早上 5:30 惊醒，看了下表一时间不能确定是五点还是六点，调了一下表盘，看数字表盘发现才 5:30，就躺下打算继续睡。</p><p>结果每 7-8 min 就惊醒一次，浑浑噩噩熬到 6:10 就起床了。</p><p>随便买了些东西当早餐，顺便捎了个薄荷糖防睡觉。</p><p>7:30 到制定地点，7:40+ 就进考场了，下完题目和配置就开始发呆。</p><p>解压密码 <code>1Xuan2Shou0Jia5You</code>，太谢谢 CCF 的祝福了（雾。</p><p>T1 送分，T2 字符串……？想了会发现不是太难。T3 构造，T4 计数。</p><p>似乎又没有数据结构和树据结构……又组些什么阴间题啊……</p><p>1h rush 完 T1,T2，发现 T2 <span class="math inline">\(O(T(27n+n\log n))\)</span> 有亿点点卡常，花了 30min 优化常数后发现还是有点点慢，但是感觉卡下去没有什么意义，就放弃了。</p><p>回头看了一下 T1，突然一下没看到 <span class="math inline">\(d\leq 5\)</span>，然后就 NT 地构造了一种 <span class="math inline">\(10000^{10}\)</span> 的图就卡没了。</p><p>一万头草泥马奔腾而过……后来猛然发现 <span class="math inline">\(d\leq 5\)</span>，再加上之前一直不相信 NOIP 会出这种恶心的高精度 <span class="math inline">\(\gcd\)</span>，然后就直接肝 T3 了。</p><p>想到一种似乎有点优秀的算法，就上手了，中途修修补补了很多下，差不多 12:00 过大样例，写了个随机 generator 就放后台和 SPJ 拍了。</p><p>T4 也直接没管正解，想到一个 <span class="math inline">\(O(\sum_i^kw_i(\log w_i+k))\)</span> 就直接上手了，没有注意一些边界，卡了好久，最后在 12:50 过了大样例，可惜有亿点点慢。</p><p>然后就下考了，感觉考试很匆忙过得及其不真实，下考之后脑子就一片空白了。</p><p>出考场之后感觉大家都说题目难，似乎我的预计得分还比较可观。</p><p>和好基友一起吃了中饭，回学校看洛谷发现 T1 似乎真的要写高精？？？我可 $#%^#&amp;@。</p><p>当然这点点小插曲还是不能挡住我颓的，回家直接上号开干了。</p><h4 id="day3">Day3</h4><p>回归文化课的第一天，文化课还是那么拉胯。</p><p>晚上搞到了自己的程序，测了一下民间数据，90+96+100+60，似乎挺高，好像本省 rk2……？反正还是要被文化课踩。</p><h4 id="day4">Day4</h4><p>真·CCF·成绩出来了，60+92+100+65，这波 T1 是真的阴间了。</p><p>有亿点点怀念停课的时光，被文化课踩得有亿点点难受啊……</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;day--inf&quot;&gt;Day -INF&lt;/h4&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>莫队的奇技淫巧</title>
    <link href="http://example.com/2020/12/02/%E8%8E%AB%E9%98%9F%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>http://example.com/2020/12/02/%E8%8E%AB%E9%98%9F%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</id>
    <published>2020-12-02T03:57:08.000Z</published>
    <updated>2020-12-02T06:20:32.548Z</updated>
    
    <content type="html"><![CDATA[<p>莫队算法是一个很妙的算法，它可以通过对查询离线分块来降低算法复杂度。</p><p>但是仔细分析你会发现，莫队所有的复杂度都是修改左右端点造成的，而查询是 <span class="math inline">\(O(1)\)</span> 的。</p><p>也就是说我们可以在莫队中套一个修改 <span class="math inline">\(O(1)\)</span>，查询 <span class="math inline">\(O(1\sim \sqrt{n})\)</span> 的数据结构，这样总复杂度依旧是 <span class="math inline">\(O(n \sqrt{n})\)</span> 的，但是它却可以做更多的事情。</p><a id="more"></a><blockquote><p>例：有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a_1,a_2...a_n\}\)</span>。<span class="math inline">\(m\)</span> 次询问，每次询问一个区间内最小没有出现过的自然数。</p></blockquote><p>这个题目是洛谷的 P4137。</p><p>这个题的经典做法是主席树或者回滚莫队，我们现在考虑另一种做法。</p><p>先直接上莫队，这样我们是不好维护删除数的操作的。</p><p>考虑在莫队里面套上一个值域分块，修改的时候 <span class="math inline">\(O(1)\)</span> 修改，查询的时候 <span class="math inline">\(O(\sqrt{n})\)</span> 一个块一个块的跳。</p><p>虽然套了一个分块，但是复杂度是加在查询上面的 ，总复杂度仍然是 <span class="math inline">\(O(n\sqrt{n})\)</span> 的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;莫队算法是一个很妙的算法，它可以通过对查询离线分块来降低算法复杂度。&lt;/p&gt;
&lt;p&gt;但是仔细分析你会发现，莫队所有的复杂度都是修改左右端点造成的，而查询是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 的。&lt;/p&gt;
&lt;p&gt;也就是说我们可以在莫队中套一个修改 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;，查询 &lt;span class=&quot;math inline&quot;&gt;\(O(1\sim \sqrt{n})\)&lt;/span&gt; 的数据结构，这样总复杂度依旧是 &lt;span class=&quot;math inline&quot;&gt;\(O(n \sqrt{n})\)&lt;/span&gt; 的，但是它却可以做更多的事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="莫队" scheme="http://example.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="分块" scheme="http://example.com/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列相关</title>
    <link href="http://example.com/2020/11/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2020/11/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/</id>
    <published>2020-11-27T12:36:56.000Z</published>
    <updated>2020-11-27T12:57:02.762Z</updated>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(F\)</span> 是斐波那契数列，其定义是对于 <span class="math inline">\(x\leq 2\)</span>，<span class="math inline">\(F(x)=1\)</span>；对于 <span class="math inline">\(x\geq 3\)</span>，<span class="math inline">\(F(x)=F(x-1)+F(x-2)\)</span>。</p><a id="more"></a><h4 id="gcdfxfyfgcdxy">1. <span class="math inline">\(\gcd(F(x),F(y))=F(gcd(x,y))\)</span> 。</h4><p>一个非常实用的结论。下面考虑证明。</p><h5 id="引理-1fxfytimes-fx-y1fy-1times-fx-y">引理 1：<span class="math inline">\(F(x)=F(y)\times F(x-y+1)+F(y-1)\times F(x-y)\)</span>。</h5><p>        把递推式逐级展开就可以得到这个式子。</p><p>        即 <span class="math inline">\(F(x)=F(x-1)+F(x-2)\Rightarrow F(x)=2F(x-2)+F(x-3)\Rightarrow F(x)=3F(x-3)+2F(x-4)...\)</span></p><h5 id="引理-2gcdfxfx-11">引理 2：<span class="math inline">\(\gcd(F(x),F(x-1))=1\)</span>。</h5><p>        仍然是把递推式展开迭代。</p><p>        即 <span class="math inline">\(\gcd(F(x),F(x-1))=\gcd(F(x-2)+F(x-1), F(x-1))=\gcd(F(x-2),F(x-1))...\)</span>。最后就可以得到 <span class="math inline">\(\gcd(F(2),F(1))\)</span>，这时结果显然是 <span class="math inline">\(1\)</span>。</p><p>有了这两个引理就可以证明上述结论了。</p><p>先假设 <span class="math inline">\(x&gt;y\)</span>，那么 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(y)\times F(x-y+1)+F(y-1)\times F(x-y),F(y))\)</span>。把这个式子套用上述两个引理，就有 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(x-y),F(y))\)</span>。可以发现这就是一个辗转相减的形式，直接套用欧几里得就有 <span class="math inline">\(\gcd(F(x),F(y))=F(\gcd(x,y))\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt; 是斐波那契数列，其定义是对于 &lt;span class=&quot;math inline&quot;&gt;\(x\leq 2\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(F(x)=1\)&lt;/span&gt;；对于 &lt;span class=&quot;math inline&quot;&gt;\(x\geq 3\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(F(x)=F(x-1)+F(x-2)\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数列" scheme="http://example.com/tags/%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线性基的瞎操作</title>
    <link href="http://example.com/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-11T08:03:04.000Z</published>
    <updated>2020-12-02T06:14:41.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查找某个数-x-可以被给出基底-a-如何异或得到">1. 查找某个数 <span class="math inline">\(x\)</span> 可以被给出基底 <span class="math inline">\(A\)</span> 如何异或得到</h4><p>把基底 <span class="math inline">\(A\)</span> 做线性基，并且在线性基的同时维护线性基中每个元素是由基底中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>，那么在查询的时候，把对应位置的 <span class="math inline">\(S\)</span> 也一起异或，就可以得到最终所求。</p><h4 id="把基底-a-的一个数-a_i-与另一个数-x-交换保证交换后基底-a-仍然满足基底的性质">2. 把基底 <span class="math inline">\(A\)</span> 的一个数 <span class="math inline">\(A_i\)</span> 与另一个数 <span class="math inline">\(x\)</span> 交换，保证交换后基底 <span class="math inline">\(A&#39;\)</span> 仍然满足基底的性质</h4><p>同上，在线性基的同时维护线性基中每个元素是由 <span class="math inline">\(A\)</span> 中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>。先查询 <span class="math inline">\(x\)</span> 怎么被 <span class="math inline">\(A\)</span> 表示，因为 <span class="math inline">\(A&#39;\)</span> 依旧满足基底的性质，那么如果用 <span class="math inline">\(A\)</span> 来表示 <span class="math inline">\(x\)</span>，那么 <span class="math inline">\(A_i\)</span> 一定会被用到。所以 <span class="math inline">\(A_i\)</span> 也可以用 <span class="math inline">\(A\)</span> 中的数和 <span class="math inline">\(x\)</span> 一起表示，那么就可以直接交换 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(A_i\)</span>，然后去更新线性基中的每个位置的 <span class="math inline">\(S\)</span> 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;查找某个数-x-可以被给出基底-a-如何异或得到&quot;&gt;1. 查找某个数 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 可以被给出基底 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 如何异或得到&lt;/h4&gt;</summary>
      
    
    
    
    
    <category term="数位" scheme="http://example.com/tags/%E6%95%B0%E4%BD%8D/"/>
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>用二进制模拟 K 进制</title>
    <link href="http://example.com/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/"/>
    <id>http://example.com/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/</id>
    <published>2020-11-11T03:39:21.000Z</published>
    <updated>2020-11-11T08:03:46.096Z</updated>
    
    <content type="html"><![CDATA[<p>被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。</p><a id="more"></a><p>先考虑怎么用二进制模拟三进制。</p><p>用 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s_0,s_1,s_2\)</span> 依次表示某数在三进制下，数位为 <span class="math inline">\(0,1,2\)</span> 的位的集合。</p><p>不难发现 <span class="math inline">\(s_0,s_1,s_2\)</span> 两两无交。</p><p>那么对于两个数的三进制下位运算，就可以通过枚举两数的 <span class="math inline">\(s_0,s_1,s_2\)</span>，得到两数在三进制下数位为 <span class="math inline">\(0,1,2,3,4\)</span> 的位的集合。且这些集合也两两无交。</p><p>之后再通过位运算的定义，把五个集合重新整理成新的 <span class="math inline">\(s_0,s_1,s_2\)</span>。</p><p>复杂度是 <span class="math inline">\(O(9)\)</span> 的（因为需要枚举 <span class="math inline">\(s_0,s_1,s_2\)</span>）。</p><p>类似的，这种做法也可以推广到 K 进制下，复杂度是 <span class="math inline">\(O(K^2)\)</span> 的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数位" scheme="http://example.com/tags/%E6%95%B0%E4%BD%8D/"/>
    
    <category term="进制" scheme="http://example.com/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S2 2020 游记</title>
    <link href="http://example.com/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-11-08T06:06:03.000Z</published>
    <updated>2020-12-02T06:26:21.642Z</updated>
    
    <content type="html"><![CDATA[<h4 id="day--1">Day -1</h4><a id="more"></a><p>考了一场很秀的模拟赛。</p><p>开局看题，发现 T1,T2,T4 都是一眼题，代码难度 T1&lt;T4&lt;T2。于是 rush 完 T1 之后直接肝 T3。</p><p>肝了 1.5h 没肝出来，决定先稳一波 rush 一手 T4，rush 完写对拍的时候监考老师绕到了我的后面。</p><p>“这是第四题吗？”</p><p>“嗯。”</p><p>“这是什么？对拍吗？”</p><p>“嗯。”</p><p>“那你是不是都做完了？”</p><p>“没有，只写了 T1,T4。”</p><p>"哦~"</p><p>似乎这只是一个平平无奇的对话，但不久后监考老师冷不丁来一句：“其实这套题目并不完全是按照难度排序，T3 应该要比 T2 简单。”</p><p>一只南美洲亚马逊河流域热带雨林中的蝴蝶，偶尔扇动几下翅膀，可以在两周以后引起美国得克萨斯州的一场龙卷风。监考老师的一句提醒，也可以引起很多人做题策略的改变。</p><p>我听完之后虽然有点小慌，但是之前就已经止损过了，所以还是稳着先把 T2 写了，最后才去肝 T3。</p><p>但是很多人都因为这一句话，直接硬肝 T3，结果全盘皆崩。</p><p>我们称这个事件为【Y 郎妙计安天下】。</p><h4 id="day-0">Day 0</h4><p>又是一场披着 CSP 皮的毒瘤模拟赛。</p><p>真想拿个仙人掌拍出题人头上让他见识一下什么才是真正的仙人掌。</p><p>不过有一说一，感觉现在码力变强了好多，一开始误认为仙人掌是点不重复，rush 了 4k 多，发现错了之后又重新 ruch 了 4k 多结果还一遍过……</p><p>考前毒奶：因为 CSP 毕竟是合格性考试，所以不会太难，T1,T2 应该都是送分，T3,T4 略难一点。</p><h4 id="day-1">Day 1</h4><p>为了考前不颓废，VP 了一场 CF Div.1。</p><p>Rush 完 A,B 后，发现 C 是一个计算几何，D 是一个比较麻烦的 DP，瞬间失去了写代码的欲望。</p><p>结果剩下的时间差不多都在知乎、2020 US Election、Typeracer、Pokemonshowdown 之间徘徊。<del>考前颓废是 OIER 的传统艺能。</del></p><p>吃完中饭就去考场了。因为自己动作比较憨，上车的时候就只有后排中间的 C 位了，于是就有了名场面【Dan 皇登基】（雾</p><p>考前集体毒奶：早出来一小时就可以多休息一小时，今天下午直接车队走起。</p><p>考试体验依旧很 nice，座位很舒适，键盘很丝滑，配置很体贴。</p><p>但是……题目很毒瘤。</p><p>浏览一遍题目之后直接想自闭离场了。</p><p>打个比方，切题就类似于在山里找宝藏，有些宝藏是藏得很深，需要你依靠自己的能力找到宝藏的位置<del>（宝藏猎人）</del>。而有些宝藏就直接给扔山顶，一眼就看得到，不过如果想得到它就需要花大功夫。</p><p>T1 就是后者，而且山顶还不是普通山的山顶，那是珠穆朗玛峰的山顶。</p><p>硬着头皮肝 T1，40min，一遍过。</p><p>硬着头皮肝 T2，20min，一遍过。</p><p>T3 一开始一点思路都没有，结果就直接想睡觉了……<del>（强烈抗议 CSP-S2 又耽误我睡觉）</del>。</p><p>迷迷糊糊了 30min，状态回暖之后直接把 T4 70 分暴力 rush 了，然后继续肝 T3。</p><p>离下考还有 50min 了时候隐隐约约有了一个算法，然后直接 rush，30 min 写完一遍过样例。</p><p>剩下的时间感觉 T4 优化无望，于是就各种检查。</p><p>预计 100+100+100+70=370，似乎不低的样子。</p><p>考完之后就是颓颓颓！！！</p><h4 id="day-2">Day 2</h4><p>CSP 已经没有 Day 2 了……又要继续为 NOIP 奋斗了。</p><p>测了一下民间数据，T1,T2,T4 100+100+70 稳了，但是 T3 有点点问题。</p><p>后来发现我本质上要维护的是后缀积，但是我的做法是维护整体积除前缀积，然而数据范围是 <span class="math inline">\(0\leq V_j\leq 10^4\)</span>……</p><p>现在我的成绩完全掌握在 T3 出题人的手中了……希望 TA 能大发慈悲，可怜可怜没注意 <span class="math inline">\(V_j=0\)</span> 的孩子吧。</p><h4 id="day-inf">Day INF</h4><p>呐~命运被掌握在别人手中的感觉真是很不好呢。</p><p>最后 100+100+70+70 了，T3 被卡到还不如指数级暴力 <code>(* ￣︿￣)</code>。</p><p>最后当然是 NOIP 2020 RP++。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;day--1&quot;&gt;Day -1&lt;/h4&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>POI2012</title>
    <link href="http://example.com/2020/10/17/POI2012/"/>
    <id>http://example.com/2020/10/17/POI2012/</id>
    <published>2020-10-17T01:34:46.000Z</published>
    <updated>2020-10-17T09:24:56.431Z</updated>
    
    <content type="html"><![CDATA[<p><del>吉老师是我们的红太阳，紧随吉老师的步伐。</del></p><a id="more"></a><h5 id="distance">Distance</h5><p>设 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(x\)</span> 的质因数个数（相同算多个）。</p><p>那么 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的操作数就是 <span class="math inline">\(f(\frac{xy}{\gcd(x,y)^2})\)</span>。</p><p>而不难发现上式等于 <span class="math inline">\(f(x)+f(y)-2f(\gcd(x,y))\)</span>。</p><p>所以对于要求答案的数 <span class="math inline">\(x\)</span>，枚举 <span class="math inline">\(\gcd\)</span> 后就只要看最小的 <span class="math inline">\(f(y)\)</span> 即可，而这个 <span class="math inline">\(y\)</span> 必须是枚举的 <span class="math inline">\(\gcd\)</span> 的倍数，预处理一下即可。</p><h5 id="cloakroom">Cloakroom</h5><p>考虑把询问离线，那么就可以把所有查询归为 <span class="math inline">\(n^2\)</span> 个组。</p><p>对于某个组，直接用 <code>bitset</code> 跑可行性背包。</p><p>复杂度 <span class="math inline">\(O(\frac{n^2k}{w})\)</span>，需要卡常。</p><h5 id="a-horrible-poem">A Horrible Poem</h5><p>把字符串按照块大小为 <span class="math inline">\(1,2...n\)</span> 分块，然后预处理每种分块每个块往前有多少个块和它一样。</p><p>对于一个查询，枚举长度的一个因子，然后查询整块是不是都相等，如果都相等就把散块拼接成一个整块再去判断这个拼接的整块和原来的整块是否相等。</p><p>画图就可以很显然的看出这个性质。</p><p>判断字符串相等直接用哈希。</p><p>需要卡常。</p><h5 id="fibonacci-representation">Fibonacci Representation</h5><p>先把这个数用斐波那契数拆分。</p><p>这么拆分有一个性质——没有相邻的 <span class="math inline">\(1\)</span>。</p><p>减去一个数可以看成是把原数加上一个数，所以现在就是在这个序列上面加减，求变成全 <span class="math inline">\(0\)</span> 的最小次数。需要注意的一个性质就是如果有两个相邻的 <span class="math inline">\(1\)</span> 会自动往后合并。</p><p>从前往后扫，碰到一个 <span class="math inline">\(1\)</span> 后，如果其后面第二位或者第三位有值，就在某个位置加上一个 <span class="math inline">\(1\)</span> 使得可以连锁反应把后面那个 <span class="math inline">\(1\)</span> 也弄掉，否则就直接删掉这个 <span class="math inline">\(1\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;吉老师是我们的红太阳，紧随吉老师的步伐。&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="POI" scheme="http://example.com/tags/POI/"/>
    
  </entry>
  
  <entry>
    <title>UOJ Contests</title>
    <link href="http://example.com/2020/10/14/UOJ-Contests/"/>
    <id>http://example.com/2020/10/14/UOJ-Contests/</id>
    <published>2020-10-14T13:24:06.000Z</published>
    <updated>2020-10-17T09:08:35.069Z</updated>
    
    <content type="html"><![CDATA[<p><del>九条可怜老师</del>吉老师在他的博客中大力赞扬 UR 。</p><p>于是博主就决定慢慢把 UR 补完。</p><p>希望补完之后能有吉老师十分之一的水平。</p><a id="more"></a><h4 id="uoj-easy-round-1">UOJ Easy Round #1</h4><h5 id="a">A</h5><p>最小是 <span class="math inline">\(2\sqrt{n}\)</span>，最大是 <span class="math inline">\(g+l\)</span>。</p><p>用三次根号分治分解 <span class="math inline">\(g,l\)</span>，剩下的要么相等，要么都是完全平方数。</p><h5 id="c">C</h5><p>离线，建操作树，用可撤销并查集求解。</p><p><code>Add</code> 是加一个儿子，<code>Delete</code> 是跳到 <span class="math inline">\(k\)</span> 级父亲，<code>Return</code> 是回到上一步所在位置。</p><p>求父亲类似长链剖分用个数组记录动指针。</p><h4 id="uoj-round-1">UOJ Round #1</h4><h5 id="a-1">A</h5><p>枚举缩进量 <span class="math inline">\(x\)</span>，当前代码量就是 <span class="math inline">\(\sum_{i=1}^n\lfloor\frac{a_i}{x}\rfloor a_i\text{ mod }x\)</span>。</p><p>显然的整数分块。</p><h5 id="b">B</h5><p>把 <span class="math inline">\(x\)</span> 模一个大于 <span class="math inline">\(x\)</span> 的数不会有任何改变。</p><p>故设 <span class="math inline">\(f[i]\)</span> 表示当前的值为 <span class="math inline">\(i\)</span>，所有大于 <span class="math inline">\(i\)</span> 的数都已经放好了的方案数，枚举转移即可。</p><h4 id="uoj-round-2">UOJ Round #2</h4><h5 id="a-2">A</h5><p>从左往右扫，遇到一个不合法的右括号，就往右找第一个左括号交换。</p><p>因为是右边的第一个左括号，所以如果下一次仍然有不合法的右括号，就可以从上次的那个位置开始继续往右找左括号。</p><h5 id="c-1">C</h5><p>先套上简单容斥，<span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(\gcd\)</span> 是 <span class="math inline">\(i\)</span> 的倍数的方案数。</p><p>对树长链剖分，这样就只需要在链合并的时候计算对 <span class="math inline">\(f\)</span> 的贡献。</p><p>朴素的想法维护深度桶，合并枚举 <span class="math inline">\(i\)</span>，直接求当前链的 <span class="math inline">\(i\)</span> 的倍数个数和合并链的 <span class="math inline">\(i\)</span> 的倍数个数。这样复杂度是 <span class="math inline">\(\sum dep\)</span> 的，不太行。</p><p>故考虑根号分治，在加入当前点的时候就直接预处理深度模 <span class="math inline">\(1\sim B\)</span> 等于 <span class="math inline">\(x\)</span> 的数的个数，剩下的同上暴力。</p><p>复杂度比较玄学，<span class="math inline">\(B=50\)</span> 可过。</p><h4 id="uoj-round-3">UOJ Round #3</h4><h5 id="a-3">A</h5><p>不难发现次大公约数就是最大公约数除掉最小质因子。</p><p>而最大公约数一定是 <span class="math inline">\(a[1]\)</span> 的因子。</p><p>预处理出 <span class="math inline">\(a[1]\)</span> 的所有因子之后，对每个 <span class="math inline">\(\gcd\)</span> 判断即可。</p><h4 id="uoj-round-4">UOJ Round #4</h4><h5 id="a-4">A</h5><p>当 <span class="math inline">\(a\geq \sqrt{n}\)</span> 的时候，<span class="math inline">\(b\)</span> 已经没有用了，两人只能操作 <span class="math inline">\(a\)</span>，故可以直接 <span class="math inline">\(O(1)\)</span> 判。</p><p>剩下的部分可以直接 DP。</p><h5 id="b-1">B</h5><p>把当前剩下的 <span class="math inline">\(k\)</span> 平均分配给三个数组（如果某个越界了就匀出来一点给别的），然后分别查询，那么查询值最小的那个一定可以被放进去，否则把它退出来，加入别的，别的一定比它大，就不优。</p><p>所以可以直接这么搞若干次，每次可以确定 <span class="math inline">\(\frac{1}{3}k\)</span> 个数，当 <span class="math inline">\(k\)</span> 足够小的之后就直接暴力即可，可以在次数限制内求得答案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;九条可怜老师&lt;/del&gt;吉老师在他的博客中大力赞扬 UR 。&lt;/p&gt;
&lt;p&gt;于是博主就决定慢慢把 UR 补完。&lt;/p&gt;
&lt;p&gt;希望补完之后能有吉老师十分之一的水平。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UOJ" scheme="http://example.com/tags/UOJ/"/>
    
  </entry>
  
  <entry>
    <title>CSP-S1 2020 游记</title>
    <link href="http://example.com/2020/10/11/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2020/10/11/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/</id>
    <published>2020-10-11T06:04:40.000Z</published>
    <updated>2020-12-02T06:24:35.489Z</updated>
    
    <content type="html"><![CDATA[<h4 id="day-1">Day 1</h4><a id="more"></a><p>今天的状态就一个字：困。</p><p>平时周末这么早还沉醉在<del>温柔乡</del>梦乡的我，坐着校车晃晃悠悠地去了考场。</p><p>天空很蓝，阳光很暖，和兄弟们看着来往的<del>妹子</del>人群，感觉生活无比惬意。</p><p>在见到如此多的小学生、初中生后，感觉自己真的老了<del>教练真就不当人</del>。</p><p>一坐下就想睡觉，越考越想睡，rush 到第三个阅读的时候就感觉整个人都要没了，天人交战了好一会之后才又重新开始从后往前 rush，最后好不容易 rush 完了，结果却睡不着了。<del>（强烈抗议 CSP-S1 耽误我睡觉）</del></p><p>中午众人决定去吃大餐，在兜兜转转之下，选择了某 M 开头的快餐店。</p><p>虽然状态不太好，但是这波还是很稳的，祝愿 CSP-S2 2020 RP++。</p><h4 id="day-inf">Day INF</h4><p>成绩出来了，比预计的高一点点 96pts <code>O(∩_∩)O</code>。</p><p>但是……听说同校的聚聚不仅 AK 初赛，而且月考年级第二（说不定还是位人赢），突然就感觉生活失去希望。</p><p>不过还是祝愿 CSP-S2 2020 RP++。</p><p><del>为了不引起日期恐慌，博主决定把游记分开写</del>。</p><p><a href="">CPS-S2 2020 游记</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;day-1&quot;&gt;Day 1&lt;/h4&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://example.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>划分数</title>
    <link href="http://example.com/2020/10/09/%E5%88%92%E5%88%86%E6%95%B0/"/>
    <id>http://example.com/2020/10/09/%E5%88%92%E5%88%86%E6%95%B0/</id>
    <published>2020-10-09T01:56:22.000Z</published>
    <updated>2020-10-15T01:44:58.111Z</updated>
    
    <content type="html"><![CDATA[<p>划分数就是把一个数 <span class="math inline">\(n\)</span> 拆分成若干个正整数的和的方案数，其中这若干个正整数是无序的，也就是 <span class="math inline">\(\{1,1,2\}\)</span> 和 <span class="math inline">\(\{1,2,1\}\)</span> 是等价的拆分。</p><p>下面我们来讨论怎么求它。</p><a id="more"></a><h5 id="简单-dp">简单 DP</h5><p>我们可以设 <span class="math inline">\(f_{i,j}\)</span> 表示把 <span class="math inline">\(i\)</span> 拆分成 <span class="math inline">\(j\)</span> 个正整数的方案数。</p><p>转移有两种，要么添加一个 <span class="math inline">\(1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p><p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\)</span>。</p><p>那么我们要求的划分数就是 <span class="math inline">\(\sum_{x=0}^n f_{n,x}\)</span>。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><p>这个算法的优点是我们可以知道所有把 <span class="math inline">\(x\leq n\)</span> 拆分成 <span class="math inline">\(y\leq n\)</span> 个正整数的方案数，缺点是复杂度过高。</p><h5 id="根号分治-dp">根号分治 DP</h5><p>可以发现，大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多选 <span class="math inline">\(\sqrt{n}\)</span> 个，所以我们可以依靠这个来优化算法。</p><p>设 <span class="math inline">\(f_{i,j}\)</span> 表示用小于等于 <span class="math inline">\(i\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p><p>转移有两种，要么是多加一个 <span class="math inline">\(i\)</span>，要么就把 <span class="math inline">\(i\)</span> 加 <span class="math inline">\(1\)</span>。</p><p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j}+f_{i,j-i}\)</span>。</p><p>这里的 <span class="math inline">\(i\)</span> 我们只枚举到 <span class="math inline">\(\sqrt{n}\)</span>，这样我们就可以知道用小于等于 <span class="math inline">\(\sqrt{n}\)</span> 拼成某个数的方案数。</p><p>设 <span class="math inline">\(g_{i,j}\)</span> 表示用 <span class="math inline">\(i\)</span> 个数大于 <span class="math inline">\(\sqrt{n}\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p><p>转移有两种，要么添加一个 <span class="math inline">\(\sqrt{n}+1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p><p>即 <span class="math inline">\(g_{i,j}=g_{i-1,j-\sqrt{n}-1}+g_{i,j-i}\)</span>。</p><p>因为大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多用 <span class="math inline">\(\sqrt{n}\)</span> 个，所以 <span class="math inline">\(i\)</span> 的上限也是 <span class="math inline">\(\sqrt{n}\)</span>。</p><p>那么最后的答案就是 <span class="math inline">\(\sum_{x=0}^n f_{\sqrt{n},x}\times \left(\sum_{y=0}^{\sqrt{n}} g_{y,n-x}\right)\)</span> 。即枚举小于等于 <span class="math inline">\(\sqrt{n}\)</span> 的数的和。复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p><p>这个算法的优点是比多项式做法容易，且复杂度优于简单 DP。缺点是我们只能求得 <span class="math inline">\(n\)</span> 的划分数。</p><h5 id="多项式">多项式</h5><p>我们可以类似背包的来构造生成函数。</p><p>设 <span class="math inline">\(P\)</span> 为划分数的生成函数，即 <span class="math inline">\(P_k\)</span> 的系数为 <span class="math inline">\(k\)</span> 的划分数。</p><p>那么就有 <span class="math inline">\(P=\prod_j^\infty\left(\sum_i a_ix^{ij}\right)\)</span>。</p><p>即枚举选择的数的大小 <span class="math inline">\(j\)</span>，然后乘上它的生成函数。</p><p>根据常识，原式等于 <span class="math inline">\(\prod_{j=1}^\infty \frac{1}{1-x^j}\)</span>。</p><p>然后通过 <span class="math inline">\(\ln\)</span> 和 <span class="math inline">\(\exp\)</span> 化乘为加，就可以求得 <span class="math inline">\(P\)</span>。</p><p>我们先不看 <span class="math inline">\(\exp\)</span>，先算 <span class="math inline">\(\ln\)</span>。那么原式就是 <span class="math inline">\(-\sum_{j=1}^\infty\ln(1-x^j)\)</span>。</p><p>考虑怎么计算 <span class="math inline">\(\ln(1-x^j)\)</span>，换个元设 <span class="math inline">\(u=x^j\)</span>，我们就需要求 <span class="math inline">\(\ln(1-u)\)</span>。</p><p>先求导，即 <span class="math inline">\(-\frac{1}{1-u}=-\sum_{i=0}^\infty u^i\)</span>，然后积分，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{u^i}{i}\)</span> 。把元换回来，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p><p>那么原式就成了 <span class="math inline">\(\sum_{j=1}^\infty \sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p><p>最后把这一坨 <span class="math inline">\(\exp\)</span> 一下就得到了 <span class="math inline">\(P\)</span>。</p><p>不难发现当上界为 <span class="math inline">\(n\)</span> 的时候，这个求和的复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。</p><p>而求 <span class="math inline">\(\exp\)</span> 的复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的，故总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p><p>这个算法的优点是能非常快的计算出 <span class="math inline">\(x\leq n\)</span> 的划分数，缺点是很复杂，且对模数有要求。</p><hr /><p>至此就讨论完了三种求划分数的方法。但是如果你认为这就完了那就 <code>too young too simple, sometimes naive</code> 了，出题人怎么可能就只考裸的划分数呢。</p><p>下面我们再讨论一下如果限制了划分出来的正整数个数，或者限制了划分出来的正整数的大小该怎么做。</p><p>我们可以发现，上述算法的【简单 DP】是很好处理前者的，【多项式】是很好处理后者的，而【根号分治 DP】中的 <span class="math inline">\(f\)</span> 可以维护后者， <span class="math inline">\(g\)</span> 可以维护前者，合并都不好维护。但是回顾上述算法，你会发现它们在最根本的思想上是相似的，而它们在这方面的性质又不一样，这就促使了我们去探究上面两个限制的关系。</p><p><strong>引理：把划分出来的正整数排序，并形成一个阶梯图，这个图在行列上具有对偶性。</strong></p><p>这么说比较抽象，我也不知道表达对不对，但是看了下面的图就知道了。（只看加粗部分）</p><p><img src="https://s1.ax1x.com/2020/10/09/0DFNCV.png" /></p><p>这张图不管是以列划分（左），还是以行划分（右），都可以看做是一个划分数的划分，且它们一一对应。</p><p>假设柱状物的个数为数的个数，柱状物的高度是数的大小。</p><p>那么如果限制是划分出来的正整数个数不超过数 <span class="math inline">\(x\)</span> ，在左图相当于是柱状物的个数不超过 <span class="math inline">\(x\)</span>，那么在右图就是柱状物的高度不超过 <span class="math inline">\(x\)</span>。</p><p>也就是说，限制划分出来的正整数个数不超过 <span class="math inline">\(x\)</span>，和限制划分出来的正整数的大小不大于 <span class="math inline">\(x\)</span> 在本质上是相同的。我们可以对它们进行等价的转化。</p><p>这样就可以解释为何上述三个同根的算法性质不同了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;划分数就是把一个数 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 拆分成若干个正整数的和的方案数，其中这若干个正整数是无序的，也就是 &lt;span class=&quot;math inline&quot;&gt;\(\{1,1,2\}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\{1,2,1\}\)&lt;/span&gt; 是等价的拆分。&lt;/p&gt;
&lt;p&gt;下面我们来讨论怎么求它。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="多项式" scheme="http://example.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总结</title>
    <link href="http://example.com/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-07T01:15:54.000Z</published>
    <updated>2020-10-11T08:06:21.178Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构的一些小 trick。</p><a id="more"></a><h3 id="并查集">并查集</h3><h4 id="支持撤销">支持撤销</h4><p>每次合并的时候按照集合的大小进行启发式合并，并且用一个操作栈记录本次操作。</p><p>在撤销一次操作的时候，只需要按照记录还原并查集即可。</p><p>合并查询操作单次 <span class="math inline">\(O(\log n)\)</span>，撤销操作单次 <span class="math inline">\(O(1)\)</span>。这种并查集在一些离线算法下有大用处。</p><h4 id="维护不可逆的覆盖操作">维护不可逆的覆盖操作</h4><p>考虑这么一道题目：给一棵 <span class="math inline">\(n\)</span> 个点的树，有 <span class="math inline">\(m\)</span> 次操作，每次操作会把一条路径上的点染色，且颜色会覆盖之前染的颜色，求最后每个点的颜色，不强制在线。<span class="math inline">\(n\leq 10^6,m\leq 5\times 10^6\)</span>。</p><p>一种 naive 的思想是用树链剖分和线段树维护颜色，但是这样是 <span class="math inline">\(m\log^2 n\)</span> 的。</p><p>考虑把操作倒序，那么每次执行的是不可逆的染色操作。</p><p>对每个点维护并查集，表示它到根路径上第一个需要被染色的点是什么，一开始显然指向自己。</p><p>如果一个点被染色了，那么就把它的边连向它父亲。每次染色就直接按照并查集的链接暴力跳，然后染色即可。</p><p>因为每个点最多被染色一次，在并查集使用 <span class="math inline">\(n\alpha(n)\)</span> 复杂度的版本下，总复杂度仅为 <span class="math inline">\(O(n\alpha(n))\)</span>。</p><p>这个 trick 虽然可能不会单独成题，但是可能会被穿插到一些题目中。它对复杂度的优化还是挺大的。</p><h3 id="栈">栈</h3><h4 id="对顶栈">对顶栈</h4><p>例题：你需要动态维护一个长度为 <span class="math inline">\(n\)</span> 序列，有 <span class="math inline">\(q\)</span> 个操作，每个操作为头尾加删元素或查询一些信息。</p><p>假设只能从尾部加删，那么我们就可以维护一个类似于栈的东西，每次加进来一个就把它压入栈，并更新一些信息，删掉一个就把它从栈弹掉，并把信息复原。</p><p>现在我们两头都要支持加删，一种直接的想法是维护两个栈，并且把它们的栈底顶到一起，这样头尾加删和普通的加删就没有什么区别，只有查询的时候需要额外计算跨过两个栈的贡献。</p><p>但是这样会出现一个问题，可能有一次删除会把一个栈的栈底给删了，这样原先的结构就被破坏了，这是很麻烦的。但实际上只需要再从序列中间开始，重新构造两个栈就可以了，这样总的重新构造的点的数目的上限是 <span class="math inline">\(\max(n,q)\)</span> 的。</p><p>因为维护了这两个栈的顶着的，所以我们称它为对顶栈。</p><p>好像这种套路就能干这一件事情，博主也就在某次考试中遇到了一次，不过了解一下它的思想总是好的。</p><h4 id="栈-1">2048 栈</h4><p>因为没得名字，随手取了一个。（侵删）</p><p>当你需要动态维护一个不好加入元素的东西的时候（如 AC 自动机、凸包等），你就可以用这个 trick，花费额外的一个 <span class="math inline">\(\log\)</span> 的代价去较为方便的维护它。</p><p>这里就用 AC 自动机举例。</p><p>维护一个栈，每个栈内的元素都是一个 AC 自动机，并且记录下 AC 自动机内的字符串数目。</p><p>对于一次加入，就在栈顶加入一个新的 AC 自动机，内部保存这一次加入的这一个字符串。</p><p>如果此时栈顶的两个 AC 自动机内的字符串数目相同，就把这两个 AC 自动机合并，并且建出一个新的 AC 自动机，一直这样直到栈顶的两个 AC 自动机不满足这个条件。</p><p>不难发现，每次更新栈的时候，AC 自动机的大小就像 2048 一样，相同即合并，且都是 <span class="math inline">\(2\)</span> 的倍数。故每个字符串只会在它所在的 AC 自动机的大小为 <span class="math inline">\(2^k\)</span> 的时候有一个贡献，所以总复杂度是总长度乘上 <span class="math inline">\(\log\)</span> 字符串个数的。</p><p>特别的，这个 trick 是可以在线维护的。</p><p>boshi 提供了一个题目 <a href="https://www.luogu.com.cn/problem/CF710F">CF710F</a> 。</p><h3 id="线段树">线段树</h3><h4 id="时间和序列的对调">时间和序列的对调</h4><p>一般线段树都是维护的序列信息，如区间和，区间积。</p><p>但是在某些问题中，它的操作是区间修改，查询是单点查询，这时候就有一个对调时间和序列的 trick 。</p><p>正如 trick 的名字，我们把时间和序列对调，每次一步一步地在序列上面走，同时对时间维护线段树。</p><p>那么对于对调前的区间修改，现在就变成了两个单点的修改，对于对调前的查询，现在就变成了一个前缀的查询。</p><p>在某些方便不维护前者，而较方便维护后者的题目中，这个 trick 是非常实用的。</p><p>比如说 <a href="http://172.16.11.217:5283/problem/170">某场公开的考试题</a>。</p><h4 id="懒信息">懒信息</h4><p>也是随手取的名字，其实这个 trick 挺常见的。（侵删）</p><p>懒标记是不下传的标记，懒信息就是查询的时候不合并的信息。</p><p>在一些题目中，对于查询操作，如果各个区间的信息是独立的（也就是说并不需要把区间信息合并就可以得到答案），且合并区间信息的复杂度远大于通过单个区间的信息得到答案的复杂度，就可以把信息懒化。</p><p>例题：维护一个序列，支持两个操作：往后面加一个数，查询 <span class="math inline">\(x\)</span> 在区间 <span class="math inline">\([l,r]\)</span> 的排名，操作数 <span class="math inline">\(\leq 10^5\)</span>，保证查询的时候序列长度大于等于 <span class="math inline">\(r\)</span>，强制在线。</p><p>先设操作数为 <span class="math inline">\(n\)</span>，序列可能有 <span class="math inline">\(n\)</span> 这么长，所以先开一个长度为 <span class="math inline">\(n\)</span> 的线段树。</p><p>每个点维护一个有序的序列，表示它控制区间内的数排序之后的结果。</p><p>不难发现每层最多 <span class="math inline">\(n\)</span> 个数，一共 <span class="math inline">\(\log n\)</span> 层，所以空间复杂度 <span class="math inline">\(n \log n\)</span>。</p><p>对于每次往后面加数，就把对应位置的数进行更改，并且往上更新，更新的规则是这样的：如果一个点的儿子是满的，那么就更新它，否则就不更新它。</p><p>更新的时候可以使用归并排序，复杂度是 <span class="math inline">\(O(len)\)</span> 的，因为更新的规则，每个点只会被更新一次，复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的。</p><p>对于查询，naive 的方法是把查询定位到的区间归并，然后看 <span class="math inline">\(x\)</span> 的排名，这样复杂度又回去了。</p><p>因为 <span class="math inline">\(x\)</span> 的排名就是 <span class="math inline">\(x\)</span> 前面有多少个数，所以我们没必要把查询定位到的区间合并，直接在每个定位到的区间内查询有多少个数小于 <span class="math inline">\(x\)</span> 即可。使用二分复杂度就是 <span class="math inline">\(O(n\log^2 n)\)</span>。</p><p>更加复杂一点的还有 <a href="https://uoj.ac/problem/46">UOJ #46</a>。</p><h3 id="平衡树">平衡树</h3><h4 id="替罪羊树">替罪羊树</h4><p>trick 不是这个数据结构，而是它拍扁重构的思想。</p><p>如果你要动态维护一棵树，而且想要让它尽量的平衡（树高在 <span class="math inline">\(O(\log)\)</span> 级别），那么就可以通过控制平衡因子拍扁重构。</p><p>比较经典的是动态加点，动态维护点分树。因为点分树如果要保证复杂度，需要树高在 <span class="math inline">\(O(\log)\)</span> 级别，而动态加点并不好维护。那么我们就干脆在每次加点的时候，就把这个点看做一个子分治中心，并连向父亲。然后像替罪羊一样，如果某个子树太难看了，就直接拍扁重建。</p><p>比较经典的莫过于 <a href="https://www.luogu.com.cn/problem/P3920">[WC2014]紫荆花之恋</a> 了。</p><h3 id="根号算法">根号算法</h3><h4 id="根号分治">根号分治</h4><p>应该是一个比较普及的 trick。</p><p>差不多就是小于根号的暴力也无所谓，大于根号的也就根号个东西。</p><p>比如出现次数大于根号的数不超过根号个，图中度数大于根号的点不超过根号个等。</p><p>这个 trick 比较简单，但是也容易被忽视，注意一下就可以了。</p><p>这方面的话可能比较简单，<a href="https://www.luogu.com.cn/problem/P3396">哈希冲突</a> 是一个比较好的例子。</p><h4 id="时间分块">时间分块</h4><p>似乎对时间轴操作的 trick 都挺重要的。</p><p>如标题所说，就是把所有的操作按照时间分块，那么在块的内部就有一个很好的性质：时间线的变动量不超过块大小。所以就可以在块内按照其它东西排序，对于询问就只需要动时间线，可能会更加方便。</p><p>比如说 <a href="https://www.luogu.com.cn/problem/P5443">[APIO2019]桥梁</a>。</p><p>当然，一些其它的题目也可以用这个思想，可以把时间线的变动看做是别的东西的变动，比如 <a href="https://www.luogu.com.cn/problem/P3247">[HNOI2016]最小公倍数</a>。</p><h4 id="操作分块定期重构">操作分块（定期重构）</h4><p>也是一个比较妙的 trick。</p><p>在一些题目中，如果操作不好应用于序列，且很多个操作可以放一起修改序列，且操作对查询的影响比较好求，就可以用这个 trick。</p><p>这个 trick 的意思是先把所有的操作屯着，查询的时候可以先在原序列查，然后再去屯着的操作里面查。当屯着的操作达到一个上限的时候，就把它们一起放出来，把整个序列翻新一次。</p><p>这个 trick 也不常见，不过其思想也十分有意义。</p><h3 id="其它">其它</h3><h4 id="树的坐标表示">树的坐标表示</h4><p>其实也不是什么高科技，也就标题唬人。</p><p>把树上每个点的坐标看做是 <span class="math inline">\((dfn,dep)\)</span>。</p><p>这样的话，一个子树就代表着一个只有左右边界上下无界的矩形，子树内离当前点距离为某个范围内的点就对应着一个矩形，我们就可以把树上问题转化成二维平面上问题。</p><p><a href="https://ac.nowcoder.com/acm/contest/6944/C">这道题</a> 是个不错的例子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构的一些小 trick。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>diary</title>
    <link href="http://example.com/2020/10/06/diary/"/>
    <id>http://example.com/2020/10/06/diary/</id>
    <published>2020-10-06T07:34:39.000Z</published>
    <updated>2020-10-21T08:28:57.874Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="用魔法咒语解开它吧。" /><label>用魔法咒语解开它吧。</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5489929edd011c760b878f4951bc1063b894e9da73884962b54414abc098b0df">d760a8545d0b399d6f7b4615394ac9fb</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这篇博客被邪恶的博主用魔法封住了。</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛 70 E 题解</title>
    <link href="http://example.com/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/</id>
    <published>2020-09-29T06:59:08.000Z</published>
    <updated>2020-09-29T07:28:41.621Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7509/E">题目链接</a></p><p><strong>题意简述</strong></p><p>定义若二元组 <span class="math inline">\((a,b)&lt;(c,d)\)</span>，则有 <span class="math inline">\(a&gt;c\)</span> 或者 <span class="math inline">\(a=c \text{ and } b&lt;d\)</span>。</p><p>给你 <span class="math inline">\(n\)</span> 个数，第 <span class="math inline">\(i\)</span> 个数是 <span class="math inline">\(a_i\)</span>。</p><p>现在系统会生成 <span class="math inline">\(n\)</span> 个二元组，第 <span class="math inline">\(i\)</span> 个二元组是 <span class="math inline">\((a_i,i)\)</span> 或者是 <span class="math inline">\((a_i+1,i)\)</span>，然后给每个二元组一个排名，设排名数列为 <span class="math inline">\(rk\)</span>。</p><p>求有多少种不同的 <span class="math inline">\(rk\)</span> 数列，两个 <span class="math inline">\(rk\)</span> 序列不同当且仅当存在至少一个位置 <span class="math inline">\(x\)</span>，使得两个 <span class="math inline">\(rk\)</span> 数列的 <span class="math inline">\(rk_x\)</span> 不同。</p><p><span class="math inline">\(n\leq 5\times 10^5,a_i\leq 10^6\)</span>，时空限制：2s 256M。</p><a id="more"></a><p><strong>样例</strong></p><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>解释：有以下八种二元组的搭配方式，以及其相应的 <span class="math inline">\(rk\)</span> 序列。</p><p><span class="math inline">\((1,1),(2,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((1,1),(2,2),(3,3)\ \ \ \ rk:3,2,1\)</span></p><p><span class="math inline">\((1,1),(3,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((1,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p><p><span class="math inline">\((2,1),(2,2),(2,3)\ \ \ \ rk:1,2,3\)</span></p><p><span class="math inline">\((2,1),(2,2),(3,3)\ \ \ \ rk:2,3,1\)</span></p><p><span class="math inline">\((2,1),(3,2),(2,3)\ \ \ \ rk:2,1,3\)</span></p><p><span class="math inline">\((2,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p><p>不同的 <span class="math inline">\(rk\)</span> 序列一共有 <span class="math inline">\(5\)</span> 个。</p><p><strong>题解</strong></p><p>比赛的时候一直认为是一个组合数学题目，没想到是一个 DP。</p><p>先下一个定义：若两个由前 <span class="math inline">\(i-1\)</span> 个二元组形成的序列，无论 <span class="math inline">\([i,n]\)</span> 中的每个二元组是 <span class="math inline">\((a_x,x)\)</span> 还是 <span class="math inline">\((a_x+1,x)\)</span>，这两个序列最终形成的排名序列都是相同的，那么我们把它们称作<strong>不可区分</strong>的。</p><p>首先把所有二元组按照 <span class="math inline">\((a_i,i)\)</span> 排序。为了方便，下文默认输入就已经保证了 <span class="math inline">\((a_i,i)&lt;(a_{i+1},i+1)\)</span>。</p><p>考虑 DP，设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i-1\)</span> 个二元组组成的<strong>可区分</strong>的序列个数。</p><p>那么第 <span class="math inline">\(i\)</span> 个位置既可以放 <span class="math inline">\((a_i,i)\)</span> 也可以放 <span class="math inline">\((a_i+1,i)\)</span>，所以有 <span class="math inline">\(f_{i+1}=2f_i\)</span>，但是这样显然会算重，所以考虑容斥。</p><p>考虑对于一个位置 <span class="math inline">\(i\)</span>，找到一个极短的区间 <span class="math inline">\([l,r](l\leq i\leq r)\)</span>，它需要满足存在一种在 <span class="math inline">\([l,i-1],[i+1,r]\)</span> 放置二元组的方案，使得第 <span class="math inline">\(i\)</span> 个位置放 <span class="math inline">\((a_i,i)\)</span> 和放 <span class="math inline">\((a_i+1,i)\)</span> 是<strong>不可区分</strong>的。这样的话，这种放置方法的贡献本来只有 <span class="math inline">\(1\)</span> 但是被算了两次，所以 <span class="math inline">\(f_r\)</span> 就需要减去 <span class="math inline">\(f_l\)</span>。</p><p>因为这个区间是极短的，所以可以恰好不重不漏地把所有的不合法的方案都减掉，最终的 <span class="math inline">\(f_{n+1}\)</span> 即为答案。</p><p>不难发现，因为我们一开始排好了序，所以 <span class="math inline">\(l,r\)</span> 是单调递增的，<span class="math inline">\(i\)</span> 也是我们单调枚举的，所以 DP 的总复杂度是 <span class="math inline">\(O(n)\)</span> 的。（有趣的是，复杂度的瓶颈在于排序）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, id;</span><br><span class="line">  Node (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _id = <span class="number">0</span>) &#123; x = _x, id = _id; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x ^ A.x ? x &gt; A.x : id &lt; A.id; &#125;;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; read(n);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(a[i].x), a[i].id = i;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; i &amp;&amp; (Node(a[l].x, a[l].id) &lt; Node(a[i].x + <span class="number">1</span>, a[i].id))) ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; (Node(a[r].x + <span class="number">1</span>, a[r].id) &lt; Node(a[i].x, a[i].id))) ++r;</span><br><span class="line">    f[r] = (f[r] + mod - f[l]) % mod;</span><br><span class="line">    f[i + <span class="number">1</span>] = ((f[i] + f[i]) % mod + f[i + <span class="number">1</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  print(f[n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/7509/E&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意简述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义若二元组 &lt;span class=&quot;math inline&quot;&gt;\((a,b)&amp;lt;(c,d)\)&lt;/span&gt;，则有 &lt;span class=&quot;math inline&quot;&gt;\(a&amp;gt;c\)&lt;/span&gt; 或者 &lt;span class=&quot;math inline&quot;&gt;\(a=c \text{ and } b&amp;lt;d\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;给你 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个数，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数是 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;现在系统会生成 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个二元组，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个二元组是 &lt;span class=&quot;math inline&quot;&gt;\((a_i,i)\)&lt;/span&gt; 或者是 &lt;span class=&quot;math inline&quot;&gt;\((a_i+1,i)\)&lt;/span&gt;，然后给每个二元组一个排名，设排名数列为 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;求有多少种不同的 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 数列，两个 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 序列不同当且仅当存在至少一个位置 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，使得两个 &lt;span class=&quot;math inline&quot;&gt;\(rk\)&lt;/span&gt; 数列的 &lt;span class=&quot;math inline&quot;&gt;\(rk_x\)&lt;/span&gt; 不同。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\leq 5\times 10^5,a_i\leq 10^6\)&lt;/span&gt;，时空限制：2s 256M。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
    <category term="容斥" scheme="http://example.com/tags/%E5%AE%B9%E6%96%A5/"/>
    
    <category term="妙题" scheme="http://example.com/tags/%E5%A6%99%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线性代数优化矩阵快速幂</title>
    <link href="http://example.com/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>http://example.com/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-09-26T07:23:28.000Z</published>
    <updated>2020-10-06T10:49:19.832Z</updated>
    
    <content type="html"><![CDATA[<p>如果我们需要求维度为 <span class="math inline">\(c\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 次幂，那么一个显然的方法是用快速幂，复杂度为 <span class="math inline">\(c^3 \log m\)</span>。不过当需要用到高精度的时候，该算法速度会大大下降。</p><p>考虑这么一个事情，<a id="more"></a> 如果可以找到一个矩阵 <span class="math inline">\(C\)</span> 和一个对角矩阵 <span class="math inline">\(P\)</span>（只有主对角线上的值不为 <span class="math inline">\(0\)</span>），使得 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>，那么 <span class="math inline">\(A^m=C\times P \times C^{-1} \times C \times P \times C^{-1}...\)</span>，不断的使用结合率，就可以得到 <span class="math inline">\(C \times P^m \times C^{-1}\)</span>。因为 <span class="math inline">\(P\)</span> 是对角矩阵，那么 <span class="math inline">\(P^m\)</span> 本质上只要对 <span class="math inline">\(P\)</span> 中的每个值跑一个实数的快速幂。这样就可以把复杂度优化到 <span class="math inline">\(c^3+c\log n\)</span>，即实数的快速幂和两次矩阵乘法。</p><p>现在的问题就是怎么得到一个合法的 <span class="math inline">\(C\)</span>。</p><p>引入两个概念：特征值和特征向量。</p><p>一个数 <span class="math inline">\(\lambda\)</span> 是矩阵 <span class="math inline">\(A\)</span> 的特征值，当且仅当存在一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>，使得 <span class="math inline">\(A\times B=\lambda B\)</span>，我们把这个向量 <span class="math inline">\(B\)</span> 称作特征向量。需要注意的是，对于同一个 <span class="math inline">\(\lambda\)</span>，<span class="math inline">\(B\)</span> 可能不止一个。</p><p>如果我们求出了一组特征值 <span class="math inline">\(\lambda_1,\lambda_2...\lambda_c\)</span>，以及对应的特征向量 <span class="math inline">\(B_1,B_2...B_c\)</span>，那么就有 <span class="math inline">\(A\times [B_1,B_2...B_c]=[\lambda_1\cdot B_1,\lambda_2\cdot B_2...\lambda_c\cdot B_c]\)</span>，设 <span class="math inline">\(C=[B_1,B_2...B_c]\)</span>，右乘一个对角矩阵相当于每一列 <span class="math inline">\(i\)</span> 乘上一个对角阵中的元素 <span class="math inline">\(a_{i,i}\)</span>，所以可以构造对角矩阵 <span class="math inline">\(P=\begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots&amp;0\\ 0 &amp; \lambda_2 &amp; \cdots&amp;0\\ \vdots &amp; \vdots&amp;\ddots&amp;\vdots \\ 0&amp;\cdots&amp;0&amp;\lambda_c\end{bmatrix}\)</span>，就可以得到 <span class="math inline">\(A\times C=C\times P\Leftrightarrow A=C\times P\times C^{-1}\)</span> 。</p><p>考虑怎么求特征值，因为 <span class="math inline">\(A\times B=\lambda B\)</span> 那么就有 <span class="math inline">\(\lambda B-A\times B=0\)</span>，所以 <span class="math inline">\((\lambda I-A)\times B=0\)</span>，因为 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span>，所以必须有 <span class="math inline">\(\det(\lambda I-A)=0\)</span>，那么可以通过行列式列方程求得 <span class="math inline">\(\lambda\)</span>。</p><p>考虑使用反证法证明 <span class="math inline">\(\det(\lambda I-A)=0\)</span>。设 <span class="math inline">\(G=\lambda I-A\)</span>，那么如果 <span class="math inline">\(\det(G)\not=0\)</span>，那么如果把 <span class="math inline">\(G\)</span> 看作是一个方程组的系数矩阵，<span class="math inline">\(B\)</span> 为未知数，那么 <span class="math inline">\(B\)</span> 将会是唯一的。而因为等式右边等于 <span class="math inline">\(0\)</span> ，所以无论如何用高斯消元，最后总会有 <span class="math inline">\(B_c=0\)</span>，那么一直往回迭代就会得到一个全 <span class="math inline">\(0\)</span> 向量，与 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span> 冲突。而如果 <span class="math inline">\(det(G)=0\)</span>，那么 <span class="math inline">\(G\)</span> 至少有一个自由元，那么就可以通过自由元，得到至少一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>。</p><p>由此我们就可以求出所有的特征值，对于某个特征值，把它带回矩阵，通过初等矩阵的行变换把它变成一个最简形式，然后把自由元带入任意一个值（一般为 <span class="math inline">\(1\)</span>）就可以得到一个特征向量 <span class="math inline">\(B\)</span>（当然对于任意的 <span class="math inline">\(k\cdot B,k\not=0\)</span> 都是符合要求的）。</p><p>至此就可以得到所有的特征值及其对应的特征向量。那么就可以得到矩阵 <span class="math inline">\(C\)</span>，求个逆就可以得到 <span class="math inline">\(C^{-1}\)</span>（消元可以用辗转相除法，就可以避免求逆元），就可以用上述做法优化了。</p><p>下面就举个栗子，用此方法得到斐波那契数列的通项公式。</p><p>众所周知，斐波那契数列的递推矩阵是 <span class="math inline">\(A=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\ \end{bmatrix}\)</span> 。</p><p>先求出该矩阵的特征值，设其为 <span class="math inline">\(\lambda\)</span>，根据定义，有 <span class="math inline">\(\det \left ( \begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \right) = 0\)</span> ，所以 <span class="math inline">\((\lambda-1)\times \lambda-1=0\)</span>，解出 <span class="math inline">\(\lambda=\frac{1\pm\sqrt{5}}{2}\)</span> 。</p><p>再根据定理，列出方程 <span class="math inline">\(\begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ \end{bmatrix}=\begin{bmatrix} 0 \\ 0 \\ \end{bmatrix}\)</span> 可以解出两个特征向量 <span class="math inline">\(\lambda_1=\frac{1-\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_1=\begin{bmatrix} 1 \\ \frac{-1-\sqrt{5}}{2} \\ \end{bmatrix}\)</span>，<span class="math inline">\(\lambda_2=\frac{1+\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_2=\begin{bmatrix} 1 \\ \frac{-1+\sqrt{5}}{2} \\ \end{bmatrix}\)</span> 。那么根据定义，设 <span class="math inline">\(C=[B_1,B_2]\)</span>，构造对角阵 $P=\begin{bmatrix} _1 &amp; 0 \ 0 &amp; _2 \ \end{bmatrix} $，就可以得到 <span class="math inline">\(A\times C=C\times P\)</span>，所以有 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>。故 <span class="math inline">\(A^m=C\times P^m \times C^{-1}\)</span>。</p><p>通过手算可以求得 <span class="math inline">\(C^{-1}= \begin{bmatrix} 1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; -\frac{\sqrt{5}}{5} \\ \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; \frac{\sqrt{5}}{5} \\ \end{bmatrix}\)</span>。</p><p>对于斐波那契数列第 <span class="math inline">\(m\)</span> 项，即是 <span class="math inline">\(A^m\)</span> 的 <span class="math inline">\(a_{1,1}\)</span>。显然 <span class="math inline">\(P^m=\begin{bmatrix} (\frac{1-\sqrt{5}}{2})^m &amp; 0 \\ 0 &amp; (\frac{1+\sqrt{5}}{2})^m \ \end{bmatrix}\)</span> ，那么 <span class="math inline">\(C\times P^m \times C^{-1}\)</span> 的 <span class="math inline">\(a_{1,1}\)</span> 为 <span class="math inline">\((\frac{1-\sqrt{5}}{2})^m\times(1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5})+(\frac{1+\sqrt{5}}{2})^m\times \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5}\)</span>，整理之后就为 <span class="math inline">\(\frac{1}{\sqrt{5}}\left((\frac{1+\sqrt{5}}{2})^{m+1}-(\frac{1-\sqrt{5}}{2})^{m+1}\right)\)</span> ，即为斐波那契数列的通项公式。</p><p>因为出现了根号，所以整个过程看似比较麻烦，不过在递推矩阵满足一些性质的时候有较快的方法求特征值和特征向量（比如在整个矩阵是一个上/下三角矩阵时，特征值就是主对角线上的值，自由元就是项数变少了某行，设它为 <span class="math inline">\(1\)</span>，就可以在矩阵大小的复杂度内求得一个特征向量）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果我们需要求维度为 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的矩阵 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次幂，那么一个显然的方法是用快速幂，复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(c^3 \log m\)&lt;/span&gt;。不过当需要用到高精度的时候，该算法速度会大大下降。&lt;/p&gt;
&lt;p&gt;考虑这么一个事情，</summary>
    
    
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>PAM 学习笔记</title>
    <link href="http://example.com/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-26T07:20:06.000Z</published>
    <updated>2020-09-26T07:20:37.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义">定义</h4><p>PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。</p><p>PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。</p><a id="more"></a><table><thead><tr class="header"><th style="text-align: left;"></th><th>AC 自动机</th><th>PAM</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">点         </td><td>一个前缀</td><td>一个回文串</td></tr><tr class="even"><td style="text-align: left;">转移边</td><td>从起点走到终点，相当于在起点的字符串后面加上一个字符</td><td>从起点走到终点，相当于在起点的字符串两侧都加上一个字符</td></tr><tr class="odd"><td style="text-align: left;">fail 边</td><td>存在的最长后缀</td><td>存在的最长回文后缀</td></tr></tbody></table><p>但是，PAM 有一个 AC 自动机不具有的性质——它有两个根！因为可以发现走转移边并不会改变回文串长度的奇偶性，这样的话就保存不了所有的回文串了，所以我们需要两个根，一个叫做奇根，还有一个叫做偶根，这样才能维护所有的回文串。</p><h4 id="构造">构造</h4><p>定义完了那就看看怎么构造它。这里我们使用增量法。</p><p>为了方便，我们给每个点定义一个结构体，存当前点的信息，这里我们就维护三个信息：当前回文串的长度、转移边、fail 边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> son[<span class="number">26</span>], fail;</span><br><span class="line">&#125; t[MAXN];</span><br></pre></td></tr></table></figure><p>先看看怎么初始化，显然我们要先定义两个根。对于奇根，它的长度为 <code>-1</code> （可以把在它两侧加一个字符，当做它会吃掉一个字符），它一开始没有儿子，它的 fail 边随便指（因为它的两侧一定可以加字符）。对于偶根，它的长度为 <code>0</code> （可以看成是空串），它一开始没有儿子，它的 fail 边指向奇根，因为它两侧不能加字符的话，就只能丢给奇根了。即：（<code>0</code> 号节点是偶根，<code>1</code> 号节点是奇根）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t[<span class="number">0</span>].len = <span class="number">0</span>; t[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">t[<span class="number">1</span>].fail = t[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>假设上一次加入的点是 <code>last</code> ，现在需要新增一个字符 <code>ch</code>，假设它存储在 <code>s[pos]</code>。</p><p>首先我们需要找到一个 <code>last</code> 所代表串的一个最长后缀，使得可以在这个后缀后面加上 <code>ch</code>，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfail</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s[pos] != s[pos - t[last].len - <span class="number">1</span>])</span><br><span class="line">    last = t[last].fail;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把这个最长后缀所在的点记作 <code>cur</code>，然后接下来就看 <code>cur</code> 节点有没有 <code>ch</code> 这个儿子，如果有就直接跳过，把 <code>last</code> 设为这个儿子，否则就新增一个节点，记为 <code>nxt</code>。</p><p>对于 <code>nxt</code>，它的长度是 <code>cur</code> 的长度 <code>+2</code> （根据转移边的定义）。它的 fail 的寻找和 AC 自动机很像，是在 <code>cur</code> 的 <code>fail</code> 中再找到一个最长的有 <code>ch</code> 这个字符的儿子的后缀，然后把 <code>nxt</code> 的 fail 指向那个后缀的 <code>ch</code> 儿子。最后再把 <code>cur</code> 的 <code>ch</code> 儿子设为 <code>nxt</code>。具体实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nxt = ++cnt;</span><br><span class="line">t[nxt].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">t[nxt].fail = t[Getfail(t[cur].fail, pos)].son[s[pos] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">t[cur].son[s[pos] - <span class="string">&#x27;a&#x27;</span>] = nxt;</span><br></pre></td></tr></table></figure><p>最后也需要让 <code>last</code> 等于 <code>nxt</code> 。</p><p>这样就可以把 PAM 构造出来，复杂度是 <span class="math inline">\(O(n)\)</span> 的，因为每次跳 fail 会让当前串的长度至少减 <code>2</code>，而加入一个字符只会让当前串的长度加 <code>2</code>，所以跳 fail 的次数是有保障的。</p><h4 id="应用">应用</h4><p>PAM 可以处理很多有关回文串的信息，具体在此就不展开了。实际上我们可以把 AC 自动机或是 SAM 的那些套路拿到 PAM 上来用，具体的怎么做还是得要进行实践。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。&lt;/p&gt;
&lt;p&gt;PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回文自动机" scheme="http://example.com/tags/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
</feed>
