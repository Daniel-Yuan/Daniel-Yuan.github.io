<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APIO2021 游记</title>
    <url>/2021/06/14/APIO2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>六个单词的英文微小说：</p>
<p>Sixty-two points. Ag. Away from OI.</p>
<p>62 Ag 退役了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3328 PYXFIB 题解</title>
    <url>/2021/01/28/BZOJ3328-PYXFIB-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>好像网上没有这么做的题解，所以就写个吧。</p>
<a id="more"></a>
<p>直接单位根反演，就有： <span class="math display">\[
\frac{1}{k}\sum_{j=0}^{k-1}\sum_{i=0}^n{n \choose i}(\omega_k^j)^iF_i
\]</span> 正常的做法是把斐波那契数用矩阵表示，然后用二项式定理。</p>
<p>考虑直接头铁用通项公式展开斐波那契数，就有 <span class="math display">\[
\frac{1}{\sqrt{5}k}\sum_{j=0}^{k-1}\left(\frac{1+\sqrt{5}}{2}(1+\frac{1+\sqrt{5}}{2}\omega_k^j)^n-\frac{1-\sqrt{5}}{2}(1+\frac{1-\sqrt{5}}{2}\omega_k^j)^n\right)
\]</span> 在模意义下可能没有 <span class="math inline">\(5\)</span> 的二次剩余，故考虑扩域，把数表示成 <span class="math inline">\(a+b\sqrt{5}\)</span> 的形式。</p>
<p>定义一下扩域后数的加减乘除然后直接做即可。在这里除法的本质是求逆元，也就是求 <span class="math inline">\(c+d\sqrt{5}\)</span> 使得它和 <span class="math inline">\(a+b\sqrt{5}\)</span> 乘起来为 <span class="math inline">\(1\)</span>。</p>
<p>不过需要注意的是，当 <span class="math inline">\(P=5\)</span> 的时候，<span class="math inline">\(\frac{1}{\sqrt{5}k}\)</span> 没有逆元，这样就会 WA，考虑特殊处理一下。</p>
<p>可以发现 <span class="math inline">\(\frac{1}{\sqrt{5}k}\)</span> 表示成 <span class="math inline">\(a+b\sqrt{5}\)</span> 的形式的时候 <span class="math inline">\(a=0\)</span>，那么当 <span class="math inline">\(P\not=5\)</span> 的时候它的逆元 <span class="math inline">\(a=0\)</span>，既然这样，后面的式子求出来的 <span class="math inline">\(a\)</span> 也会等于 <span class="math inline">\(0\)</span>。</p>
<p>所以我们根本没有必要在这一步把这个复数求逆，直接把 <span class="math inline">\(k\)</span> 求逆乘上后面的式子求出来的 <span class="math inline">\(b\)</span> 即可。</p>
<p>常数可能会比矩阵乘法的做法小。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title>CF506E 题解</title>
    <url>/2020/09/17/CF506E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>一道极 (e) 妙 (xin) 的自动机优化 DP 的题目。</p>
<p>先假设最后得到的字符串为 <span class="math inline">\(T\)</span>，由题意易知 <span class="math inline">\(T\)</span> 合法当且仅当 <span class="math inline">\(T\)</span> 是回文串且 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T\)</span> 的一个子序列。</p>
<p><span class="math inline">\(T\)</span> 是回文串的这个性质我们可以通过从外向内一个一个填字符来实现，所以我们需要 DP 的是 <span class="math inline">\(S\)</span> 相对于 <span class="math inline">\(T\)</span> 而言被匹配了多少个字符。</p>
<p>特别的，因为当 <span class="math inline">\(T\)</span> 的长度为奇数的时候，最后一次填的字符本质上是一个字符，需要特别处理，所以下面我们先讨论 <span class="math inline">\(T\)</span> 的长度为偶数的情况。</p>
<a id="more"></a>
<p>因为 <span class="math inline">\(T\)</span> 这个字符串是从外向内确定的，所以 <span class="math inline">\(S\)</span> 的匹配也是从外向内的，故可以设 <span class="math inline">\(f_{i,l,r}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前后 <span class="math inline">\(i\)</span> 个字符，当前 <span class="math inline">\(S\)</span> 还剩下 <span class="math inline">\([l,r]\)</span> 没有匹配到的方案数。</p>
<p>考虑转移，假设当前有 <span class="math inline">\(s[l] = s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r-1}\)</span>，如果当前填的字符不是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(25\)</span>。</p>
<p>假设当前 <span class="math inline">\(s[l] \not= s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r}\)</span>，如果当前填的字符是 <span class="math inline">\(s[r]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r-1}\)</span>，如果当前填的字符不是两者，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(24\)</span>。</p>
<p>需要注意的是，对于所有的 <span class="math inline">\(f_{i,l,r}(l&gt;r)\)</span>，因为 <span class="math inline">\((l&gt;r)\)</span>，也就是说 <span class="math inline">\(S\)</span> 已经被匹配完，所以无论填什么字符都没关系，那么它们就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(26\)</span>。</p>
<p>这样我们便有了一个 <span class="math inline">\(n\times |S|^2\)</span> 的 DP，如果把后面的状态强行剥离就可以做到 <span class="math inline">\(|S|^6\log n\)</span>，似乎并没有什么用。</p>
<p>考虑优化这个 DP，我们把这个 DP 的转移用一张图来表示，对于 <span class="math inline">\(S=abab\)</span>，转移图是这样的：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/17/wftvp6.png" alt="wftvp6.png" /><figcaption>wftvp6.png</figcaption>
</figure>
<p>其中下划线是已经匹配的部分，在 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列的椭圆表示 <span class="math inline">\(f_{x,i,j}\)</span>，我们把所有的 <span class="math inline">\(l&gt;r\)</span> 的状态归到一个状态里面去，就有了如上的转移图。一个合法的方案本质上就是从 <span class="math inline">\(abab\)</span> 走 <span class="math inline">\(n+|S|\)</span> 步到 ____​ 的一条路径。</p>
<p>我们把某条路径上面的所有节点拿出来，并且按照 <span class="math inline">\(s[l]\)</span> 是否等于 <span class="math inline">\(s[r]\)</span> 分类成两种点，可以发现，无论这两种点的排列如何，当这两种点的数量确定的时候，答案已经确定了。</p>
<p>设 <span class="math inline">\(s[l]=s[r]\)</span> 的点为 <span class="math inline">\(0\)</span> 类点，<span class="math inline">\(s[l]\not=s[r]\)</span> 的点为 <span class="math inline">\(1\)</span> 类点，不难发现在某条路径上确定了 <span class="math inline">\(1\)</span> 类点的数目后，可以直接计算得到一个唯一的 <span class="math inline">\(0\)</span> 类点的数目，而 <span class="math inline">\(1\)</span> 类点的数目的取值范围为 <span class="math inline">\([0,len-1]\)</span>，所以总共不同的路径数最多只有 <span class="math inline">\(|S|\)</span> 条。</p>
<p>考虑有多少种方案经过某条路径，设 <span class="math inline">\(g_{x,l,r}\)</span> 表示在区间 <span class="math inline">\([l,r]\)</span> 的这段转移中，总共经过 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(1\)</span> 类点的方案数，用记忆化搜索即可求得，我们需要的就是 <span class="math inline">\(g_{x,1,|S|}\)</span>。这部分复杂度 <span class="math inline">\(|S|^3\)</span>。</p>
<p>在一条路径上面 DP 的复杂度是 <span class="math inline">\(|S|\times n\)</span>，通过矩阵优化可以优化到 <span class="math inline">\(|S|^3\times \log n\)</span>，总复杂度即 <span class="math inline">\(|S|^4\log n\)</span>，虽然仍然过不了，但是优化了很多。</p>
<p>我们设起点为 <span class="math inline">\(S\)</span>， <span class="math inline">\(0\)</span> 类点为黑色，<span class="math inline">\(1\)</span> 类点为白色，终点为 <span class="math inline">\(T\)</span>，上述过程中的转移图差不多是这样：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/18/w4aqtH.png" alt="w4aqtH.png" /><figcaption>w4aqtH.png</figcaption>
</figure>
<p>考虑继续优化，上述算法问题就出在我们对每种路径都跑了一次 DP，考虑把它们合并成一次。先规定所有的路径<span class="math inline">\(0\)</span> 类点都在前面，<span class="math inline">\(1\)</span> 类点都在后面。然后在新的转移图上把第一行放上 <span class="math inline">\(0\)</span> 类点，第二行放上 <span class="math inline">\(1\)</span> 类点，在第一行的点之间连边，第二行的点之间连边，现在就考虑怎么在第一行的点和第二行的点之间连边，不难发现，这种连边实质上代表了一种路径，因为这种边只能走一次，且走这种边就可以确定经过的 <span class="math inline">\(0\)</span> 类点和 <span class="math inline">\(1\)</span> 类点的数目，这样的话复杂度就优化到了 <span class="math inline">\(|S|^3\log n\)</span>。</p>
<p>把上图按照这种优化连边之后的图就是这样：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/18/w4d83R.png" alt="w4d83R.png" /><figcaption>w4d83R.png</figcaption>
</figure>
<p>其中从第一行的点到第二行的点的转移系数为有多少种方案经过这种路径，即 <span class="math inline">\(g_{x,l,r}\)</span>。可以发现这样转化之后只有 <span class="math inline">\(\frac{3}{2}|S|\)</span> 个点，且因为转移图是 DAG 图，所以可以通过编号使得转移都是从编号小的点转移到编号大的点，这样可以得到一个比较优秀的常数优化。复杂度 <span class="math inline">\(|S|^3\log n\)</span>。</p>
<p>最后还需要考虑一下 <span class="math inline">\(|T|\)</span> 为奇数。我们先把 <span class="math inline">\(|T|\)</span> 的长度看做 <span class="math inline">\(|T|+1\)</span> ，这样就可以得到一个答案。考虑有多少种方案不合法，可以发现是所有最后一步是放两个字符，且恰好在最后一次转移的时候放的方案，我们把这种方案算出来减掉即可。具体的，把所有最后一步是放两个字符的路径拿出来，然后去掉终点的自环再跑一遍上述 DP，这次求出来的答案就是要减掉的方案。</p>
<p>至此便可完美解决此题。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = i; j &lt;= lim; ++j) &#123;</span><br><span class="line">        re.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = i; k &lt;= j; ++k)</span><br><span class="line">          re.a[i][j] = (re.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; F;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Matpow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Matrix re;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; j &lt;= lim; ++j)</span><br><span class="line">      re.a[i][j] = (i == j);</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[x][l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">  <span class="keyword">if</span> (s[l] == s[r])</span><br><span class="line">    f[x][l][r] = DP(x, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f[x][l][r] = (DP(x - <span class="number">1</span>, l + <span class="number">1</span>, r) + DP(x - <span class="number">1</span>, l, r - <span class="number">1</span>)) % mod;</span><br><span class="line">  <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">int</span> n, len;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; n;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  lim = len + (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">    F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  F.a[lim][lim] = <span class="number">26</span>;</span><br><span class="line">  F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">    ans = F.a[<span class="number">1</span>][lim];</span><br><span class="line">  ans = (ans + F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod) % mod;</span><br><span class="line">  <span class="keyword">if</span> ((n + len) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(F.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(F.a));</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!((len - i) &amp; <span class="number">1</span>))</span><br><span class="line">        F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">      ans = (ans - F.a[<span class="number">1</span>][lim] + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!(len &amp; <span class="number">1</span>))</span><br><span class="line">      ans = (ans - F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2019 游记</title>
    <url>/2019/11/16/CSP-S%202019%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离十一月十六日只不足几天，CSP 的审判快要降临了罢，我正有写一点东西的必要了。（雾</p>
<a id="more"></a>
<h2 id="day--1">Day -1</h2>
<p>教练组织高二的学长出去玩去了，苦逼的我还要接着考 CSP 信(zi)心(bi)赛。/羡慕</p>
<p>配 <code>emacs</code> 的时候突然忘记 <code>default</code> 怎么写了，一直认为最后两个字母是 <code>te</code> 。最后还是靠着 <code>switch</code> 的高亮打出来的（CSP 前犯这种错误我怕不是要爆零）</p>
<p>晚上 U 盘坏了，捣鼓了一晚上。</p>
<p>考前 RP 突然爆炸，感觉吃枣药丸（怕不是 CSP-S RP++ 爆负了……）</p>
<h2 id="day-0">Day 0</h2>
<p>上午写了一个线性基板子，一个矩阵快速幂板子，一个 <code>Miller-Rabin</code> 板子。</p>
<p>之后就欢快地颓了一下午加一晚上。<del>（某乎：如何看待某巨佬 AK CSP-S）</del></p>
<h2 id="day-1">Day 1</h2>
<p>在一阵互相膜拜之后进入了考场。</p>
<p>座位之间有隔板 <del>考试前还在讨论如何用毒瘤码风祸害周围同学</del>，键盘敲起来特别舒服，值得一提的是，<code>Emacs</code> 有配置文件！<del>好评</del>。</p>
<p>开考后 10 分钟就把 T1 切了。</p>
<p>T2 像极了考前的一道 <del>九条可怜</del> 的括号匹配题，几分钟码了个 <code>Trie</code> 树就过样例了，然而那个题<strong>忽略括号方向</strong> <del>我给忘了QAQ</del>。</p>
<p>然后 T3 看上去很玄学的样子，开始手玩，结果手玩不动样例……<del>还不如暴搜</del></p>
<p>闲的没事就给 T2 写了个对拍，一组就错……</p>
<p>发现了那个小错误后重新思考做法，发现还是可以用栈的思想，在每次加入或删除一个节点的时候计算贡献，过了样例后接着拍，还是炸了，不过 <del>它已经被我优化到拍几百组错一组了</del>。</p>
<p>接着调，发现是个小错误，调完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几千组错一组了</del>。</p>
<p>接着调，又发现个小错误，调完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几万组错一组了</del>。</p>
<p>当我百思不得其解时，已经 10:50了 QAQ。</p>
<p>当我气的去打完 T3 搜索并且想了一下特殊数据后，已经 11:20 了。</p>
<p>当我感慨造化弄人，以为要命绝于此，要被这次 <code>CSP</code> 送退役时，发现：<strong>我 ** <code>vector</code> 访问了非法内存 ？？？</strong> 。</p>
<p>改完之后拍几万组都没有问题，不过这次考试也因为 T2 止步 210 了……</p>
<p>又欢乐地颓了一下午加一晚上。</p>
<h2 id="day-2">Day 2</h2>
<p>昨天颓太欢乐了，今早莫名的困……</p>
<p>感觉今天心态都不一样了……昨天想着怎么拿高分怎么 AK，今天就只想着多拿点分 <del>（还是不能给我这种蒟蒻太高的期望）</del></p>
<p>开场就写了一个 T1 的 <span class="math inline">\(n^2m\)</span> 的做法，后来发现它假了，只能补上一维保证正确性，最后打了个 <span class="math inline">\(n^3m\)</span> 的 <code>DP</code>。</p>
<p>然后写 T2，一开始写了一个 <span class="math inline">\(n^3\)</span> 的<code>DP</code>，并且理性分析发现可以优化到 <span class="math inline">\(n^2\)</span> 。经过人(bao)类(li)智(da)慧(biao)后，发现每个以每个点为终点的 <code>DP</code> 值有且仅有一个有用，于是可以使用单调队列优化做到 <span class="math inline">\(O(n)\)</span> ，<del>但是为啥我压 8 位高精都可以MLE，只能过 type=0</del></p>
<p>最后写 T3，发现暴力分出奇地高，于是写完暴搜后就找特殊数据的规律，<del>还真被我找到了</del>，又骗了一大波分。</p>
<p>一道题都没切预计都比昨天高……<del>我 ** 昨天在干嘛</del>。</p>
<h2 id="后记">后记：</h2>
<p>210 + 247 = 457……没能完成教练定的500分目标<del>AFO AFO</del>……</p>
<p>趁还没有退役先把游记码了……<del>AFO了就没机会了</del></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1 2020 游记</title>
    <url>/2020/10/11/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="day-1">Day 1</h4>
<a id="more"></a>
<p>今天的状态就一个字：困。</p>
<p>平时周末这么早还沉醉在<del>温柔乡</del>梦乡的我，坐着校车晃晃悠悠地去了考场。</p>
<p>天空很蓝，阳光很暖，和兄弟们看着来往的<del>妹子</del>人群，感觉生活无比惬意。</p>
<p>在见到如此多的小学生、初中生后，感觉自己真的老了<del>教练真就不当人</del>。</p>
<p>一坐下就想睡觉，越考越想睡，rush 到第三个阅读的时候就感觉整个人都要没了，天人交战了好一会之后才又重新开始从后往前 rush，最后好不容易 rush 完了，结果却睡不着了。<del>（强烈抗议 CSP-S1 耽误我睡觉）</del></p>
<p>中午众人决定去吃大餐，在兜兜转转之下，选择了某 M 开头的快餐店。</p>
<p>虽然状态不太好，但是这波还是很稳的，祝愿 CSP-S2 2020 RP++。</p>
<h4 id="day-inf">Day INF</h4>
<p>成绩出来了，比预计的高一点点 96pts <code>O(∩_∩)O</code>。</p>
<p>但是……听说同校的聚聚不仅 AK 初赛，而且月考年级第二（说不定还是位人赢），突然就感觉生活失去希望。</p>
<p>不过还是祝愿 CSP-S2 2020 RP++。</p>
<p><del>为了不引起日期恐慌，博主决定把游记分开写</del>。</p>
<p><a href="https://daniel-yuan.github.io/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/">CPS-S2 2020 游记</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2 2020 游记</title>
    <url>/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="day--1">Day -1</h4>
<a id="more"></a>
<p>考了一场很秀的模拟赛。</p>
<p>开局看题，发现 T1,T2,T4 都是一眼题，代码难度 T1&lt;T4&lt;T2。于是 rush 完 T1 之后直接肝 T3。</p>
<p>肝了 1.5h 没肝出来，决定先稳一波 rush 一手 T4，rush 完写对拍的时候监考老师绕到了我的后面。</p>
<p>“这是第四题吗？”</p>
<p>“嗯。”</p>
<p>“这是什么？对拍吗？”</p>
<p>“嗯。”</p>
<p>“那你是不是都做完了？”</p>
<p>“没有，只写了 T1,T4。”</p>
<p>"哦~"</p>
<p>似乎这只是一个平平无奇的对话，但不久后监考老师冷不丁来一句：“其实这套题目并不完全是按照难度排序，T3 应该要比 T2 简单。”</p>
<p>一只南美洲亚马逊河流域热带雨林中的蝴蝶，偶尔扇动几下翅膀，可以在两周以后引起美国得克萨斯州的一场龙卷风。监考老师的一句提醒，也可以引起很多人做题策略的改变。</p>
<p>我听完之后虽然有点小慌，但是之前就已经止损过了，所以还是稳着先把 T2 写了，最后才去肝 T3。</p>
<p>但是很多人都因为这一句话，直接硬肝 T3，结果全盘皆崩。</p>
<p>我们称这个事件为【Y 郎妙计安天下】。</p>
<h4 id="day-0">Day 0</h4>
<p>又是一场披着 CSP 皮的毒瘤模拟赛。</p>
<p>真想拿个仙人掌拍出题人头上让他见识一下什么才是真正的仙人掌。</p>
<p>不过有一说一，感觉现在码力变强了好多，一开始误认为仙人掌是点不重复，rush 了 4k 多，发现错了之后又重新 ruch 了 4k 多结果还一遍过……</p>
<p>考前毒奶：因为 CSP 毕竟是合格性考试，所以不会太难，T1,T2 应该都是送分，T3,T4 略难一点。</p>
<h4 id="day-1">Day 1</h4>
<p>为了考前不颓废，VP 了一场 CF Div.1。</p>
<p>Rush 完 A,B 后，发现 C 是一个计算几何，D 是一个比较麻烦的 DP，瞬间失去了写代码的欲望。</p>
<p>结果剩下的时间差不多都在知乎、2020 US Election、Typeracer、Pokemonshowdown 之间徘徊。<del>考前颓废是 OIER 的传统艺能。</del></p>
<p>吃完中饭就去考场了。因为自己动作比较憨，上车的时候就只有后排中间的 C 位了，于是就有了名场面【Dan 皇登基】（雾</p>
<p>考前集体毒奶：早出来一小时就可以多休息一小时，今天下午直接车队走起。</p>
<p>考试体验依旧很 nice，座位很舒适，键盘很丝滑，配置很体贴。</p>
<p>但是……题目很毒瘤。</p>
<p>浏览一遍题目之后直接想自闭离场了。</p>
<p>打个比方，切题就类似于在山里找宝藏，有些宝藏是藏得很深，需要你依靠自己的能力找到宝藏的位置<del>（宝藏猎人）</del>。而有些宝藏就直接给扔山顶，一眼就看得到，不过如果想得到它就需要花大功夫。</p>
<p>T1 就是后者，而且山顶还不是普通山的山顶，那是珠穆朗玛峰的山顶。</p>
<p>硬着头皮肝 T1，40min，一遍过。</p>
<p>硬着头皮肝 T2，20min，一遍过。</p>
<p>T3 一开始一点思路都没有，结果就直接想睡觉了……<del>（强烈抗议 CSP-S2 又耽误我睡觉）</del>。</p>
<p>迷迷糊糊了 30min，状态回暖之后直接把 T4 70 分暴力 rush 了，然后继续肝 T3。</p>
<p>离下考还有 50min 了时候隐隐约约有了一个算法，然后直接 rush，30 min 写完一遍过样例。</p>
<p>剩下的时间感觉 T4 优化无望，于是就各种检查。</p>
<p>预计 100+100+100+70=370，似乎不低的样子。</p>
<p>考完之后就是颓颓颓！！！</p>
<h4 id="day-2">Day 2</h4>
<p>CSP 已经没有 Day 2 了……又要继续为 NOIP 奋斗了。</p>
<p>测了一下民间数据，T1,T2,T4 100+100+70 稳了，但是 T3 有点点问题。</p>
<p>后来发现我本质上要维护的是后缀积，但是我的做法是维护整体积除前缀积，然而数据范围是 <span class="math inline">\(0\leq V_j\leq 10^4\)</span>……</p>
<p>现在我的成绩完全掌握在 T3 出题人的手中了……希望 TA 能大发慈悲，可怜可怜没注意 <span class="math inline">\(V_j=0\)</span> 的孩子吧。</p>
<h4 id="day-inf">Day INF</h4>
<p>呐~命运被掌握在别人手中的感觉真是很不好呢。</p>
<p>最后 100+100+70+70 了，T3 被卡到还不如指数级暴力 <code>(* ￣︿￣)</code>。</p>
<p>最后当然是 NOIP 2020 RP++。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTSC2010] 性能优化 题解</title>
    <url>/2021/01/29/CTSC2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>不难发现就是求 <span class="math inline">\(A*B^C\)</span> 的长度为 <span class="math inline">\(n\)</span> 的循环卷积（这都看不出来还配做这个题？）</p>
<a id="more"></a>
<p>一种及其 naive 的想法是倍增多项式快速幂模拟循环卷积。</p>
<p>因为值域很小，直接用 FFT 是足够的，复杂度 <span class="math inline">\(O(n\log n\log C)\)</span>，怎么看都过不了。</p>
<p>我们知道 FFT 本质上就是做的循环卷积。</p>
<p>所以说如果我们能求出长度为 <span class="math inline">\(n\)</span> 的 DFT 和 IDFT，那么我们直接 DFT 了 <span class="math inline">\(A,B\)</span>，然后把 <span class="math inline">\(B\)</span> 的点值求个 <span class="math inline">\(C\)</span> 次方，然后再 IDFT 回去。套一个 Bluestein 就是 <span class="math inline">\(O(n\log n)\)</span> 的了。</p>
<p>这样复杂度是 <span class="math inline">\(O(9n\log n)\)</span> 的，有点点卡常。</p>
<p>但是显然有一个性质我们没有用到，就是 <span class="math inline">\(n\)</span> 能表示成若干个不超过 <span class="math inline">\(10\)</span> 的正整数的乘积。</p>
<p>不妨考虑普通 FFT 的本质，是把它分成奇偶两部分 <span class="math inline">\(A_0(x)=a_0x^0+a_2x^1...,A_1(x)=a_1x^0+a_2x^1...\)</span>，然后递归下去算，最后这个点的 <span class="math inline">\(A(x)=A_0(x^2)+xA_1(x^2)\)</span>。</p>
<p>类似的，我们可以把 <span class="math inline">\(A\)</span> 分成 <span class="math inline">\(p\)</span> 份，<span class="math inline">\(A_0,A_1...A_p\)</span>，递归下去，回溯的时候 <span class="math inline">\(O(p)\)</span> 合并。</p>
<p>总复杂度是 <span class="math inline">\(O(\sum np)\)</span> 的，因为 <span class="math inline">\(n\)</span> 的质因子只有 <span class="math inline">\(2,3,5,7\)</span>，所以这个复杂度是可以接受的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line">LL omega[MAXN];</span><br><span class="line">LL a[MAXN], b[MAXN], t[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span> </span>&#123;</span><br><span class="line">  LL re = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % mod)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a % mod;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Prime[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getwn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = mod - <span class="number">1</span>, cnt = <span class="number">0</span>, sq = <span class="built_in">sqrt</span>(mod - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">2</span>; i &lt;= sq; ++i)</span><br><span class="line">    <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">      Prime[++cnt] = i;</span><br><span class="line">      <span class="keyword">while</span> (tmp % i == <span class="number">0</span>)</span><br><span class="line">        tmp /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (tmp != <span class="number">1</span>) Prime[++cnt] = tmp;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">2</span>; <span class="number">666</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; flag &amp;&amp; j &lt;= cnt; ++j)</span><br><span class="line">      <span class="keyword">if</span> (qpow(i, (mod - <span class="number">1</span>) / Prime[j]) == <span class="number">1</span>)</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(LL *a, <span class="keyword">int</span> len, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>();</span><br><span class="line">  <span class="keyword">for</span> (RI i = l; i &lt;= r; ++i) t[i] = a[i];</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">7</span> == <span class="number">0</span>) p = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">5</span> == <span class="number">0</span>) p = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">3</span> == <span class="number">0</span>) p = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) p = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> L[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;, R[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> cur = l, sz = len / p;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">    L[i] = cur, R[i] = cur - <span class="number">1</span>, cur += sz;</span><br><span class="line">  <span class="keyword">for</span> (RI i = l; i &lt;= r; ++i)</span><br><span class="line">    a[++R[(i - l) % p]] = t[i];</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; p; ++i) </span><br><span class="line">    FFT(a, sz, L[i], R[i], op);</span><br><span class="line">  <span class="keyword">for</span> (RI i = l; i &lt;= r; ++i) t[i] = a[i];</span><br><span class="line">  LL wn = (mod - <span class="number">1</span>) / len, w = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>; a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI j = (i - l) % (len / p) + l; j &lt;= r; j += sz) &#123;</span><br><span class="line">      a[i] = (a[i] + t[j] * omega[tmp] % mod) % mod;</span><br><span class="line">      tmp = (tmp + w) % (mod - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    w = (w + op * wn + mod - <span class="number">1</span>) % (mod - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n, C; read(n), read(C); mod = n + <span class="number">1</span>;</span><br><span class="line">  LL wn = Getwn(); omega[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    omega[i] = omega[i - <span class="number">1</span>] * wn % mod;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i) read(a[i]);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i) read(b[i]);</span><br><span class="line">  FFT(a, n, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  FFT(b, n, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i] = a[i] * qpow(b[i], C) % mod;</span><br><span class="line">  FFT(a, n, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    print(a[i] * qpow(n, mod - <span class="number">2</span>) % mod);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>循环卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>DP of DP</title>
    <url>/2021/01/21/DP-of-DP/</url>
    <content><![CDATA[<p>做过不少 DP of DP 题，但是考试还是想不到，很气，写个总结记录下。</p>
<a id="more"></a>
<p>对于一个题目，如果它要求的是在某个限制下计数，并且在看一个状态有没有满足限制的时候也需要 DP，这时候往往就要用到 DP of DP。</p>
<p>一般的流程是这样的，我们先考虑对于一个已知状态，怎么判定其是否满足性质。这时候我们一般都会有一个 DP，且这个 DP 是用增量法填表的，即类似于 <span class="math inline">\(f_{i,...}\)</span> 表示前 <span class="math inline">\(i\)</span> 个位置（或其它）怎么怎么样。然后因为我们的根本需求是计数，而计数我们也用到增量法，所以可以把 <span class="math inline">\(f_{i,...}\)</span> 的 <span class="math inline">\(i\)</span> 放到外层 DP 处，然后把剩下的 <span class="math inline">\(f_{...}\)</span> 给排成一列压缩起来，变成一个状态。这样在外层我们就得到了 <span class="math inline">\(F_{i,S}\)</span>，表示考虑前 <span class="math inline">\(i\)</span> 个位置（或其它），内层 DP 的状态是 <span class="math inline">\(S\)</span> 的方案数。在转移 <span class="math inline">\(i+1\)</span> 的时候，我们把 <span class="math inline">\(S\)</span> 还原成内层 DP 数组 <span class="math inline">\(f_{...}\)</span>，然后对 <span class="math inline">\(f_{...}\)</span> 和 <span class="math inline">\(i+1\)</span> 跑内层 DP 得到一个新状态<span class="math inline">\(f^{&#39;}_{...}\)</span> 并重新压缩成 <span class="math inline">\(T\)</span>，这样就可以从 <span class="math inline">\(F_{i,S}\)</span> 转移到 <span class="math inline">\(F_{i+1,T}\)</span>。</p>
<p>考虑看一道例题：</p>
<blockquote>
<p>给一个小写字母字符串 <span class="math inline">\(S\)</span>，<span class="math inline">\(|S|\leq15\)</span>，问有多少个长度为 <span class="math inline">\(n\)</span>，<span class="math inline">\((n\leq 100)\)</span> 的小写字母字符串 <span class="math inline">\(T\)</span>，使得 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 的最长上升子序列的长度为 <span class="math inline">\(k\)</span>。对于 <span class="math inline">\(k=0,1,2...|S|\)</span> 都要求答案。</p>
</blockquote>
<p>经典题，按照上面的流程来做。</p>
<p>首先对于一个已知字符串 <span class="math inline">\(T\)</span>，考虑求它的最长上升子序列。设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前 <span class="math inline">\(i\)</span> 个字符，<span class="math inline">\(S\)</span> 的前 <span class="math inline">\(j\)</span> 个字符的最长上升子序列最长是多少。这个 DP 符合增量法，所以把 <span class="math inline">\(f_{1,2...j}\)</span> 压缩成一个状态 <span class="math inline">\(S\)</span>。在外层，设 <span class="math inline">\(F_{i,S}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前 <span class="math inline">\(i\)</span> 个字符，<span class="math inline">\(f_{i,\{0,1...|S|\}}\)</span> 算出来的值状压起来为 <span class="math inline">\(S\)</span> 的方案数。转移的时候，枚举下一个字符填什么，然后把 <span class="math inline">\(S\)</span> 还原成 <span class="math inline">\(f\)</span>，然后计算出新的 <span class="math inline">\(f&#39;\)</span>，再状压回 <span class="math inline">\(T\)</span>，就可以从 <span class="math inline">\(F_{i,S}\)</span> 转移到 <span class="math inline">\(F_{i+1,T}\)</span> 了。</p>
<p>这样我们就完成了普通的 DP of DP，但是这样复杂度有问题，因为 <span class="math inline">\(f\)</span> 的取值范围是 <span class="math inline">\([0,15]\)</span> 压起来特别大，但是我们发现 <span class="math inline">\(f_i-f_{i-1}\in[0,1]\)</span>，所以可以把 <span class="math inline">\(f_i-f_{i-1}\)</span> 压起来，这样 <span class="math inline">\(F_{i,S}\)</span> 的 <span class="math inline">\(S\)</span> 的取值只有 <span class="math inline">\(2^{15}\)</span> 了。</p>
<p>代码如下，这里只实现了字符集为 <span class="math inline">\(\{N,O,I\}\)</span> 。原题是 <a href="https://www.luogu.com.cn/problem/P4590">[TJOI2018] 游园会</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>], g[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> Trans[<span class="number">1</span> &lt;&lt; <span class="number">15</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">3</span>][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> bitcnt[<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> Ans[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y - mod, x += (x &gt;&gt; <span class="number">31</span>) &amp; mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI S = <span class="number">0</span>, NS; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      f[i] = f[i - <span class="number">1</span>] + ((S &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;N&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">0</span>] = NS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;O&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">1</span>] = NS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      g[i] = max(g[i - <span class="number">1</span>], max(f[i], f[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;I&#x27;</span>)));</span><br><span class="line">    NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">      NS |= (g[i] - g[i - <span class="number">1</span>]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    Trans[S][<span class="number">2</span>] = NS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> cur = <span class="number">1</span>, nxt = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    swap(cur, nxt);</span><br><span class="line">    <span class="built_in">memset</span>(dp[nxt], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[nxt]));</span><br><span class="line">    <span class="keyword">for</span> (RI S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">1</span>][Trans[S][<span class="number">0</span>]], dp[cur][<span class="number">2</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">2</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">1</span>]], dp[cur][<span class="number">2</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">2</span>]], dp[cur][<span class="number">0</span>][S]);</span><br><span class="line">      Add(dp[nxt][<span class="number">0</span>][Trans[S][<span class="number">2</span>]], dp[cur][<span class="number">1</span>][S]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI S = <span class="number">1</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S)</span><br><span class="line">    bitcnt[S] = bitcnt[S ^ (S &amp; (-S))] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S)</span><br><span class="line">      Add(Ans[bitcnt[S]], dp[nxt][i][S]);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt;= k; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是我们肯定不仅仅满足这个普通的 DP of DP，我们需要更便捷的东西——自动机。</p>
<p>也就是说我们干脆就直接把 <span class="math inline">\(S\)</span> 看成是一个状态的集合，然后把所有的状态的集合建出一个转移的自动机。一个自动机上面的节点代表着一个状态，而转移边就代表着这个状态加入一个东西后可以转移到哪里。这样我们的 DP 就变成了一个普通的自动机上 DP。</p>
<p>典型例子是 <a href="https://www.luogu.com.cn/problem/P5279">[ZJOI2019] 麻将</a>，可以结合<a href="https://daniel-yuan.github.io/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/#more">我的这篇博客</a>把这个题切了。</p>
<p><del>（不知为何写着写着就变成一个普及 DP of DP 的博客了……）</del></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>DP of DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Dan 的犯傻合集</title>
    <url>/2021/05/02/Dan-%E7%9A%84%E7%8A%AF%E5%82%BB%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>Daniel_yuan 笨死了！！！</p>
<a id="more"></a>
<p>不管是左移还是右移，移动的位数超过位长是 UB，主流编译器会把移动的位数对位长取模。所以 <code>1ull &gt;&gt; 64</code> 得到的是 <code>1</code> 不是 <code>0</code>。</p>
<p>生成函数的前缀和是乘上 <span class="math inline">\(1+x+x^2+...\)</span>，普通函数的离散前缀和是离散积分，两者完全不同。</p>
<p>长度为 <span class="math inline">\(K\)</span> 的常系数齐次线性递推，矩阵快速幂的求转移矩阵的 <span class="math inline">\(n-K\)</span> 次方，而多项式做法是求 <span class="math inline">\(x^n\)</span> 对特征多项式取模的结果。</p>
<p>写 SAM 的时候复制节点记得要把大多数维护的信息都传过去。</p>
<p>线段树合并优化 DP 注意左右孩子合并顺序。</p>
<p><code>vector</code> 内部元素内存确实是动态开的，但是它有一个指针的静态内存。（不要傻到 <code>vector</code> 静态内存爆炸）</p>
<p>扫描线维护矩形面积并的线段树，有句话可能是这样的 <code>sum[x] = (tag[x] &gt; 0 ? val[x] : sum[lc] + sum[rc]);</code> ，这句话可能会对叶子实现，如果不特判的话，数组要开 8 倍。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>Daniel_yuan&#39;s New Blog</title>
    <url>/2020/09/15/Daniel-yuan-s-New-Blog/</url>
    <content><![CDATA[<p>这是 Daniel_yuan 的新博客。也是一块留言板。</p>
<p>有什么想对 Daniel_yuan 说的就发在下面吧！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>Euler Project</title>
    <url>/2021/02/22/Euler-Project/</url>
    <content><![CDATA[<p>大佬说 Euler-Project 没有刷的必要，这篇博客咕了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>FWT 小结</title>
    <url>/2021/01/19/FWT-%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>FWT 是快速求形如 <span class="math inline">\(C(x)=\sum_{i?j=x}A(i)B(j)\)</span> 的算法，其中 <span class="math inline">\(?\)</span> 表示一种二进制的位运算。</p>
<a id="more"></a>
<h4 id="原理">原理</h4>
<p>其实 FWT 背板挺容易的，但是因为考试趋向越来越本质化，所以我们要逐渐开始了解一些原来背板算法的原理。</p>
<p>类似于 FFT，我们考虑从最本源的地方来了解 FWT——构造一种线性变换 <span class="math inline">\(A\rightarrow A&#39;\)</span>，使得 <span class="math inline">\(C&#39;(x)=A&#39;(x)B&#39;(x)\)</span>，这样去掉线性变换的复杂度，总复杂度是 <span class="math inline">\(O(len)\)</span> 的。需要注意的是，这里的 <span class="math inline">\(A,B,C\)</span> 需要做同一种线性变换。</p>
<p>因为我们所做的是线性变换（即只存在加减），那么在 <span class="math inline">\(A&#39;\)</span> 中，我们可以把 <span class="math inline">\(A\)</span> 中每个数对它的贡献用一个系数表示，即 <span class="math inline">\(A&#39;(x)=\sum_i f(x,i)A(i)\)</span>。</p>
<p>那么 <span class="math inline">\(C&#39;(x)=\sum_i f(x,i)C(i)=\sum_if(x,i)\sum_{j?k=i}A(j)B(k)\)</span>，<span class="math inline">\(A&#39;(x)B&#39;(x)=\sum_if(x,i)A(i)\sum_jf(x,j)B(j)\)</span>。整理得 <span class="math inline">\(\sum_i\sum_jf(x,i?j)A(i)B(j)=\sum_i\sum_jf(x,i)f(x,j)A(i)B(j)\)</span>。故有 <span class="math inline">\(f(x,i?j)=f(x,i)f(x,j)\)</span>。</p>
<p>也就是说我们需要构造 <span class="math inline">\(f(x,i)\)</span>，使得它满足上述需求。</p>
<p>对于或操作，有 <span class="math inline">\(f(x,i \text{ or }j)=f(x,i)f(x,j)\)</span>，不难发现 <span class="math inline">\(i\text{ or }j\in x\Leftrightarrow i\in x\land j\in x\)</span>，那么设 <span class="math inline">\(f(x,i)=[i\in x]\)</span> 即可。</p>
<p>对于与操作，有 <span class="math inline">\(f(x,i\text{ and }j)=f(x,i)f(x,j)\)</span>，和或相似的，<span class="math inline">\(x\in i\text{ and }j\Leftrightarrow x\in i\land x\in j\)</span>。<span class="math inline">\(f(x,i)=[x\in i]\)</span>。</p>
<p>对于异或操作，这可能就有些麻烦。我们需要挖掘一些异或的性质。对于两个数 <span class="math inline">\(x,y\)</span>，显然 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(1\)</span> 的个数加上 <span class="math inline">\(y\)</span> 的 <span class="math inline">\(1\)</span> 的个数的奇偶性和 <span class="math inline">\(x \text{ xor } y\)</span> 的相同。而与和异或有恒等式 <span class="math inline">\((x\text{ xor } y)\text{ and } z=(x\text{ and }z)\text{ xor }(y\text{ and }z)\)</span>（不难证明），所以 <span class="math inline">\(i\text{ and }x\)</span> 的 <span class="math inline">\(1\)</span> 的个数加上 <span class="math inline">\(j\text{ and }x\)</span> 的 <span class="math inline">\(1\)</span> 的个数的奇偶性和 <span class="math inline">\((i\text{ and }x)\text{ xor }(j\text{ and }x)=(i\text{ xor } j)\text{ and } x\)</span> 的相同，而奇偶性的区分加减我们一般用 <span class="math inline">\((-1)^k\)</span> ，所以设 <span class="math inline">\(f(x,i)=(-1)^{|x \text { and }i|}\)</span> 即可。</p>
<h4 id="实现">实现</h4>
<p>下面只讨论 FWT，对于 IFWT，其就是 FWT 的逆向过程。</p>
<p>考虑按位计算贡献。</p>
<p>设 <span class="math inline">\(f_k(S)\)</span> 表示对于 <span class="math inline">\(S\)</span>，已经计算了前 <span class="math inline">\(k\)</span> 位任意，后面位数严格和 <span class="math inline">\(S\)</span> 相等且暂未考虑其对贡献的影响的贡献。考虑从 <span class="math inline">\(f_k(S)\)</span> 推到 <span class="math inline">\(f_{k+1}(S)\)</span>。</p>
<p>考虑每个数对 <span class="math inline">\(u,v\)</span> 互相的贡献，其中 <span class="math inline">\(u,v\)</span> 仅在第 <span class="math inline">\(k+1\)</span> 位不同，为了方便，设 <span class="math inline">\(u&lt;v\)</span>。</p>
<p>对于或，<span class="math inline">\(f_k(u)\)</span> 中存的是后面位数和 <span class="math inline">\(u\)</span> 相等，<span class="math inline">\(1\sim k\)</span> 位是 <span class="math inline">\(u\)</span> 子集的数的贡献，<span class="math inline">\(f_k(v)\)</span> 同理，那么显然考虑了第 <span class="math inline">\(k+1\)</span> 位后，<span class="math inline">\(f_{k+1}(u)=f_k(u)\)</span> ，<span class="math inline">\(f_{k+1}(v)=f_k(u)+f_k(v)\)</span>。</p>
<p>类似的，对于与，<span class="math inline">\(f_{k+1}(u)=f_k(u)+f_k(v)\)</span> ，<span class="math inline">\(f_{k+1}(v)=f_k(v)\)</span>。</p>
<p>对于异或，<span class="math inline">\(u\)</span> 在 <span class="math inline">\(k+1\)</span> 位对数的符号没有影响，而 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(k+1\)</span> 位对 <span class="math inline">\(k+1\)</span> 位为 <span class="math inline">\(1\)</span> 的数的符号有一个 <span class="math inline">\(-1\)</span> 的影响（因为之前没有考虑这一位对答案贡献的影响），所以 <span class="math inline">\(f_{k+1}(u)=f_k(u)+f_k(v)\)</span>，<span class="math inline">\(f_{k+1}(v)=f_k(u)-f_k(v)\)</span>。</p>
<p>这样就能在 <span class="math inline">\(O(len\log len)\)</span> 的时间内对于 <span class="math inline">\(A\)</span> 求得 <span class="math inline">\(A&#39;\)</span>。而逆变化就是正变化的相反操作，在此就不再赘述。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>FWT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2019]JOJO 题解</title>
    <url>/2020/12/29/HNOI2019-JOJO-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这个题目的 <span class="math inline">\(2\)</span> 操作代表着需要维护一个可持久化的东西。</p>
<p>但是因为它没有强制在线，根据常识，可以离线生成一个操作树来降低思考难度。</p>
<p>不难发现最终的字符串的长度可能会非常长，可以达到 <span class="math inline">\(n\cdot x=10^9\)</span> 级别，这提示我们不能从字符串本身入手。</p>
<a id="more"></a>
<p>考虑一个后缀是 Border 需要满足什么条件，假设现在有字符串 <span class="math inline">\(aa|c|bb|aaa|c|b\)</span>，其中的一个 Border 就是 <span class="math inline">\(aacb\)</span>。我们把它的对应段拿出来，即 <span class="math inline">\((a,2)(c,1)(b,2)\)</span> 和 <span class="math inline">\((a,3)(c,1)(b,1)\)</span>，可以发现的是，它的第一段的长度必须大于等于整个字符串的第一段的长度，它的最后一段的长度必须要小于等于对应段的长度，而中间部分必须完全相同。</p>
<p>所以我们可以考虑把每个操作看成是 <span class="math inline">\((c_i,x_i)\)</span> ，并且用 KMP 维护这个过程。</p>
<p>首先考虑怎么维护 <span class="math inline">\(fail\)</span> 数组。需要特别注意的是，因为我们现在使用增量法求答案（树结构的性质使然），所以这里的 <span class="math inline">\(fail\)</span> 定义为一个最长的后缀，使得该后缀的第一段的长度大于等于整个字符串的第一段的长度，且剩下部分和整个字符串后面部分<strong>完全相同</strong>。这和一般的 <span class="math inline">\(fail\)</span> 略微有点区别。</p>
<p>我们现在的操作是一个<strong>树结构</strong>，而 KMP <strong>暴力</strong>找 <span class="math inline">\(fail\)</span> 的复杂度是<strong>均摊</strong>的，所以我们在加入一个段的时候并不能直接暴力跳 <span class="math inline">\(fail\)</span> 指针。考虑设 <span class="math inline">\(nxt_{now,c,x}\)</span> 表示在节点 <span class="math inline">\(now\)</span>，加上 <span class="math inline">\(x\)</span> 的字符 <span class="math inline">\(c\)</span> 会跳到哪里，可以用主席树维护这个东西，即把 <span class="math inline">\(nxt_{now,c}\)</span> 看成是一个线段树，每次扫到一个儿子时把 <span class="math inline">\(nxt_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(nxt_{now,C}\)</span> 中的 <span class="math inline">\(X\)</span> 赋值成这个儿子即可。</p>
<p>需要特别注意的是，我们前面有【Border 的第一段的长度必须大于等于整个串的第一段的长度】，也就是说对于一个串，如果它的 <span class="math inline">\(fail\)</span> 需要考虑整个串的第一段的时候稍微有点特殊，直接把整个串的第一段看成是 <span class="math inline">\((c,x\sim 10000)\)</span> 的段即可。</p>
<p>这样我们就动态维护出了 <span class="math inline">\(fail\)</span> 数组，考虑通过这个来维护答案。</p>
<p>假设现在加入的段是 <span class="math inline">\((c,x)\)</span>。</p>
<p>把它的 <span class="math inline">\(fail\)</span> 树上到根的链拿出来，假设是一个这样的结构。其中 <span class="math inline">\((c,x_i)\)</span> 表示这个点下面有一个 <span class="math inline">\((c,x_i)\)</span> 的操作。<span class="math inline">\(length\)</span> 表示整个字符串到它这里的长度。</p>
<p><img src="https://s3.ax1x.com/2020/12/29/rbk5Mq.png" /></p>
<p>可以发现对于长度为 <span class="math inline">\([1,x1]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的 <span class="math inline">\(nxt\)</span> 长度是 <span class="math inline">\(length_{fail1}+i\)</span>。对于 <span class="math inline">\([x1+1,x2]\)</span> 的部分，第 <span class="math inline">\(i\)</span> 个的<span class="math inline">\(nxt\)</span> 的长度是 <span class="math inline">\(length_{fail2}+i\)</span>，以此类推。我们把这个长度给拆开，那么一部分是 <span class="math inline">\(length\)</span> 的和，一部分是 <span class="math inline">\(i\)</span> 的和。对于后者，只要求出其 <span class="math inline">\(fail\)</span> 链上最长的一个 <span class="math inline">\(x\)</span>，总和就是 <span class="math inline">\(\frac{x(x+1)}{2}\)</span>。对于前者，可以发现如果一个地方有多个选择，一定选择 <span class="math inline">\(length\)</span> 最长的一个，而我们整个过程是在树上遍历，每次往下走 <span class="math inline">\(length\)</span> 是单调不减的，所以可以类似于维护 <span class="math inline">\(fail\)</span>，用 <span class="math inline">\(len_{now,c,x}\)</span> 表示这个点 <span class="math inline">\(now\)</span> 一直往上跳 <span class="math inline">\(fail\)</span> 树，往下加 <span class="math inline">\(x\)</span> 的最大 <span class="math inline">\(length\)</span>，用主席树维护 <span class="math inline">\(len_{now,c}\)</span>，每次扫的一个儿子时把 <span class="math inline">\(len_{now,c}\)</span> 从 <span class="math inline">\(fail_{now}\)</span> 那里继承，假设它到该儿子的边是 <span class="math inline">\((C,X)\)</span>，那么直接把 <span class="math inline">\(len_{now,c}\)</span> 中的 <span class="math inline">\(1\sim X\)</span> 赋值成 <span class="math inline">\(length_{now}\)</span>。</p>
<p>需要注意的是，如果这个加入的段可以匹配整个串的第一段，如 <span class="math inline">\(abaa\)</span>，最后的那个 <span class="math inline">\(a\)</span> 就需要特判。稍加讨论即可。</p>
<p>这样就可以直接做了。时空复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>可持久化数据结构</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2019] 白兔之舞 题解</title>
    <url>/2021/01/29/HNOI2019-%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><del>白兔虐我千百遍，我待白兔如初恋。</del></p>
<p>随着单位根反演的普及，这道题或许会逐渐成为模板。</p>
<a id="more"></a>
<p>设 <span class="math inline">\(F_i\)</span> 表示走 <span class="math inline">\(i\)</span> 步到 <span class="math inline">\(y\)</span> 得到方案，那么显然有： <span class="math display">\[
F_i={L \choose i}A^i[x][y]
\]</span> 其中 <span class="math inline">\(A\)</span> 矩阵是给出的邻接矩阵 <span class="math inline">\(w\)</span>。（如果这个都不会还学什么单位根反演？）</p>
<p>设 <span class="math inline">\(G_x\)</span> 表示表示最终的 <span class="math inline">\(x\)</span> 的答案，那么显然 <span class="math inline">\(G_x=\sum_iF_i[i\text{ mod }k=x]\)</span>。括号内的内容等价于 <span class="math inline">\(k|i-x\)</span>。</p>
<p>直接套单位根反演，就有 <span class="math inline">\(G_x=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-xj}\sum_{i=0}^L{L \choose i}A^i[x][y]\omega_k^{ij}\)</span>。</p>
<p>不难发现后面一堆就是 <span class="math inline">\((A\omega_k^j+I)^L[x][y]\)</span>，直接矩阵快速幂算即可，设算出来的结果为 <span class="math inline">\(H_j\)</span>，那么原式就等于 <span class="math inline">\(\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-xj}H_j\)</span>。</p>
<p>按照 Bluestein 的套路，把 <span class="math inline">\(-xj\)</span> 拆成 <span class="math inline">\({j \choose 2}+{x \choose 2}-{j+x \choose 2}\)</span>，那么原式就为 <span class="math inline">\(\frac{1}{k}\omega_k^{x\choose 2}\sum_{j=0}^{k-1}\omega_k^{j \choose 2}H_j\cdot\omega_k^{j+x\choose 2}\)</span>，不难发现右边是一个减法卷积，直接任意模数 FFT 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line">LL n, k, L, x, y, mod;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL a, LL k)</span> </span>&#123;</span><br><span class="line">  LL re = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a % mod)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a % mod;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Prime[<span class="number">105</span>];</span><br><span class="line"><span class="function">LL <span class="title">Getwn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, tmp = mod - <span class="number">1</span>, sq = <span class="built_in">sqrt</span>(mod);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">2</span>; i &lt;= sq; ++i)</span><br><span class="line">    <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">      Prime[++cnt] = i;</span><br><span class="line">      <span class="keyword">while</span> (tmp % i == <span class="number">0</span>)</span><br><span class="line">        tmp /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (tmp != <span class="number">1</span>) Prime[++cnt] = tmp;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">2</span>; <span class="number">666</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; flag &amp;&amp; j &lt;= cnt; ++j)</span><br><span class="line">      <span class="keyword">if</span> (qpow(i, (mod - <span class="number">1</span>) / Prime[j]) == <span class="number">1</span>)</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> qpow(i, (mod - <span class="number">1</span>) / k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  LL a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        re.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">          re.a[i][j] += a[i][k] * A.a[k][j];</span><br><span class="line">        re.a[i][j] %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> LL &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        re.a[i][j] = a[i][j] * A % mod;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">  Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        re.a[i][j] = (a[i][j] + A.a[i][j]) % mod;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; E, I, F;</span><br><span class="line"><span class="function">Matrix <span class="title">Matrixqpow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Matrix re; re = I;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">LL A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FuckFuckTmd &#123;</span><br><span class="line">  <span class="keyword">double</span> <span class="keyword">const</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> M = <span class="number">32767</span>;</span><br><span class="line">  <span class="keyword">int</span> r[MAXN];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    Complex (<span class="keyword">double</span> _a = <span class="number">0</span>, <span class="keyword">double</span> _b = <span class="number">0</span>) &#123; a = _a, b = _b; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;A) &#123; <span class="keyword">return</span> Complex(a + A.a, b + A.b); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;A) &#123; <span class="keyword">return</span> Complex(a - A.a, b - A.b); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp;A) &#123; <span class="keyword">return</span> Complex(a * A.a - b * A.b, a * A.b + b * A.a); &#125;</span><br><span class="line">  &#125; omega[MAXN], A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN], H[MAXN];</span><br><span class="line">  LL RE[MAXN];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="keyword">int</span> len, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="keyword">if</span> (r[i] &gt; i)</span><br><span class="line">        swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> wn = len / i;</span><br><span class="line">      <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt; len; j += i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = j; k &lt; j + i / <span class="number">2</span>; ++k) &#123;</span><br><span class="line">          Complex x = a[k], y = a[k + i / <span class="number">2</span>] * omega[w];</span><br><span class="line">          a[k] = x + y;</span><br><span class="line">          a[k + i / <span class="number">2</span>] = x - y;</span><br><span class="line">          w = (w + op * wn + len) % len;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FUCKFFT</span><span class="params">(LL *a, <span class="keyword">int</span> lena, LL *b, <span class="keyword">int</span> lenb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; lena; ++i) &#123;</span><br><span class="line">      A[i].a = (a[i] &gt;&gt; <span class="number">15</span>) &amp; M;</span><br><span class="line">      B[i].a = a[i] &amp; M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; lenb; ++i) &#123;</span><br><span class="line">      C[i].a = (b[i] &gt;&gt; <span class="number">15</span>) &amp; M;</span><br><span class="line">      D[i].a = b[i] &amp; M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; lena + lenb - <span class="number">1</span>)</span><br><span class="line">      len &lt;&lt;= <span class="number">1</span>, ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (cnt - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">double</span> deg = <span class="number">2.0</span> * PI * i / len;</span><br><span class="line">      omega[i] = Complex(<span class="built_in">cos</span>(deg), <span class="built_in">sin</span>(deg));</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(A, len, <span class="number">1</span>), FFT(B, len, <span class="number">1</span>);</span><br><span class="line">    FFT(C, len, <span class="number">1</span>), FFT(D, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      F[i] = A[i] * C[i];</span><br><span class="line">      G[i] = A[i] * D[i] + B[i] * C[i];</span><br><span class="line">      H[i] = B[i] * D[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(F, len, <span class="number">-1</span>), FFT(G, len, <span class="number">-1</span>), FFT(H, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      RE[i] = LL(F[i].a / len + <span class="number">0.5</span>) % mod * (M + <span class="number">1</span>) % mod * (M + <span class="number">1</span>) % mod;</span><br><span class="line">      RE[i] = (RE[i] + LL(G[i].a / len + <span class="number">0.5</span>) % mod * (M + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">      RE[i] = (RE[i] + LL(H[i].a / len + <span class="number">0.5</span>) % mod) % mod;</span><br><span class="line">      RE[i] = (RE[i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LL ans[MAXN];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod; --x, --y;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; E.a[i][j];</span><br><span class="line">      I.a[i][j] = (i == j);</span><br><span class="line">    &#125;</span><br><span class="line">  LL wn = Getwn(), w = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> lenF = k, lenG = <span class="number">2</span> * k - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; lenF; ++i) &#123;</span><br><span class="line">    F = E * w + I;</span><br><span class="line">    F = Matrixqpow(F, L);</span><br><span class="line">    A[i] = F.a[x][y];</span><br><span class="line">    A[i] = A[i] * qpow(wn, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">    w = w * wn % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; lenG; ++i)</span><br><span class="line">    B[i] = qpow(wn, k - <span class="number">1l</span>l * i * (i - <span class="number">1</span>) / <span class="number">2</span> % k);</span><br><span class="line">  <span class="comment">// for (RI i = 0; i &lt; lenF; ++i)</span></span><br><span class="line">  <span class="comment">//   for (RI j = i; j &lt; lenG; ++j)</span></span><br><span class="line">  <span class="comment">//     ans[j - i] = (ans[j - i] + A[i] * B[j] % mod) % mod;</span></span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>, j = lenG - <span class="number">1</span>; i &lt; j; ++i, --j)</span><br><span class="line">    swap(B[i], B[j]);</span><br><span class="line">  FuckFuckTmd :: FUCKFFT(A, lenF, B, lenG);</span><br><span class="line">  LL *ans = FuckFuckTmd :: RE;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    LL val = ans[lenG - <span class="number">1</span> - i];</span><br><span class="line">    val = val * qpow(k, mod - <span class="number">2</span>) % mod * qpow(wn, <span class="number">1l</span>l * i * (i - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>单位根反演</tag>
        <tag>循环卷积</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2021 游记</title>
    <url>/2021/04/12/HNOI2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<a id="more"></a>
<p>时间总是流逝得很快，这已经是 Daniel_yuan 经历的第三次省选了。</p>
<p>这也是 Daniel_yuan 所能参加的最后一次省选了。</p>
<p>从懵懂、激动到沉稳，改变的是心态，不变的是实力。（划掉</p>
<h3 id="day--inf">Day -INF</h3>
<p>不知为啥明明活得挺开心的晚上睡眠质量还是不好。</p>
<p>要么就是睡不着要么就是做一些奇奇怪怪的梦。</p>
<p>每天早上都睡到考勤前，然后急急忙忙跑到学校。</p>
<h3 id="day--1">Day -1</h3>
<p>去某新开发的公园散心。</p>
<p>因为主路十分崎岖，而选择了一条大公路。结果就围着公园绕了半圈，啥都没看到 :(。</p>
<p>途中发现了一串楼梯就往上爬，越爬越离谱，到了山顶就变成泥泞小路了<del>（甚至怀疑走到了山顶洞人老家）</del>。</p>
<p>为了激励士气，教练和班主任一拍即合，决定让我们喊山。</p>
<p>然而因为大家都觉得谁喊谁尴尬，就没人打算喊。结果被教练教育了一顿（大概是因为教练尴尬 :)）</p>
<h3 id="day-0">Day 0</h3>
<p>早上强制要求制定计划，决定复习一波网络流+差分约束（要素察觉</p>
<p>但实际上效率并不高，算是半颓半学吧。</p>
<h3 id="day-1">Day 1</h3>
<p>紧张得 5 点多就醒了，迷迷糊糊睡到了出发时间。</p>
<p>到了考场，发现下载文件只有 <code>.vimrc</code>，用 <code>emacs</code> 的我在一瞬间有那么小慌，后来猛然发现配置文件就在主目录下……</p>
<p>T1 的保证 <span class="math inline">\(a_i\)</span> 有序感觉很有问题，直接 rush 线性做法，缝缝补补肝出来个，对上拍就没管了。</p>
<p>T2 发现一个数的约束只有三个，但是没什么想法，手玩了 <span class="math inline">\(m=2\)</span> 后发现 <span class="math inline">\(n,m\leq 3\)</span> 都不会手玩，只能自闭。</p>
<p>T3 随手转化一下就有 44 分了，发现是个动态图强连通性，感觉是个不会的模板，只能自闭。</p>
<p>然后……就这么以 <span class="math inline">\(100+30+44\)</span> 离场了。很是自闭。</p>
<p>考完之后吃完饭就在机房睡觉，回家之后也是半睡半醒，迷迷糊糊地一天就这么过去了。</p>
<h3 id="day-2">Day 2</h3>
<p>在家睡觉果然就是不一样，差点就睡过头了。</p>
<p>雨下得很大，颇有壮士一去兮不复返之势。</p>
<p>T1 sb 数据结构，脑抽用 <code>map</code> 存了个东西写了个 <span class="math inline">\(\log^3\)</span> 的做法。</p>
<p>T2 sb 状压 DP，但是更加 sb 的我写完搜索的部分分之后就死活肝不出来。</p>
<p>T3 压位暴力似乎显然，然后就直接 rush 了。</p>
<p>写完感觉很无聊，想也想不动，颓也不敢颓，就开始想下午回家怎么 happy。</p>
<p>考完自爆 <span class="math inline">\(100+60+75\)</span>。很是自闭。</p>
<p>下午和小伙伴们胡吃海喝、把酒言欢，紧张而又平淡的 HNOI 就这么结束了。</p>
<h3 id="day-3">Day 3</h3>
<p>没测民间数据，也没上你谷，感觉考完之后整个人都置身于 OI 之外了。</p>
<p>考后在机房整了好几次活。</p>
<h3 id="day-inf">Day INF</h3>
<p>成绩出了，<span class="math inline">\(100+30+44+95+60+40\)</span>，很是拉胯，但是靠着 NOIP 的发挥苟进了 A 队。</p>
<p>Daniel_yuan 的 OI 生涯又被续上了一命（+1s</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hall 定理学习笔记</title>
    <url>/2021/01/04/Hall-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>在网上学习了 Hall 定理后决定写这么个东西。</p>
<p>如有雷同或涉及侵权，请联系博主。</p>
<a id="more"></a>
<h3 id="定理内容">定理内容</h3>
<p>对于一个二分图，假设其左边节点个数小于等于右边节点个数，并设左边节点个数为 <span class="math inline">\(X\)</span>，右边为 <span class="math inline">\(Y\)</span>。</p>
<p>若从左边选出任意 <span class="math inline">\(k\)</span> 个节点，右边都有至少 <span class="math inline">\(k\)</span> 个节点与之相连，那么该二分图的最大匹配个数恰好为 <span class="math inline">\(X\)</span>。我们称满足这个条件的匹配为完美匹配。</p>
<p>为了方便，在下文中默认左边的节点数小于等于右边的节点数。</p>
<h3 id="证明">证明</h3>
<p>考虑从必要和充分两方面证明这个定理。</p>
<h4 id="必要性">1. 必要性</h4>
<p>如果一个二分图有完美匹配，且其不满足 Hall 定理。</p>
<p>那么对于左边某 <span class="math inline">\(k\)</span> 个节点，右边与之相连的点数小于 <span class="math inline">\(k\)</span>。</p>
<p>而根据假设，左边这 <span class="math inline">\(k\)</span> 个节点都匹配了右边 <span class="math inline">\(k\)</span> 个不同的节点，那么右边与之相连的点数至少为 <span class="math inline">\(k\)</span>。</p>
<p>前后两者是矛盾的，所以该假设不成立，故必要性得证。</p>
<h4 id="充分性">2. 充分性</h4>
<p>如果一个二分图满足 Hall 定理，且其没有完美匹配。</p>
<p>考虑分两个部分来证明它。</p>
<h5 id="part1.-若左边每个点的度数都大于等于-2">Part1. 若左边每个点的度数都大于等于 <span class="math inline">\(2\)</span>。</h5>
<p>我们在左边可以找到一个没有匹配的点 <span class="math inline">\(l_1\)</span>。它一定会连接到一个右边的节点 <span class="math inline">\(r_1\)</span>。</p>
<p>如果 <span class="math inline">\(r_1\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p>
<p>否则 <span class="math inline">\(r_1\)</span> 会匹配到一个左边的节点 <span class="math inline">\(l_2\)</span>。那么 <span class="math inline">\(l_2\)</span> 一定会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p>
<p>如果 <span class="math inline">\(r_2\)</span> 没有被匹配，那么就找到了一条增广路，与假设矛盾。</p>
<p>否则……</p>
<p>这样会一直循环下去，而点数有限，那么必然终止，所以整体与假设矛盾。</p>
<h5 id="part2.-若左边有点的度数等于-1">Part2. 若左边有点的度数等于 <span class="math inline">\(1\)</span></h5>
<p>有点的度数为 <span class="math inline">\(1\)</span> 就可能出现一个问题，就是上述证明的 <span class="math inline">\(l_2\)</span> 若度数为 <span class="math inline">\(1\)</span>，则不会连接到另一个右边的节点 <span class="math inline">\(r_2\)</span>。</p>
<p>但其实这样也是可以证明的。假设 <span class="math inline">\(l_1\)</span> 的度数为 <span class="math inline">\(1\)</span>，那么若 <span class="math inline">\(l_2\)</span> 的度数也为 <span class="math inline">\(1\)</span>，就会因为它们连接着同一个点 <span class="math inline">\(r_1\)</span> 而不满足 Hall 定理矛盾（如果左边选择这两个点，右边只有一个点与之相连）</p>
<p>假设 <span class="math inline">\(l_1\)</span> 的度数大于等于 <span class="math inline">\(2\)</span>，而 <span class="math inline">\(l_2\)</span> 的度数为 <span class="math inline">\(1\)</span>。那么我们可以把这条增广路反向，这样 <span class="math inline">\(l_2\)</span> 就变成了 <span class="math inline">\(l_1\)</span>，再用上面的证明即可。</p>
<hr />
<h3 id="引申">引申</h3>
<p>定义二分图的 K-完美匹配 为二分图有 <span class="math inline">\(K\)</span> 个完全不相交的完美匹配。</p>
<p>现在考虑该图要满足什么条件才有 K-完美匹配。</p>
<p>这个题是一个经典问题，有一个很经典的网络流做法，博主根据这个做法以及一些分析归纳出了下列定理：（可能是个经典定理，但是博主找不到）</p>
<p>对于一个二分图，如果可以通过删边的操作，使得左边的每个点的度数都为 <span class="math inline">\(K\)</span>，且右边的每个点的度数都小于等于 <span class="math inline">\(K\)</span>，那么一定存在 K-完美匹配。</p>
<h3 id="证明-1">证明</h3>
<p>还是从必要和充分两方面证明这个引理。</p>
<h4 id="充分性-1">1. 充分性</h4>
<p>考虑用归纳法证明。</p>
<h5 id="先证明-k1-成立">1. 先证明 <span class="math inline">\(K=1\)</span> 成立。</h5>
<p>从左边任选一个点，然后找到它相连的点，匹配。</p>
<p>根据前提条件，这条边是这两个点连出的唯一一条边。</p>
<p>这样这个问题就变成了一个条件不变规模更小的问题。</p>
<p>一直这么下去就可以得到一个完美匹配。</p>
<h5 id="假设证明了-kleq-x-1-成立再证明-kx-成立">2. 假设证明了 <span class="math inline">\(K\leq x-1\)</span> 成立，再证明 <span class="math inline">\(K=x\)</span> 成立。</h5>
<p>首先这个图满足 Hall 定理。因为对于左边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而右边的点的度数的上限是 <span class="math inline">\(x\)</span>，那么右边至少会有 <span class="math inline">\(k\)</span> 个点与其相连。</p>
<p>把左边所有点和右边所有的度数恰好为 <span class="math inline">\(x\)</span> 的点及它们之间的边拿出来构成一个新图，此时的这张图是<strong>右边的点数小于等于左边的点数的</strong>，那么对于右边任意 <span class="math inline">\(k\)</span> 个点，其有的边的数目是 <span class="math inline">\(k\times x\)</span> 条，而左边的点的度数上限是 <span class="math inline">\(x\)</span>，那么至少左边会有 <span class="math inline">\(k\)</span> 个点与其相连。</p>
<p>这样的话对于这个新图，就存在一个完美匹配。构造出这个完美匹配后，回到原图，保留新图的匹配，再用匈牙利算法形成一个原图的完美匹配。然后把这个完美匹配删掉，剩下的图恰好满足 <span class="math inline">\(K=x-1\)</span> 的性质，而通过归纳，<span class="math inline">\(K=x-1\)</span> 已经被证明，故充分性得证。</p>
<h4 id="必要性-1">2. 必要性</h4>
<p>若左边存在一个点的度数小于 <span class="math inline">\(K\)</span>，那么显然不存在一个 K-完美匹配。不然一定存在一种删边方式使得左边的度数等于 <span class="math inline">\(K\)</span>。</p>
<p>如果删边之后左边存在一个点的度数大于 <span class="math inline">\(K\)</span>，那么 K-完美匹配 后一定会剩下一些边，那么把这些便删掉也不影响判断。</p>
<p>那么现在可能使得该定理必要性不存在的就只有：左边的所有点的度数为 <span class="math inline">\(K\)</span>，且右边存在一个点的度数大于 <span class="math inline">\(K\)</span>，且该二分图存在 K-完美匹配。</p>
<p>但是你会发现上述情况是不可能存在的，因为在删除 K-完美匹配 的边后，左边的点的度数就都变成了 <span class="math inline">\(0\)</span>，而右边此时会存在至少一个点的度数大于 <span class="math inline">\(0\)</span>（因为每一个匹配最多让一个点的度数减一），这是矛盾的。</p>
<p>故必要性得证。</p>
<p>这就能解释对于二分图的 K-完美匹配 的判定，为何可以用【 <span class="math inline">\(S\)</span> 向左边的点连流量为 <span class="math inline">\(K\)</span> 的边，在每个二分图上的边中左边的点向右边的点连流量为 <span class="math inline">\(1\)</span> 的边，右边的点向 <span class="math inline">\(T\)</span> 连流量为 <span class="math inline">\(K\)</span> 的边，看网络流的结果中左边的点是否都满流】来判断了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOI2018] 机械娃娃 题解</title>
    <url>/2021/03/18/IOI2018-%E6%9C%BA%E6%A2%B0%E5%A8%83%E5%A8%83-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/problem/408">题面在此</a>。</p>
<a id="more"></a>
<p>第一想法是对于某个触发器，它的出边是固定的，如果它的出边集合大小大于 <span class="math inline">\(1\)</span> 的话，就只能连到开关上。所以就考虑用开关来表示一个触发器的所有出边。</p>
<p>不难构造出一个完满二叉树的结构。按照题目顺序把前几个叶子和最后一个叶子连到这个触发器的出边上，中间的叶子就全部回到根。类似下图，其中 <span class="math inline">\(T\)</span> 集合为某个触发器的出边集合。（其中 <span class="math inline">\(1&#39;\)</span> 就是 <span class="math inline">\(1\)</span>，画图原因），路线就是 <span class="math inline">\(T1,T2,(1),T3\)</span>，走完之后所有开关都在 <code>X</code>。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13304049297/0.png" /></p>
<p>仔细想想可以发现我们并不需要对每个点都开一个完满二叉树，我们完全可以只用一个完满二叉树来存储所有的出边。类似下图，其中 <span class="math inline">\(A\)</span> 是给定序列。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13304060750/0.png" /></p>
<p>路线就是 <span class="math inline">\(A0,A1,A2,...\)</span>。</p>
<p>这样我们需要 <span class="math inline">\(A\)</span> 序列长度为 <span class="math inline">\(2\)</span> 的整数次方，最坏情况我们不能接受。</p>
<p>考虑 <span class="math inline">\(M=1\)</span> 的部分分，我们可以构造出来一个这样的结构，其中方点是开关。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13304110559/0.png" /></p>
<p>我们仅用了 <span class="math inline">\(3\)</span> 个开关，就使得 <span class="math inline">\(U\)</span> 可以被到达 <span class="math inline">\(7\)</span> 次。</p>
<p>考虑每个开关的 <code>X</code> 边贡献，不难发现在图中标号为 <span class="math inline">\(v\)</span> 的开关的 <code>X</code> 边会经过 <span class="math inline">\(2^v\)</span> 次。所以我们可以通过对 <code>X</code> 边的控制来使得 <span class="math inline">\(U\)</span> 可以被经过 <span class="math inline">\([0,2^3-1]\)</span> 次。</p>
<p>我们把每个 <code>X</code> 边所链接的都改成一个上述的完满二叉树，我们可以通过对 <span class="math inline">\(N\)</span> 的二进制拆分来决定每个完满二叉树存在与否，就可以通过 <span class="math inline">\(N+\log_2N\)</span> 实现按照顺序遍历 <span class="math inline">\(A\)</span> 序列。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>妙题</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI 题题题题</title>
    <url>/2021/05/02/NOI-%E9%A2%98%E9%A2%98%E9%A2%98%E9%A2%98/</url>
    <content><![CDATA[<p><del>因为有四年所以有四个题字。</del></p>
<p>都是博主的个人想法，不保证做法简洁。</p>
<a id="more"></a>
<hr />
<h3 id="noi-2017">NOI 2017</h3>
<h4 id="整数">整数</h4>
<p>模拟。</p>
<p>发现要快速进退位，于是用个线段树维护区间是不是全 <code>1</code> 或者全 <code>0</code>，然后二分。</p>
<p>发现二分可以在线段树里面，所以直接线段树上二分。</p>
<p>发现一个线段树节点只维护一位效率太低，于是直接压位。</p>
<p>复杂度 <span class="math inline">\(O(n\log\frac{30n}{\omega})\)</span>。</p>
<h4 id="蚯蚓排队">蚯蚓排队</h4>
<p>模拟。</p>
<p>只看修改直接暴力的复杂度就是对的，因为均摊 <span class="math inline">\(nk\)</span> 个串每个串长度 <span class="math inline">\(O(k)\)</span>，而 <code>2</code> 操作会增加最多 <span class="math inline">\(k^2\)</span> 个长度为 <span class="math inline">\(O(k)\)</span> 的串，而 <code>2</code> 操作只有 <span class="math inline">\(10^3\)</span> 个。</p>
<p>考虑怎么查询。愚蠢的博主看到收尾加删就直接上 SAM 了，殊不知直接哈希就可以了。查询复杂度是 <span class="math inline">\(O(|S|)\)</span> 的。</p>
<h4 id="泳池">泳池</h4>
<p>求限制下边界的极大子矩形直接上笛卡尔树即可。</p>
<p>直接设 <span class="math inline">\(f_{i,x,0/1}\)</span> 表示长度为 <span class="math inline">\(i\)</span> 的区间，下边界都不是危险的，高度最小值为 <span class="math inline">\(x\)</span>，大小达没达到 <span class="math inline">\(k\)</span> 的方案数。转移的时候枚举最大值的位置，然后对 <span class="math inline">\(x\)</span> 后缀和即可。卡下 <span class="math inline">\(x\)</span> 的上界复杂度就是调和级数，<span class="math inline">\(O(k^2\ln k)\)</span>。</p>
<p>然后把每个 <span class="math inline">\(f\)</span> 后面绑上一个下边界是危险的格子对 <span class="math inline">\(n\)</span> 跑 DP，设 <span class="math inline">\(dp_{i,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 列，当前大小达没达到 <span class="math inline">\(k\)</span> 的方案数。枚举最后一段的大小即可。</p>
<p><span class="math inline">\(K\leq 1000\)</span> 显然不能矩阵快速幂，考虑常系数齐次线性递推，不用 NTT 直接暴力多项式即可。复杂度 <span class="math inline">\(O(k^2\log n)\)</span>。</p>
<h4 id="游戏">游戏</h4>
<p>如果没有 <code>x</code> 直接大力 2-SAT。</p>
<p>有 <code>x</code> 就枚举一下 <code>x</code> 到底取什么。</p>
<p>暴力一点就 <span class="math inline">\(3^k\)</span>，实测可过，但实际上只需要枚举 <span class="math inline">\(2^k\)</span> 就可以包含所有可能状态。</p>
<p>复杂度 <span class="math inline">\(O(2^k(2n+2m))\)</span>。</p>
<h4 id="蔬菜">蔬菜</h4>
<p>正难则反。以退为进。</p>
<p>把退菜变成进菜问题就容易很多。直接整个俩堆即可，一个放 <span class="math inline">\(x=0\)</span> 的，一个放每天都在进菜且菜的 <span class="math inline">\(x&gt;1\)</span> 的。前者用一个少一个，所以直接取出前 <span class="math inline">\(m\)</span> 个来。后者取出前 <span class="math inline">\(m\)</span> 个来后，因为每个菜在这一天至少进一个，所以也至少有 <span class="math inline">\(m\)</span> 个，在这 <span class="math inline">\(2m\)</span> 大的里面选 <span class="math inline">\(m\)</span> 大的即可。</p>
<p>这样还是暴力了点，因为询问太多了。</p>
<p>不能发现第 <span class="math inline">\(k\)</span> 天的答案必然包含第 <span class="math inline">\(k-1\)</span> 天的。因为第 <span class="math inline">\(k\)</span> 天能用的菜第 <span class="math inline">\(k-1\)</span> 天也能用。所以从第 <span class="math inline">\(k\)</span> 天推到第 <span class="math inline">\(k-1\)</span> 天直接删掉 <span class="math inline">\(m\)</span> 个菜即可。</p>
<p>复杂度 <span class="math inline">\(O(nm\log n)\)</span>。</p>
<h4 id="分身术">分身术</h4>
<p>毒瘤计算几何。暴力水 <span class="math inline">\(20\)</span> 分得了。</p>
<p>对于 <span class="math inline">\(K=1\)</span>，直接预处理。凸包上第 <span class="math inline">\(x\)</span> 个点删掉之后，只有极角序在凸包上第 <span class="math inline">\(x-1\)</span> 到 <span class="math inline">\(x+1\)</span> 个点之间的点可能会在凸包上。每个点只会被扫两次，复杂度正确。</p>
<p>懒得复读题解。</p>
<h4 id="总结">总结</h4>
<p>考察算法全面，类型新颖，部分分足，区分度高，不失为一套好 NOI 题。</p>
<p><del>正经的总结懒得写。</del></p>
<hr />
<h3 id="noi-2018">NOI 2018</h3>
<h4 id="归程">归程</h4>
<p>Kruskal 重构树 + Dijkstra 最短路 + 树上倍增。</p>
<p>懂的都懂。</p>
<h4 id="冒泡排序">冒泡排序</h4>
<p>把所有 <span class="math inline">\(p_i&gt; i\)</span> 和 <span class="math inline">\(p_i\leq i\)</span> 的拿出来形成两个序列，这两个序列必须都是单调递增的。</p>
<p>考虑 DP 前者，后者直接把剩下的数 <code>sort</code> 即可。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 个数，前缀最大值为 <span class="math inline">\(j\)</span> 的方案数。如果当前点不放数，就 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}\)</span>，否则当前点放 <span class="math inline">\(j\)</span>，那么就有 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,k}(k&lt;j)\)</span>。</p>
<p>对于求答案，类似数位 DP，强制一个前缀等于 <span class="math inline">\(q\)</span>，接下来的那一位强制大于 <span class="math inline">\(q\)</span>，注意到这里需要强制字典序大小，所以需要用到容斥，即 <span class="math inline">\(p_i&gt;i\)</span> 的序列个数减去 <span class="math inline">\(p_i&gt;i\)</span> 的序列中不包含 <span class="math inline">\(i\)</span> 的序列个数。这里可以直接调用 DP 值。</p>
<p>考虑优化 DP。其中 <span class="math inline">\(f_{i,j}\)</span> 相当于是把 <span class="math inline">\(j\sim n\)</span> 填到 <span class="math inline">\(i\sim n\)</span> 中，一个位置要么不放要么 <span class="math inline">\(p_i\leq i\)</span> 的方案数。考虑把空位全部归给后面的数，在 <span class="math inline">\(n+1\)</span> 放一个标志符。这样就相当于每个数要分配一个数 <span class="math inline">\(x\)</span>，其中 <span class="math inline">\(x=0\)</span> 表示不放，<span class="math inline">\(x&gt;0\)</span> 表示占用 <span class="math inline">\(x\)</span> 个位置，且在第 <span class="math inline">\(x\)</span> 位上放这个数。投影到平面直角坐标系上就是从 <span class="math inline">\((j,i)\)</span> 走到 <span class="math inline">\((n+1,n)\)</span> 不能越过 <span class="math inline">\(y=x+1\)</span> 的方案数，这是经典容斥。</p>
<h4 id="你的名字">你的名字</h4>
<p>大力 SAM 加线段树合并。</p>
<p>求解过程就是先对该串建 SAM 去重，每个右端点有一个 <span class="math inline">\([1,l1]\)</span> 的左端点限制。</p>
<p>然后放在大串的 SAM 上查，每个右端点有一个 <span class="math inline">\([l2,i]\)</span> 的左端点限制。</p>
<p>然后就可以求出来每个左端点的范围了。</p>
<p>然后直接计算即可。</p>
<h4 id="屠龙勇士">屠龙勇士</h4>
<p>细节比较多的白给 exCRT。</p>
<p>需要特别注意 exCRT 部分的细节实现。</p>
<p>反正就一模板加细节题。</p>
<h4 id="情报中心">情报中心</h4>
<p>测试点 <span class="math inline">\(1\sim 4\)</span> 白给分。</p>
<p><span class="math inline">\(c_i=0\)</span> 有交就行，求出每条边的最长次长链即可。</p>
<p>剩下的差不多得了。</p>
<h4 id="多边形">多边形</h4>
<p>前 <span class="math inline">\(20\)</span> 状压 DP 白给分。</p>
<p>考虑 <span class="math inline">\(K=1\)</span>，不难发现走过的叶子一定是连续的。不然在中间的叶子就被困住了。</p>
<p>所以直接枚举第一个经过的叶子，最后经过的叶子就是它后面的那个叶子，剩下的部分就要求每个子树可以从最小标号的叶子进去，从最大标号的叶子出来且所有点都遍历到。</p>
<p>考虑 DP，设 <span class="math inline">\(f_{i,0/1,0/1,0/1}\)</span> 表示节点 <span class="math inline">\(i\)</span> 的子树，<span class="math inline">\(i\)</span> 号节点有没有被遍历到，<span class="math inline">\(i\)</span> 号节点有没有属于一个往下走到当前子树最小标号的叶子的路径，<span class="math inline">\(i\)</span> 号节点有没有属于一个从当前子树最大标号的叶子往上走的路径，大力讨论转移即可。</p>
<p>枚举之后，树就被切成了森林，每个森林 <span class="math inline">\(f_{root,1,0,0}\)</span> 的乘积就是答案。</p>
<p><span class="math inline">\(50\)</span> 差不多了。</p>
<h4 id="总结-1">总结</h4>
<p>考察算法全面，类型新颖，部分分足，区分度高，不失为一套好 NOI 题。</p>
<p><del>正经的总结懒得写。</del></p>
<hr />
<h3 id="noi-2019">NOI 2019</h3>
<h4 id="回家路线">回家路线</h4>
<p><del>之前不小心把这题漏了。</del></p>
<p>按照时间排序之后 DP。</p>
<p>一脸可以优化的样子。</p>
<h4 id="机器人">机器人</h4>
<p>区间 DP 显然。</p>
<p>设 <span class="math inline">\(f_{l,r,x}\)</span> 表示区间 <span class="math inline">\(l,r\)</span> 且最大值上限为 <span class="math inline">\(x\)</span> 的方案数。因为题目限制有用的 <span class="math inline">\(l,r\)</span> 很少。而 <span class="math inline">\(x\)</span> 可以做前缀和。</p>
<p>可以发现 <span class="math inline">\(f_{p,p}\)</span> 的前缀和在值域上是一个一次三段分段函数。所以 <span class="math inline">\(f_{l+1,r}\)</span> 是一个二次五段分段函数，故 <span class="math inline">\(f_{l,l+1}\)</span> 的前缀和是一个三次分段函数。</p>
<p>所以 <span class="math inline">\(f_{l,r}\)</span> 是一个 <span class="math inline">\(r-l+1\)</span> 次分段函数，且段数为 <span class="math inline">\(O(r-l+1)\)</span> 级别。</p>
<p>维护多项式不好求前缀和以及乘法，但是可以直接维护 <span class="math inline">\(O(n)\)</span> 个点值，需要求某个具体点的点值的时候直接拉格朗日插值即可。为了方便维护的点值可以连续，插值的复杂度就是 <span class="math inline">\(O(n\log mod)\)</span>，因为要求逆元。</p>
<p>似乎有效的 <span class="math inline">\(l,r\)</span> 个数是 <span class="math inline">\(O(n)\)</span> 级别的，所以总复杂度大约是 <span class="math inline">\(O(n^3\log mod)\)</span> 的。当然可以预处理逆元降低一些复杂度。</p>
<h4 id="序列">序列</h4>
<p>模拟费用流入坑题。</p>
<p>冷静分析不难，细节稍多。</p>
<p><a href="https://daniel-yuan.github.io/2021/01/26/NOI2019-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/">看我看我看我</a></p>
<p><del>才不会告诉你是博主懒</del>。</p>
<h4 id="弹跳">弹跳</h4>
<p>KD-Tree 优化最短路。</p>
<p>众所周知线段树可以优化一维最短路。</p>
<p>为了让空间不炸，所以用 KD-Tree 优化二维最短路。</p>
<p>时间复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>，空间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h4 id="斗主地">斗主地</h4>
<p>期望 DP。</p>
<p>不难发现两堆牌顺序不变，剩下组合的所有情况出现的概率都是相同的。</p>
<p>所以直接大力 DP，40 分有手就行。</p>
<p>考虑优化，打表可以发现一次函数的期望还是一次函数。大胆猜测二次函数的期望还是二次函数。随便写写就过了。</p>
<p>考虑证明。先考虑 <span class="math inline">\(f(i)=i\)</span>，即 <span class="math inline">\(f(i)=c+di\)</span>。设新的 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(F\)</span>。下面先讨论左半部分，设其大小为 <span class="math inline">\(L\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
{n\choose L}F(x)&amp;=\sum_{i=1}^L{x-1\choose i-1}{n-x\choose L-i}(c+di)\\
&amp;=c\sum_{i=1}^L{x-1\choose i-1}{n-x\choose L-i}+d\sum_{i=1}^Li{x-1\choose i-1}{n-x\choose L-i}\\
&amp;=c{n-1\choose L-1}+d\sum_{i=1}^L(i-1){x-1\choose i-1}{n-x\choose L-i}+d\sum_{i=1}^L{x-1\choose i-1}{n-x\choose L-i}\\
&amp;=(c+d){n-1\choose L-1}+d\sum_{i=1}^L(x-1){x-2\choose i-2}{n-x\choose L-i}\\
&amp;=(c+d){n-1\choose L-1}+d(x-1){n-2\choose L-2}
\end{aligned}
\]</span></p>
<p>可以发现 <span class="math inline">\(F(x)-F(x-1)\)</span> 是定值。所以 <span class="math inline">\(F\)</span> 也是一个一次函数。</p>
<p>类似的，应该也可以证明二次函数的性质。</p>
<h4 id="i-君的探险">I 君的探险</h4>
<p>只会 <span class="math inline">\(68\)</span>，无了。</p>
<p>前面的 <span class="math inline">\(20\)</span> 分有手就行。</p>
<p>对于后面的 ABCD，有一个通用的但是没有办法扩展的做法。</p>
<p>考虑二进制分组，这样对每个点可以求出与它连边的点的异或和。</p>
<p>对于 A，每个点度数只有 <span class="math inline">\(1\)</span> 直接输出。</p>
<p>对于 B，从后往前扫，当前点 <span class="math inline">\(x\)</span> 的异或和 <span class="math inline">\(y\)</span> 就是小于它的唯一与它连边的点，然后把 <span class="math inline">\(y\)</span> 异或和异或上 <span class="math inline">\(x\)</span>。</p>
<p>对于 C，全部点亮一遍，叶子的状态不会发生改变。然后直接一遍推。</p>
<p>对于 D，考虑一层一层剥叶子。先考虑所有点，如果一个点 <span class="math inline">\(x\)</span> 和它的异或和 <span class="math inline">\(y\)</span> 真的有边，且加上这条边之后 <span class="math inline">\(x\)</span> 已经记录完了，那么 <span class="math inline">\(x\)</span> 就是叶子。然后就剥完了一层叶子。对于第二层，扫所有点复杂度就假了，但是这一层的叶子一定和上一层的叶子有边，所以就只用考虑那些点。这个过程每个点的贡献都是自己一次，自己的爹一次，复杂度正确。</p>
<p>后面的就不会了，但是前面的 <span class="math inline">\(68\)</span> 分简洁好想，后面的 <span class="math inline">\(32\)</span> 分怎么想都想不出来，这 <span class="math inline">\(32\)</span> 分不要也罢。</p>
<h4 id="总结-2">总结</h4>
<p>考察算法全面，类型新颖，部分分足，区分度高，不失为一套好 NOI 题。</p>
<p><del>正经的总结懒得写。</del></p>
<hr />
<h3 id="noi-2020">NOI 2020</h3>
<h4 id="美食家">美食家</h4>
<p>暴力 DP 有手就行。</p>
<p>矩阵优化显然。</p>
<p>直接矩阵快速幂优化，复杂度三次方不得行。</p>
<p>发现转移都是向量乘矩阵，预处理 <span class="math inline">\(2^t\)</span> 的矩阵之后，在转移的时候直接平方复杂度的向量乘矩阵即可。</p>
<h4 id="命运">命运</h4>
<p><span class="math inline">\(O(n^2)\)</span> DP 显然。</p>
<p>考虑线段树合并优化 DP 转移。</p>
<p>线段树下标表示的就是 DP 第二维的下标。</p>
<p>合并的时候 <span class="math inline">\(f_{now,i}\)</span> 乘的是 <span class="math inline">\(f_{son,j}(j\leq i)\)</span>，<span class="math inline">\(f_{son,i}\)</span> 乘的是 <span class="math inline">\(f_{now,j}(j&lt;i)\)</span>。</p>
<p>在线段树合并的时候，同时下传当前位置左边的 DP 值的和。那么在合并到指定位置的时候，需要乘的系数就已经求出来了。</p>
<p>因为 DP 问题，这个线段树还需要维护区间求和，区间乘，单点赋值等，但都不难写，唯一需要注意的是需要先合并右儿子再合并左儿子，因为左对右有影响。</p>
<p>复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h4 id="时代的眼泪">时代的眼泪</h4>
<p>大力四维莫队 <span class="math inline">\(O(n^{\frac{7}{4}})\)</span> 加上一个人均特殊性质 A 就有 <span class="math inline">\(52\)</span> 分了。</p>
<p>根号算法爬。</p>
<h4 id="制作菜品">制作菜品</h4>
<p>厉害的构造题。</p>
<p>特殊性质有大用。</p>
<p><a href="">稍后填坑，先咕着</a></p>
<h4 id="超现实树">超现实树</h4>
<p>厉害的思维题。</p>
<p>特殊性质有大用。</p>
<p><a href="">稍后填坑，先咕着</a></p>
<h4 id="翻修道路">翻修道路</h4>
<p>菜鸡博主不会弦图。</p>
<p>不会弦图的 OIer 大型自闭现场。</p>
<p>爆零得了，不在乎这几分。</p>
<h4 id="总结-3">总结</h4>
<p>考察算法全面，类型新颖，部分分足，区分度高，不失为一套好 NOI 题。</p>
<p><del>正经的总结懒得写。</del></p>
<hr />
<p>不放代码了，不然显得博客又臭又长。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2016] 循环之美 题解</title>
    <url>/2021/01/26/NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>手玩发现，一个极简分数，如果其分母和进制的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(1\)</span>，那么就符合题意。</p>
<p>那么就变成了求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\)</span>。</p>
<p>其实这个求和式的化简并不难，只是需要多发现式子之间的联系。</p>
<a id="more"></a>
<h4 id="展开-ij1">1. 展开 <span class="math inline">\([(i,j)=1]\)</span>。</h4>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\\
=&amp;\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor\sum_{j=1}^{\lfloor\frac{m}{t}\rfloor}[(tj,k)=1]\\
=&amp;\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor[(t,k)=1]\sum_{a|k}\mu(a)\lfloor\frac{m}{ta}\rfloor\\
=&amp;\sum_{a|k}\mu(a)\sum_{t=1}^n\mu(t)\lfloor\frac{n}{t}\rfloor[(t,k)=1]\lfloor\frac{m}{ta}\rfloor
\end{aligned}
\]</span></p>
<p>后面显然可以整除分块。但是分块后需要求 <span class="math inline">\(\sum_{i=1}^n\mu(i)[(i,k)=1]\)</span>。到在这里博主就不会了，因为这个式子看起来不可推。但是实际上设这个为 <span class="math inline">\(g(n,k)\)</span>，稍加整理： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\mu(i)[(i,k)=1]\\
=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^{\lfloor\frac{n}{a}\rfloor}\mu(ia)\\
=&amp;\sum_{a|k}\mu^2(a)\sum_{i=1}^{\lfloor\frac{n}{a}\rfloor}\mu(i)[(i,a)=1]\\
=&amp;\sum_{a|k}\mu^2(a)g(\lfloor\frac{n}{a}\rfloor,a)
\end{aligned}
\]</span> 这个式子暴力推，<span class="math inline">\(g\)</span> 到边界亚线性筛。</p>
<h4 id="展开-ik1">2. 展开 <span class="math inline">\([(i,k)=1]\)</span>。</h4>
<p>博主一开始没有想到展开这个，但是这样推相对简单。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\sum_{j=1}^m[(j,k)=1][(i,j)=1]\\
=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac{m}{a}\rfloor}[(i,ja)=1]\\
=&amp;\sum_{a|k}\mu(a)\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac{m}{a}\rfloor}[(i,j)=1][(i,a)=1]
\end{aligned}
\]</span></p>
<p>可以发现最后的式子和第一个式子很像，式子答案为 <span class="math inline">\(f(n,m,k)\)</span>，那么就有 <span class="math inline">\(f(n,m,k)=\sum_{a|k}f(\lfloor\frac{m}{a}\rfloor,n,a)\)</span>。到边界直接算即可。</p>
<hr />
<p>可以发现对不同的地方展开，有两个截然不同的结果，虽然最后都可以得到正确答案，但是会有不同的推导难度。</p>
<p>而不管用什么，最重要的部分都是等效替代，也就是说把某个求和式设成函数 <span class="math inline">\(f\)</span>，然后在推导中注意看式子中有没有重新得到 <span class="math inline">\(f\)</span>，然后就可以得到 <span class="math inline">\(f\)</span> 之间的递推式了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2019] 序列 题解</title>
    <url>/2021/01/26/NOI2019-%E5%BA%8F%E5%88%97-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>简单学习了模拟费用流之后一直有点迷糊，后来在交流中似乎悟到了些什么。</p>
<p>能推出这道题挺开心的，而且对模拟费用流有了更进一步的理解。</p>
<a id="more"></a>
<p>首先这个题目很容易建出费用流的图。</p>
<p>考虑每次增广都会新增一对 <span class="math inline">\(a,b\)</span>，那么我们就需要起点向 <span class="math inline">\(\{a\}\)</span> 连边，<span class="math inline">\(\{b\}\)</span> 向终点连边，这样一条路径就一定会对应一对 <span class="math inline">\(a,b\)</span>。</p>
<p>对于 <span class="math inline">\(K\)</span> 个下标的限制，直接对起点拆点。</p>
<p>而对于至少的限制，我们把其转化成最多，即最多 <span class="math inline">\(K-L\)</span> 对 <span class="math inline">\(c,d\)</span> 不相同，这样也可以用一条流量为 <span class="math inline">\(K-L\)</span> 的边表示。</p>
<p>而对于相同和不同的限制，如果相同那么显然可以直接流，即 <span class="math inline">\(a_i\)</span> 向 <span class="math inline">\(b_i\)</span> 连边。而如果不同，那么就需要通过上一行的边，所以建立两个辅助节点 <span class="math inline">\(L,R\)</span>，<span class="math inline">\(L\)</span> 向 <span class="math inline">\(R\)</span> 连 <span class="math inline">\(K-L\)</span> 的边，然后 <span class="math inline">\(\{a\}\)</span> 向 <span class="math inline">\(L\)</span> 连边，<span class="math inline">\(R\)</span> 向 <span class="math inline">\(\{b\}\)</span> 连边。</p>
<p>因为我们在增广的同时要保证最大，所以在所有起点向 <span class="math inline">\(\{a\}\)</span> 的边上和 <span class="math inline">\(\{b\}\)</span> 向终点的边上加上他们的权值的费用，其它边的费用为 <span class="math inline">\(0\)</span>，这样就有了一个费用流的模型。</p>
<p><a href="https://imgchr.com/i/sXiJIJ"><img src="https://s3.ax1x.com/2021/01/26/sXiJIJ.png" /></a></p>
<p>直接费用流肯定过不了，考虑模拟费用流。</p>
<p>我们可以发现一共有六种增广方式。 <span class="math display">\[
\begin{aligned}
&amp;S \rightarrow A \rightarrow B \rightarrow T\\
&amp;S \rightarrow A \rightarrow L \rightarrow R \rightarrow B \rightarrow T\\
&amp;S \rightarrow A_1 \rightarrow L \rightarrow A_2 \rightarrow B_2 \rightarrow T\\
&amp;S \rightarrow A_1 \rightarrow B_1 \rightarrow R \rightarrow B_2 \rightarrow T\\
&amp;S \rightarrow A_1 \rightarrow L \rightarrow A_2 \rightarrow B_2 \rightarrow R \rightarrow B_3 \rightarrow T\\
&amp;S \rightarrow A_1 \rightarrow B_1 \rightarrow R \rightarrow B_2 \rightarrow A_2 \rightarrow L \rightarrow A_3 \rightarrow B_3 \rightarrow T\\
\end{aligned}
\]</span> 在有下标的路径中，下标相同的点的位置相同。（如 <span class="math inline">\(A_1\)</span> 和 <span class="math inline">\(B_1\)</span> 的）</p>
<p>可以发现其中只有路径 <span class="math inline">\(2\)</span> 会经过 <span class="math inline">\(L\rightarrow R\)</span> 的边，所以我们可以先贪心把路径 <span class="math inline">\(2\)</span> 走完，然后再增广 <span class="math inline">\(L\)</span> 次。</p>
<p>考虑剩下的增广，设 <span class="math inline">\(P\)</span> 为没选的点的集合，<span class="math inline">\(Q\)</span> 为选了的点，且当前状态是用 <span class="math inline">\(L\rightarrow R\)</span> 边形成的集合，<span class="math inline">\(O\)</span> 为选了的点，且当前状态是用 <span class="math inline">\(A_i\rightarrow B_i\)</span> 的边形成的集合。</p>
<p>那么对于剩下的五种路径，我们有以下限制： <span class="math display">\[
\begin{aligned}
A, B   \in &amp;P\\
\text{}\\
A_1, B_2 \in &amp;P; &amp;A_2     \in &amp;Q\\
A_1, B_2 \in &amp;P; &amp;B_1     \in &amp;Q\\
A_1, B_3 \in &amp;P; &amp;A_2, B_2 \in &amp;Q\\
A_1, B_3 \in &amp;P; &amp;B_1, A_3 \in &amp;Q; &amp;A_2, B_2 \in O
\end{aligned}
\]</span> 然后在增广完之后，上面的五条路径分别会出现这样的改变：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\(\text{insert } O\)</span></th>
<th><span class="math inline">\(\text{delete } O\)</span></th>
<th><span class="math inline">\(\text{insert } Q\)</span></th>
<th><span class="math inline">\(\text{delete } Q\)</span></th>
<th><span class="math inline">\(\text{insert }P\)</span></th>
<th><span class="math inline">\(\text{delete }P\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\text{path 1}\)</span></td>
<td><span class="math inline">\(A,B\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><span class="math inline">\(A,B\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\text{path 3}\)</span></td>
<td><span class="math inline">\(A_2,B_2\)</span></td>
<td></td>
<td><span class="math inline">\(A_1\)</span></td>
<td><span class="math inline">\(A_2\)</span></td>
<td></td>
<td><span class="math inline">\(A_1,B_2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\text{path 4}\)</span></td>
<td><span class="math inline">\(A_1,B_1\)</span></td>
<td></td>
<td><span class="math inline">\(B_2\)</span></td>
<td><span class="math inline">\(B_1\)</span></td>
<td></td>
<td><span class="math inline">\(A_1,B_2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\text{path 5}\)</span></td>
<td><span class="math inline">\(A_2,B_2\)</span></td>
<td></td>
<td><span class="math inline">\(A_2,B_2\)</span></td>
<td><span class="math inline">\(A_1,B_3\)</span></td>
<td></td>
<td><span class="math inline">\(A_1,B_3\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\text{path 6}\)</span></td>
<td><span class="math inline">\(A_1,B_1,A_3,B_3\)</span></td>
<td><span class="math inline">\(A_2,B_2\)</span></td>
<td><span class="math inline">\(B_1,A_3\)</span></td>
<td><span class="math inline">\(A_2,B_2\)</span></td>
<td></td>
<td><span class="math inline">\(A_1,B_3\)</span></td>
</tr>
</tbody>
</table>
<p>可以发现改变量并不多。</p>
<p>那么我们用 <span class="math inline">\(5\)</span> 个可删堆，分别维护：<span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(P\)</span> 的和的最大值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(P\)</span> 的最大值，<span class="math inline">\(B\)</span> 在 <span class="math inline">\(P\)</span> 的最大值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(P\)</span> 且 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(Q\)</span> 的最大的 <span class="math inline">\(A\)</span> 的权值，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(Q\)</span> 且 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(P\)</span> 的最大的 <span class="math inline">\(B\)</span> 的权值。并同时维护 <span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(Q\)</span>，<span class="math inline">\(A,B\)</span> 都在 <span class="math inline">\(O\)</span> 的对数，就可以通过这五个可删堆的拼凑，得到上述五条路径的最大值，修改的时候由于修改量很少，暴力更新可删堆即可。</p>
<p>总复杂度 <span class="math inline">\(O(\sum n\log \max\{n\})\)</span>。</p>
<p>贴个代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, id;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v ^ A.v ? v &lt; A.v : id &lt; A.id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v == A.v &amp;&amp; id == A.id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ErasableHeap</span> &#123;</span></span><br><span class="line">  <span class="built_in">priority_queue</span> &lt;Node&gt; I, O;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (!O.empty() &amp;&amp; I.top() == O.top()) I.pop(), O.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (!I.empty()) I.pop();    <span class="keyword">while</span> (!O.empty()) O.pop(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node x)</span> </span>&#123; I.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(Node x)</span>  </span>&#123; O.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; flush(); <span class="keyword">return</span> I.empty(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Node <span class="title">top</span><span class="params">()</span>   </span>&#123; flush(); <span class="keyword">return</span> I.top();   &#125;</span><br><span class="line">&#125; q1, q2, q3, q4, q5;</span><br><span class="line"><span class="comment">// Max AB in P; Max A in P; Max B in P; Max A in P and B in Q; Max A in Q and B in P;</span></span><br><span class="line"><span class="keyword">int</span> visa[MAXN], visb[MAXN];</span><br><span class="line"><span class="keyword">int</span> stkQ[MAXN], stkO[MAXN];</span><br><span class="line"><span class="comment">// 0 : in P; 1 : in Q; 2 : in O</span></span><br><span class="line"><span class="keyword">int</span> cntO, cntQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteAll</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">0</span>) q1.erase((Node)&#123;a[x].v + b[x].v, x&#125;);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span>)                 q2.erase(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visb[x] == <span class="number">0</span>)                 q3.erase(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">1</span>) q4.erase(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">0</span>) q5.erase(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">1</span>) --cntQ;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">2</span> &amp;&amp; visb[x] == <span class="number">2</span>) --cntO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertAll</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">0</span>) q1.insert((Node)&#123;a[x].v + b[x].v, x&#125;);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span>)                 q2.insert(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visb[x] == <span class="number">0</span>)                 q3.insert(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">0</span> &amp;&amp; visb[x] == <span class="number">1</span>) q4.insert(a[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">0</span>) q5.insert(b[x]);</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">1</span> &amp;&amp; visb[x] == <span class="number">1</span>) stkQ[++cntQ] = x;</span><br><span class="line">  <span class="keyword">if</span> (visa[x] == <span class="number">2</span> &amp;&amp; visb[x] == <span class="number">2</span>) stkO[++cntO] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushInQ</span><span class="params">(<span class="keyword">int</span> *vis, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  DeleteAll(x);</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  InsertAll(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushInO</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  DeleteAll(x);</span><br><span class="line">  visa[x] = visb[x] = <span class="number">2</span>;</span><br><span class="line">  InsertAll(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> T; read(T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, K, L; read(n), read(K), read(L);</span><br><span class="line">    <span class="keyword">int</span> res = K - L;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      read(a[i].v), a[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      read(b[i].v), b[i].id = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      visa[i] = visb[i] = <span class="number">0</span>;</span><br><span class="line">    cntO = <span class="number">0</span>, cntQ = <span class="number">0</span>;</span><br><span class="line">    q1.clear(); q2.clear(); q3.clear(); q4.clear(); q5.clear();</span><br><span class="line"></span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.v &gt; y.v; &#125;);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.v &gt; y.v; &#125;);  </span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= res; ++i) &#123;</span><br><span class="line">      ans += a[i].v, visa[a[i].id] = <span class="number">1</span>;</span><br><span class="line">      ans += b[i].v, visb[b[i].id] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.id &lt; y.id; &#125;);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n, [](Node x, Node y)&#123; <span class="keyword">return</span> x.id &lt; y.id; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) InsertAll(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = L;</span><br><span class="line">    <span class="keyword">while</span> (L--) &#123;</span><br><span class="line">      LL val1 = q1.top().v;</span><br><span class="line">      LL val2 = !q2.empty() &amp;&amp; !q5.empty() ? q2.top().v + q5.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val3 = !q3.empty() &amp;&amp; !q4.empty() ? q3.top().v + q4.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val4 = cntQ &amp;&amp; !q2.empty() &amp;&amp; !q3.empty() ? q2.top().v + q3.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      LL val5 = cntO &amp;&amp; !q4.empty() &amp;&amp; !q5.empty() ? q4.top().v + q5.top().v : <span class="number">-0x7f7f7f7f7f7f7f7f</span>;</span><br><span class="line">      <span class="keyword">if</span> (val1 &gt; val2 &amp;&amp; val1 &gt; val3 &amp;&amp; val1 &gt; val4 &amp;&amp; val1 &gt; val5) &#123;</span><br><span class="line">        ans += val1;</span><br><span class="line">        PushInO(q1.top().id);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val2 &gt; val3 &amp;&amp; val2 &gt; val4 &amp;&amp; val2 &gt; val5) &#123;</span><br><span class="line">        ans += val2;</span><br><span class="line">        <span class="keyword">int</span> tmp = q5.top().id;</span><br><span class="line">        PushInQ(visa, q2.top().id);</span><br><span class="line">        PushInO(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val3 &gt; val4 &amp;&amp; val3 &gt; val5) &#123;</span><br><span class="line">        ans += val3;</span><br><span class="line">        <span class="keyword">int</span> tmp = q4.top().id;</span><br><span class="line">        PushInQ(visb, q3.top().id);</span><br><span class="line">        PushInO(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (val4 &gt; val5) &#123;</span><br><span class="line">        ans += val4;</span><br><span class="line">        <span class="keyword">int</span> t1 = q2.top().id, t2 = q3.top().id;</span><br><span class="line">        PushInO(stkQ[cntQ]);</span><br><span class="line">        PushInQ(visa, t1);</span><br><span class="line">        PushInQ(visb, t2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += val5;</span><br><span class="line">        <span class="keyword">int</span> t1 = q4.top().id, t2 = q5.top().id, t3 = stkO[cntO];</span><br><span class="line">        PushInQ(visa, t3), PushInQ(visb, t3);</span><br><span class="line">        PushInO(t1);</span><br><span class="line">        PushInO(t2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">S -&gt; A -&gt; B -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A -&gt; L -&gt; R -&gt; B -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; L -&gt; A2 -&gt; B2 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; B1 -&gt; R -&gt; B2 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; L -&gt; A2 -&gt; B2 -&gt; R -&gt; B3 -&gt; T</span></span><br><span class="line"><span class="comment">S -&gt; A1 -&gt; B1 -&gt; R -&gt; B2 -&gt; A2 -&gt; L -&gt; A3 -&gt; B3 -&gt; T</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, use all of the path 2</span></span><br><span class="line"><span class="comment">Then, expand rest times</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Let P is a set of the nodes not be chosen, Q is a set of the nodes be chosen into LR, Otherwise is O.</span></span><br><span class="line"><span class="comment">path 1 : A, B   in P                            O : A, B   insert</span></span><br><span class="line"><span class="comment">path 3 : A1, B2 in P; A2     in Q               O : A2, B2 insert                         Q : A2 delete,     A1     insert</span></span><br><span class="line"><span class="comment">path 4 : A1, B2 in P; B1     in Q               O : A1, B1 insert                         Q : B1 delete,     B2     insert</span></span><br><span class="line"><span class="comment">path 5 : A1, B3 in P; A2, B2 in Q               O : A2, B2 insert                         Q : A2, B2 delete, A1, B3 insert</span></span><br><span class="line"><span class="comment">path 6 : A1, B3 in P; B1, A3 in Q; A2, B2 in O  O : A2, B2 delete, A1, B1, A3, B3 insert  Q : B1, A3 delete, A2, B2 insert</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cerr</span> &lt;&lt; (<span class="keyword">double</span>)(clock()) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>最后再来个总结：</p>
<p>模拟费用流究其根本是先建图，然后再分析图进行贪心模拟。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>模拟费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2020 游记</title>
    <url>/2020/12/02/NOIP-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="day--inf">Day -INF</h4>
<a id="more"></a>
<p>已经记不清什么时候的事情了。</p>
<p>组内进行了分小组出题互测。</p>
<p>Clamee 出了一道让队爷都拍手称赞的题，还给丢 T3 了。</p>
<p>自从那一天被 T3 搞自闭开始，T3 就再也没有切过了【悲伤】。</p>
<h4 id="day--5">Day -5</h4>
<p>我说 Codeforces 它不讲武德，当时它一个 Div1A，一个 Div1B，一个 Div1C，我全部都切掉了啊。</p>
<p>切掉之后自然是点到为止，Pretest passed 后就不管了，因为这时按照传统规矩它已经被切了。</p>
<p>它也承认我是先切了它，但它突然就是一个数据怼上来，我大意了啊，没有特判，直接就给 FST 了。</p>
<p>它偷袭一个 2000 多分的蒟蒻这好吗？这不好。OI 界要以和为贵，加强 pretest。</p>
<p>最后掉分了。（</p>
<h4 id="day--4">Day -4</h4>
<p>Kewth 给我们出模拟赛了！！！</p>
<p>开局四个 <span class="math inline">\(998244353\)</span> 当场自闭。</p>
<p>数学蒟蒻在线惊恐。</p>
<p>又被 T3 卡了，T4 比 T3 难多了还给切了，我真就 &amp;@#$&amp;%#&amp;。</p>
<p>又刷了好久知乎，感觉颓死了。</p>
<p>好羡慕那些 win 啊。</p>
<h4 id="day--3">Day -3</h4>
<p>CYJian 给我们出模拟赛了！！！</p>
<p>感觉一开始状态挺好的，前三题一下就做完了（虽然 T3 假了）。</p>
<p>结果 T4 不知道抽了什么筋，想到一个换根+树剖+带修主席树的做法，还开始写了。</p>
<p>写到后面越陷越深，最后 10k 都没写完惨变暴力分。</p>
<p>在 CYJian 这届，切了 T4 就有 0.667 的概率进国家集训队，而没有切进的概率为 0。</p>
<p><strong>在此提前恭喜 xiaolilsqs 进队！！！</strong></p>
<p>Clamee 又改了它出的神仙 T3，不过还好有前车之鉴没有被踩。</p>
<h4 id="day--2">Day -2</h4>
<p>Ysu 给组内开了个会。</p>
<p>自然是考前给大家加信心。（然而考前就要求写退役记）</p>
<p>他说他在高考之前和喜欢的妹子一起刷了一周题，然后就考上了北航。</p>
<p>要是我 NOIP 前可以和喜欢的妹子一起刷一周题，那 400 分不手到擒来？！（因为前提无法实现，所以后面的结果就写得奇怪一点）</p>
<p>又双叒叕开始颓了……还似乎被 Ysu 看到了。</p>
<p>神游了一段时间之后决定开始搞学。</p>
<p>写退役记的时候想到了很多往事，下午加晚上就这么过去了。</p>
<h4 id="day--1">Day -1</h4>
<p>NOIP 前的最后一次模拟赛。</p>
<p>tiger0132 会出题的消息不胫而走，在赛前引起了很多人的恐慌。</p>
<p>最终是 tiger 的两道题拼上另外两题，有一说一，tiger 的题目还是很良心的。毒瘤还是毒瘤在拼的题目上。</p>
<p>最后 3h AK 了。</p>
<p>Ysu 说要把这次当 NOIP，NOIP 当考后放松赛（要是 NOIP 能像今天一样就好了）。</p>
<p>又颓了好一会……后面觉得这样不太行就开始捣鼓 Linux。</p>
<h4 id="day-0">Day 0</h4>
<p>被叫出去<strong>爬</strong>（山）了。</p>
<p>回来之后搞了一次机房团建（雾。</p>
<p>晚上开了场 Div.2 VP，卡 E 了，感觉药丸。</p>
<h4 id="day1">Day1</h4>
<p>Ysu 喝奶茶导致喉咙发炎了（听说被珍珠呛到？？？），心疼 30s。</p>
<p>早上 5:30 惊醒，看了下表一时间不能确定是五点还是六点，调了一下表盘，看数字表盘发现才 5:30，就躺下打算继续睡。</p>
<p>结果每 7-8 min 就惊醒一次，浑浑噩噩熬到 6:10 就起床了。</p>
<p>随便买了些东西当早餐，顺便捎了个薄荷糖防睡觉。</p>
<p>7:30 到制定地点，7:40+ 就进考场了，下完题目和配置就开始发呆。</p>
<p>解压密码 <code>1Xuan2Shou0Jia5You</code>，太谢谢 CCF 的祝福了（雾。</p>
<p>T1 送分，T2 字符串……？想了会发现不是太难。T3 构造，T4 计数。</p>
<p>似乎又没有数据结构和树据结构……又组些什么阴间题啊……</p>
<p>1h rush 完 T1,T2，发现 T2 <span class="math inline">\(O(T(27n+n\log n))\)</span> 有亿点点卡常，花了 30min 优化常数后发现还是有点点慢，但是感觉卡下去没有什么意义，就放弃了。</p>
<p>回头看了一下 T1，突然一下没看到 <span class="math inline">\(d\leq 5\)</span>，然后就 NT 地构造了一种 <span class="math inline">\(10000^{10}\)</span> 的图就卡没了。</p>
<p>一万头草泥马奔腾而过……后来猛然发现 <span class="math inline">\(d\leq 5\)</span>，再加上之前一直不相信 NOIP 会出这种恶心的高精度 <span class="math inline">\(\gcd\)</span>，然后就直接肝 T3 了。</p>
<p>想到一种似乎有点优秀的算法，就上手了，中途修修补补了很多下，差不多 12:00 过大样例，写了个随机 generator 就放后台和 SPJ 拍了。</p>
<p>T4 也直接没管正解，想到一个 <span class="math inline">\(O(\sum_i^kw_i(\log w_i+k))\)</span> 就直接上手了，没有注意一些边界，卡了好久，最后在 12:50 过了大样例，可惜有亿点点慢。</p>
<p>然后就下考了，感觉考试很匆忙过得及其不真实，下考之后脑子就一片空白了。</p>
<p>出考场之后感觉大家都说题目难，似乎我的预计得分还比较可观。</p>
<p>和好基友一起吃了中饭，回学校看洛谷发现 T1 似乎真的要写高精？？？我可 $#%^#&amp;@。</p>
<p>当然这点点小插曲还是不能挡住我颓的，回家直接上号开干了。</p>
<h4 id="day3">Day3</h4>
<p>回归文化课的第一天，文化课还是那么拉胯。</p>
<p>晚上搞到了自己的程序，测了一下民间数据，90+96+100+60，似乎挺高，好像本省 rk2……？反正还是要被文化课踩。</p>
<h4 id="day4">Day4</h4>
<p>真·CCF·成绩出来了，60+92+100+65，这波 T1 是真的阴间了。</p>
<p>有亿点点怀念停课的时光，被文化课踩得有亿点点难受啊……</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>PAM 学习笔记</title>
    <url>/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="定义">定义</h4>
<p>PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。</p>
<p>PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。</p>
<a id="more"></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th>AC 自动机</th>
<th>PAM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">点         </td>
<td>一个前缀</td>
<td>一个回文串</td>
</tr>
<tr class="even">
<td style="text-align: left;">转移边</td>
<td>从起点走到终点，相当于在起点的字符串后面加上一个字符</td>
<td>从起点走到终点，相当于在起点的字符串两侧都加上一个字符</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fail 边</td>
<td>存在的最长后缀</td>
<td>存在的最长回文后缀</td>
</tr>
</tbody>
</table>
<p>但是，PAM 有一个 AC 自动机不具有的性质——它有两个根！因为可以发现走转移边并不会改变回文串长度的奇偶性，这样的话就保存不了所有的回文串了，所以我们需要两个根，一个叫做奇根，还有一个叫做偶根，这样才能维护所有的回文串。</p>
<h4 id="构造">构造</h4>
<p>定义完了那就看看怎么构造它。这里我们使用增量法。</p>
<p>为了方便，我们给每个点定义一个结构体，存当前点的信息，这里我们就维护三个信息：当前回文串的长度、转移边、fail 边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> son[<span class="number">26</span>], fail;</span><br><span class="line">&#125; t[MAXN];</span><br></pre></td></tr></table></figure>
<p>先看看怎么初始化，显然我们要先定义两个根。对于奇根，它的长度为 <code>-1</code> （可以把在它两侧加一个字符，当做它会吃掉一个字符），它一开始没有儿子，它的 fail 边随便指（因为它的两侧一定可以加字符）。对于偶根，它的长度为 <code>0</code> （可以看成是空串），它一开始没有儿子，它的 fail 边指向奇根，因为它两侧不能加字符的话，就只能丢给奇根了。即：（<code>0</code> 号节点是偶根，<code>1</code> 号节点是奇根）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">0</span>].len = <span class="number">0</span>; t[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">t[<span class="number">1</span>].fail = t[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>假设上一次加入的点是 <code>last</code> ，现在需要新增一个字符 <code>ch</code>，假设它存储在 <code>s[pos]</code>。</p>
<p>首先我们需要找到一个 <code>last</code> 所代表串的一个最长后缀，使得可以在这个后缀后面加上 <code>ch</code>，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfail</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s[pos] != s[pos - t[last].len - <span class="number">1</span>])</span><br><span class="line">    last = t[last].fail;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这个最长后缀所在的点记作 <code>cur</code>，然后接下来就看 <code>cur</code> 节点有没有 <code>ch</code> 这个儿子，如果有就直接跳过，把 <code>last</code> 设为这个儿子，否则就新增一个节点，记为 <code>nxt</code>。</p>
<p>对于 <code>nxt</code>，它的长度是 <code>cur</code> 的长度 <code>+2</code> （根据转移边的定义）。它的 fail 的寻找和 AC 自动机很像，是在 <code>cur</code> 的 <code>fail</code> 中再找到一个最长的有 <code>ch</code> 这个字符的儿子的后缀，然后把 <code>nxt</code> 的 fail 指向那个后缀的 <code>ch</code> 儿子。最后再把 <code>cur</code> 的 <code>ch</code> 儿子设为 <code>nxt</code>。具体实现如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nxt = ++cnt;</span><br><span class="line">t[nxt].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">t[nxt].fail = t[Getfail(t[cur].fail, pos)].son[s[pos] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">t[cur].son[s[pos] - <span class="string">&#x27;a&#x27;</span>] = nxt;</span><br></pre></td></tr></table></figure>
<p>最后也需要让 <code>last</code> 等于 <code>nxt</code> 。</p>
<p>这样就可以把 PAM 构造出来，复杂度是 <span class="math inline">\(O(n)\)</span> 的，因为每次跳 fail 会让当前串的长度至少减 <code>2</code>，而加入一个字符只会让当前串的长度加 <code>2</code>，所以跳 fail 的次数是有保障的。</p>
<h4 id="应用">应用</h4>
<p>PAM 可以处理很多有关回文串的信息，具体在此就不展开了。实际上我们可以把 AC 自动机或是 SAM 的那些套路拿到 PAM 上来用，具体的怎么做还是得要进行实践。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>POI2012</title>
    <url>/2020/10/17/POI2012/</url>
    <content><![CDATA[<p><del>吉老师是我们的红太阳，紧随吉老师的步伐。</del></p>
<a id="more"></a>
<h5 id="distance">Distance</h5>
<p>设 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(x\)</span> 的质因数个数（相同算多个）。</p>
<p>那么 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的操作数就是 <span class="math inline">\(f(\frac{xy}{\gcd(x,y)^2})\)</span>。</p>
<p>而不难发现上式等于 <span class="math inline">\(f(x)+f(y)-2f(\gcd(x,y))\)</span>。</p>
<p>所以对于要求答案的数 <span class="math inline">\(x\)</span>，枚举 <span class="math inline">\(\gcd\)</span> 后就只要看最小的 <span class="math inline">\(f(y)\)</span> 即可，而这个 <span class="math inline">\(y\)</span> 必须是枚举的 <span class="math inline">\(\gcd\)</span> 的倍数，预处理一下即可。</p>
<h5 id="cloakroom">Cloakroom</h5>
<p>考虑把询问离线，那么就可以把所有查询归为 <span class="math inline">\(n^2\)</span> 个组。</p>
<p>对于某个组，直接用 <code>bitset</code> 跑可行性背包。</p>
<p>复杂度 <span class="math inline">\(O(\frac{n^2k}{w})\)</span>，需要卡常。</p>
<h5 id="a-horrible-poem">A Horrible Poem</h5>
<p>把字符串按照块大小为 <span class="math inline">\(1,2...n\)</span> 分块，然后预处理每种分块每个块往前有多少个块和它一样。</p>
<p>对于一个查询，枚举长度的一个因子，然后查询整块是不是都相等，如果都相等就把散块拼接成一个整块再去判断这个拼接的整块和原来的整块是否相等。</p>
<p>画图就可以很显然的看出这个性质。</p>
<p>判断字符串相等直接用哈希。</p>
<p>需要卡常。</p>
<h5 id="fibonacci-representation">Fibonacci Representation</h5>
<p>先把这个数用斐波那契数拆分。</p>
<p>这么拆分有一个性质——没有相邻的 <span class="math inline">\(1\)</span>。</p>
<p>减去一个数可以看成是把原数加上一个数，所以现在就是在这个序列上面加减，求变成全 <span class="math inline">\(0\)</span> 的最小次数。需要注意的一个性质就是如果有两个相邻的 <span class="math inline">\(1\)</span> 会自动往后合并。</p>
<p>从前往后扫，碰到一个 <span class="math inline">\(1\)</span> 后，如果其后面第二位或者第三位有值，就在某个位置加上一个 <span class="math inline">\(1\)</span> 使得可以连锁反应把后面那个 <span class="math inline">\(1\)</span> 也弄掉，否则就直接删掉这个 <span class="math inline">\(1\)</span>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ Contests</title>
    <url>/2020/10/14/UOJ-Contests/</url>
    <content><![CDATA[<p><del>九条可怜老师</del>吉老师在他的博客中大力赞扬 UR 。</p>
<p>于是博主就决定慢慢把 UR 补完。</p>
<p>希望补完之后能有吉老师十分之一的水平。</p>
<a id="more"></a>
<h4 id="uoj-easy-round-1">UOJ Easy Round #1</h4>
<h5 id="a">A</h5>
<p>最小是 <span class="math inline">\(2\sqrt{n}\)</span>，最大是 <span class="math inline">\(g+l\)</span>。</p>
<p>用三次根号分治分解 <span class="math inline">\(g,l\)</span>，剩下的要么相等，要么都是完全平方数。</p>
<h5 id="c">C</h5>
<p>离线，建操作树，用可撤销并查集求解。</p>
<p><code>Add</code> 是加一个儿子，<code>Delete</code> 是跳到 <span class="math inline">\(k\)</span> 级父亲，<code>Return</code> 是回到上一步所在位置。</p>
<p>求父亲类似长链剖分用个数组记录动指针。</p>
<h4 id="uoj-round-1">UOJ Round #1</h4>
<h5 id="a-1">A</h5>
<p>枚举缩进量 <span class="math inline">\(x\)</span>，当前代码量就是 <span class="math inline">\(\sum_{i=1}^n\lfloor\frac{a_i}{x}\rfloor a_i\text{ mod }x\)</span>。</p>
<p>显然的整数分块。</p>
<h5 id="b">B</h5>
<p>把 <span class="math inline">\(x\)</span> 模一个大于 <span class="math inline">\(x\)</span> 的数不会有任何改变。</p>
<p>故设 <span class="math inline">\(f[i]\)</span> 表示当前的值为 <span class="math inline">\(i\)</span>，所有大于 <span class="math inline">\(i\)</span> 的数都已经放好了的方案数，枚举转移即可。</p>
<h4 id="uoj-round-2">UOJ Round #2</h4>
<h5 id="a-2">A</h5>
<p>从左往右扫，遇到一个不合法的右括号，就往右找第一个左括号交换。</p>
<p>因为是右边的第一个左括号，所以如果下一次仍然有不合法的右括号，就可以从上次的那个位置开始继续往右找左括号。</p>
<h5 id="c-1">C</h5>
<p>先套上简单容斥，<span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(\gcd\)</span> 是 <span class="math inline">\(i\)</span> 的倍数的方案数。</p>
<p>对树长链剖分，这样就只需要在链合并的时候计算对 <span class="math inline">\(f\)</span> 的贡献。</p>
<p>朴素的想法维护深度桶，合并枚举 <span class="math inline">\(i\)</span>，直接求当前链的 <span class="math inline">\(i\)</span> 的倍数个数和合并链的 <span class="math inline">\(i\)</span> 的倍数个数。这样复杂度是 <span class="math inline">\(\sum dep\)</span> 的，不太行。</p>
<p>故考虑根号分治，在加入当前点的时候就直接预处理深度模 <span class="math inline">\(1\sim B\)</span> 等于 <span class="math inline">\(x\)</span> 的数的个数，剩下的同上暴力。</p>
<p>复杂度比较玄学，<span class="math inline">\(B=50\)</span> 可过。</p>
<h4 id="uoj-round-3">UOJ Round #3</h4>
<h5 id="a-3">A</h5>
<p>不难发现次大公约数就是最大公约数除掉最小质因子。</p>
<p>而最大公约数一定是 <span class="math inline">\(a[1]\)</span> 的因子。</p>
<p>预处理出 <span class="math inline">\(a[1]\)</span> 的所有因子之后，对每个 <span class="math inline">\(\gcd\)</span> 判断即可。</p>
<h4 id="uoj-round-4">UOJ Round #4</h4>
<h5 id="a-4">A</h5>
<p>当 <span class="math inline">\(a\geq \sqrt{n}\)</span> 的时候，<span class="math inline">\(b\)</span> 已经没有用了，两人只能操作 <span class="math inline">\(a\)</span>，故可以直接 <span class="math inline">\(O(1)\)</span> 判。</p>
<p>剩下的部分可以直接 DP。</p>
<h5 id="b-1">B</h5>
<p>把当前剩下的 <span class="math inline">\(k\)</span> 平均分配给三个数组（如果某个越界了就匀出来一点给别的），然后分别查询，那么查询值最小的那个一定可以被放进去，否则把它退出来，加入别的，别的一定比它大，就不优。</p>
<p>所以可以直接这么搞若干次，每次可以确定 <span class="math inline">\(\frac{1}{3}k\)</span> 个数，当 <span class="math inline">\(k\)</span> 足够小的之后就直接暴力即可，可以在次数限制内求得答案。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>[ZJOI2019]开关 题解</title>
    <url>/2021/01/19/ZJOI2019-%E5%BC%80%E5%85%B3-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>把初始状态和目标状态交换，题目不变。</p>
<p>为了方便，设 <span class="math inline">\(p_i\)</span> 为 <span class="math inline">\(i\)</span> 被选的概率，对应到输入即 <span class="math inline">\(\frac{p_i}{\sum_{j=1}^n p_j}\)</span> 。</p>
<p>设 <span class="math inline">\(f(S)\)</span> 表示从 <span class="math inline">\(S\)</span> 状态开始，期望走 <span class="math inline">\(f(S)\)</span> 步到达全零状态。为了方便，我们定义 <span class="math inline">\(\varnothing\)</span> 表示全零状态。</p>
<p>那么显然有<a id="more"></a> <span class="math inline">\(f(S)=\begin{cases}0&amp;S=\varnothing\\1+\sum p_if_{S \text{ xor } i}&amp;S\not=\varnothing\end{cases}\)</span>。</p>
<p>如果把 <span class="math inline">\(f(S)\)</span> 看做是集合幂级数 <span class="math inline">\(F=\sum_S f(S)x^S\)</span>，下半部分的 <span class="math inline">\(\sum\)</span> 可以看做是一个异或卷积（更多有关位运算的卷积，可以参考<a href="https://daniel-yuan.github.io/2021/01/19/FWT-%E5%B0%8F%E7%BB%93/#more">我的另一篇博客</a>），那么我们设另一个集合幂级数 <span class="math inline">\(G=\sum_S g(S)x^S\)</span>，其中 <span class="math inline">\(g(S)\)</span> 在 <span class="math inline">\(S\)</span> 中仅含一个元素 <span class="math inline">\(k\)</span> 的时候为 <span class="math inline">\(p_k\)</span>，否则为 <span class="math inline">\(0\)</span>。那么下半部分的 <span class="math inline">\(\sum\)</span> 就可以看做是 <span class="math inline">\(F*G\)</span>。</p>
<p>不看 <span class="math inline">\(\varnothing\)</span>，我们有 <span class="math inline">\(F*G+1=F\)</span>，即 <span class="math inline">\(F*(G-1)=-1\)</span>，为了方便，把 <span class="math inline">\(g(S)\)</span> 做一个微调，即 <span class="math inline">\(g(S)=\begin{cases}-1&amp;S=\varnothing\\p_i&amp;|S|=1,S\text{ 中的元素为 }i\\0&amp;|S|&gt;1\end{cases}\)</span>。这样在不考虑 <span class="math inline">\(\varnothing\)</span> 的时候，<span class="math inline">\(F*G=-1\)</span>。</p>
<p>考虑 <span class="math inline">\(F*G\)</span> 的 <span class="math inline">\(\varnothing\)</span> 项是什么，我们可以知道 <span class="math inline">\(\sum_i(F*G)(i)=\sum_{i,j} F(i)G(j)\)</span>，因为 <span class="math inline">\(\sum_iG(i)=0\)</span>，所以右边为 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(\sum_i(F*G)(i)=0\)</span>，所以可以推出 <span class="math inline">\((F*G)(\varnothing)=2^n-1\)</span>。</p>
<p>设 <span class="math inline">\(H=F*G\)</span>，那么就有 <span class="math inline">\(h(S)=\begin{cases}2^n-1&amp;S=\varnothing\\-1&amp;S\not=\varnothing\end{cases}\)</span>。</p>
<p><span class="math inline">\(G,H\)</span> 我们都知道，考虑反推 <span class="math inline">\(F\)</span>。</p>
<p>设 <span class="math inline">\(FWTX\)</span> 为集合幂级数 <span class="math inline">\(X\)</span> 在 <span class="math inline">\(FWT\)</span> 之后的结果。根据异或卷积 <span class="math inline">\(FWT\)</span> 的公式（在上面给出的博客有详细介绍）<span class="math inline">\(F(i)=\sum_j(-1)^{|i\text{ and }j|}F(j)\)</span>，不难得到 <span class="math inline">\(FWTG(S)=\begin{cases}0&amp;S=\varnothing\\\sum_{|T|=1}(-1)^{|S\text{ and T|}}p-1&amp;S\not=\varnothing\end{cases}\)</span>，<span class="math inline">\(FWTH(S)=\begin{cases}0&amp;S=\varnothing\\2^n&amp;S\not=\varnothing\end{cases}\)</span>。对于前者，就是照搬式子，然后在 <span class="math inline">\(S=\varnothing\)</span> 处特别展开一下。对于后者，<span class="math inline">\(S=\varnothing\)</span> 的部分是 <span class="math inline">\(H(S)\)</span> 全部相加显然为 <span class="math inline">\(0\)</span>，而其它位置，对 <span class="math inline">\(FWTH(S)\)</span> 贡献为正的 <span class="math inline">\(H(S)\)</span> 和负的 <span class="math inline">\(H(S)\)</span> 应该各占一半，而 <span class="math inline">\(H(\varnothing)\)</span> 的贡献为正，那么剩下的部分相加就应该是 <span class="math inline">\((-1)\times(-1)\)</span>，再加上 <span class="math inline">\(H(\varnothing)\)</span> 就为 <span class="math inline">\(2^n\)</span>。</p>
<p>那么我们可以很轻易的得到，在 <span class="math inline">\(S\not=\varnothing\)</span> 时， <span class="math inline">\(FWTF(S)=\frac{2^n}{\sum_{|T|=1}(-1)^{|S\text{ and T|}}p-1}\)</span>，而当 <span class="math inline">\(S=\varnothing\)</span> 的时候，<span class="math inline">\(FWTF(S)\)</span> 用除法求就 <span class="math inline">\(\text{nan}\)</span> 了，所以需要特别处理。</p>
<p>考虑在 <span class="math inline">\(\sum_SFWTF(S)\)</span> 中每个 <span class="math inline">\(F(S)\)</span> 的贡献，假设 <span class="math inline">\(|S|=X\)</span>，枚举 <span class="math inline">\(|S \text{ and } T|\)</span>，那么就有 <span class="math inline">\(\sum_k(-1)^kC_X^k2^{n-X}=2^{n-X}[X=0]\)</span>，其中 <span class="math inline">\(C_x^y\)</span> 表示组合数（后同）。所以 <span class="math inline">\(\sum_S FWTF(S)=2^nF(\varnothing)\)</span>，而上文有 <span class="math inline">\(F(\varnothing)=0\)</span>，所以 <span class="math inline">\(\sum_S FWTF(S)=0\)</span>。所以 <span class="math inline">\(FWTF(\varnothing)\)</span> 就是 <span class="math inline">\(-\sum_{S\not=\varnothing}FWTF(S)\)</span>。</p>
<p>根据上面推导，我们也可以知道 <span class="math inline">\(F(S)=\frac{1}{2^n}\sum_T(-1)^{|S\text{ and }T|}FWTF(T)\)</span>。（原理也是 <span class="math inline">\(\sum_k(-1)^kC_X^k=[X=0]\)</span>）。</p>
<p>把 <span class="math inline">\(\varnothing\)</span> 单独考虑，那么就有 <span class="math inline">\(F(S)=\sum_{T\not=\varnothing}(\frac{1}{1-\sum_{|U|=1}(-1)^{|U\text{ and }T|}p}-(-1)^{|S\text{ and }T|}\frac{1}{1-\sum_{|U|=1}(-1)^{|U\text{ and }T|}p})\)</span>。</p>
<p>把左右相抵的去掉，稍加整理，有 <span class="math inline">\(F(S)=\sum_{(-1)^{T\text{ and } S}=-1}\frac{2}{2\sum_{|U|=1}p[|U\text{ and }T|=1]}\)</span>。</p>
<p>最后就是一个简单 DP 了<del>（不会吧不会吧，推到这里还不会 DP？）</del>。</p>
<p>设 <span class="math inline">\(dp_{i,j,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 个开关，分子总和为 <span class="math inline">\(j\)</span>，交的奇偶性为 <span class="math inline">\(0/1\)</span> 的方案数。转移显然，总复杂度 <span class="math inline">\(O(n\sum p)\)</span>。</p>
<p>贴个代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> p[MAXN], s[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">50005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y - mod; x += (x &gt;&gt; <span class="number">31</span>) &amp; mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % mod)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = <span class="number">1l</span>l * re * a % mod;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p[i], sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (RI j = p[i]; j &lt;= sum[i]; ++j) &#123;</span><br><span class="line">      Add(f[i][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j - p[i]][<span class="number">0</span> ^ s[i]]);</span><br><span class="line">      Add(f[i][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - p[i]][<span class="number">1</span> ^ s[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">0</span>; j &lt;= sum[i]; ++j) &#123;</span><br><span class="line">      Add(f[i][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">      Add(f[i][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt;= sum[n]; ++i)</span><br><span class="line">    Add(ans, <span class="number">1l</span>l * sum[n] * f[n][i][<span class="number">1</span>] % mod * qpow(i, mod - <span class="number">2</span>) % mod);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>FWT</tag>
        <tag>多项式</tag>
        <tag>期望概率</tag>
      </tags>
  </entry>
  <entry>
    <title>[ZJOI2019] 麻将 题解</title>
    <url>/2021/01/21/ZJOI2019-%E9%BA%BB%E5%B0%86-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>首先对于已有的一堆牌，我们应该要能确定它能不能胡。</p>
<p>这部分具体的可以参考<a href="https://daniel-yuan.github.io/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/#more">我的另一篇博客</a>，顺带说一句，[ZJOI2019] 麻将的前置知识居然被拿去 [GXOI/GZOI2019] 出了个宝牌一大堆<del>，ZJOI 恐怖如斯</del>。</p>
<a id="more"></a>
<p>回到这个题目，对于一个已知状态，我们可以设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1}\)</span> 表示前 <span class="math inline">\(i\)</span> 张牌，<span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，<span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，有无雀头的最大面子数。</p>
<p>但是现在状态是未知的，所以考虑 DP of DP，即把这个 <span class="math inline">\(f\)</span> 压到状态里面去。为了方便，我们把 <span class="math inline">\(f_{0/1/2,0/1/2,0/1}\)</span> （注意到这里已经忽略了 <span class="math inline">\(i\)</span>，因为 <span class="math inline">\(i\)</span> 对转移没有影响）建一个自动机。而自动机上面的信息就是形如 <span class="math inline">\(f_{0,0,0}=x,f_{0,0,1}=y...\)</span> 这样的多元组，因为还有七对子的特殊牌型，所以在自动机上面额外记录一个 <span class="math inline">\(cnt\)</span> 表示对子数。</p>
<p>乍一看，一共有 <span class="math inline">\(3\times 3\times 2=18\)</span> 个 <span class="math inline">\(f\)</span> 状态，而 <span class="math inline">\(f\)</span> 的取值有 <span class="math inline">\(0/1/2/3/4\)</span> 五种（大于 <span class="math inline">\(4\)</span> 已经没有意义，故可以限制最大值为 <span class="math inline">\(4\)</span>），并且还有一个额外的 <span class="math inline">\(cnt\)</span> 需要记录，自动机上的节点数会达到 <span class="math inline">\(5^{18}\times 8=3.0517578125×10^{13}\)</span>，我们难以承受。但是显然有很多状态不会被涉及到，比如说 <span class="math inline">\(f_{0,0,0}=3\)</span> 的时候任何 <span class="math inline">\(f\)</span> 值都不会小于 <span class="math inline">\(3\)</span>。所以我们可以写一个 BFS 去看看自动机节点数有多少。特别的，如果 <span class="math inline">\(cnt=7\)</span> 或者 <span class="math inline">\(f_{0,0,0}=4\)</span>，那么已经胡牌，我们可以建立一个胡牌节点，与此同时，我们也可以把转移边记录下来，特别的，胡牌节点只有自环。代码形如这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map &lt;Status, int&gt; mp;</span><br><span class="line">void GetStatus() &#123;</span><br><span class="line">  Status t, nxt; &#x2F;&#x2F; 这是一个定义状态的结构体</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  q.push(t), mp[t] &#x3D; ++cnt;</span><br><span class="line">  while (t.cnt !&#x3D; -1) t.Trans(2); &#x2F;&#x2F; 这里是构造一个胡牌节点</span><br><span class="line">  mp[t] &#x3D; ++cnt;</span><br><span class="line">  for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i)</span><br><span class="line">    child[mp[t]][i] &#x3D; mp[t];</span><br><span class="line">  while (!q.empty()) &#123;</span><br><span class="line">    t &#x3D; q.front(); q.pop();</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i) &#123;</span><br><span class="line">      nxt &#x3D; t, nxt.Trans(i); &#x2F;&#x2F; 更新 f</span><br><span class="line">      if (mp.find(nxt) &#x3D;&#x3D; mp.end())</span><br><span class="line">        q.push(nxt), mp[nxt] &#x3D; ++cnt; &#x2F;&#x2F; 新建节点</span><br><span class="line">      child[mp[t]][i] &#x3D; mp[nxt]; &#x2F;&#x2F; 记录转移边</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt; 100000) break; &#x2F;&#x2F; protection</span><br><span class="line">  &#125;</span><br><span class="line">  length &#x3D; mp.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 <span class="math inline">\(f\)</span> 具体怎么转移大家可以自己推一推。</p>
<p>然后你会发现搜出来只有 1566 个节点（我也不知道为什么和很多博客上写的都不同，我还怀疑了自己好久……），于是我们就可以根据这个来 DP 了（可以把节点看做是内部的 DP）。</p>
<p>设 <span class="math inline">\(g_{i,j,k}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，当前牌长度为 <span class="math inline">\(j\)</span>，在自动机上面的点 <span class="math inline">\(k\)</span> 的方案数。转移的时候枚举这一种牌有多少张即可，复杂度 <span class="math inline">\(O(n^2\times 1566)\)</span>。因为相同种类的牌是有编号区分的，所以转移的时候一定要乘组合数（被卡了好久）。</p>
<p>最后再考虑计算答案。对于一个至少 <span class="math inline">\(k\)</span> 次才能胡牌的状态，它对答案的贡献为 <span class="math inline">\(k\)</span>。因为是至少，不好直接求，考虑转化成至多。即改成对于一个至多 <span class="math inline">\(k-1\)</span> 次都不能胡牌的状态，它对答案的贡献为 <span class="math inline">\(k\)</span>。而这个状态在 <span class="math inline">\(1\sim k-1\)</span> 次都不能胡牌。所以我们可以把贡献拆分到 <span class="math inline">\(1\sim k-1\)</span> 上面去，每个部分的权值为 <span class="math inline">\(1\)</span>。（或者说 <span class="math inline">\(k=\sum_{i=1}^k1\)</span>？）。</p>
<p>那么最终答案就是 <span class="math inline">\(\frac{\sum_{i=14}^{4n}\sum_{j=1}^{len}g_{n,i,j}(4n-i)!(i-13)![\text{ $j$ 不是胡牌节点 }]}{(4n-13)!}+1\)</span>。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define debug(...) fprintf(stderr, __VA_ARGS__)</span><br><span class="line">#define RI register int</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">#define FILEIO(name) freopen(name&quot;.in&quot;, &quot;r&quot;, stdin), freopen(name&quot;.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Status &#123; &#x2F;&#x2F; 自动机中的状态</span><br><span class="line">  int f[3][3][2], cnt;</span><br><span class="line">  Status () &#123;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          f[i][j][k] &#x3D; -0x3f3f3f3f;</span><br><span class="line">    cnt &#x3D; f[0][0][0] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  void Trans(int res) &#123; &#x2F;&#x2F; 自动机状态的内部转移</span><br><span class="line">    Status nxt;</span><br><span class="line">    int win &#x3D; 0;</span><br><span class="line">    nxt.cnt &#x3D; cnt + (res &gt;&#x3D; 2);</span><br><span class="line">    win |&#x3D; (nxt.cnt &gt;&#x3D; 7);</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k) &#123;</span><br><span class="line">          for (RI lasi &#x3D; 0; lasi &lt;&#x3D; 2; ++lasi)</span><br><span class="line">            for (RI lask &#x3D; 0; lask &lt;&#x3D; k; ++lask) &#123;</span><br><span class="line">              int ned &#x3D; lasi + i + j + 2 * (k - lask);</span><br><span class="line">              if (ned &gt; res) continue;</span><br><span class="line">              nxt.f[i][j][k] &#x3D; min(4, max(nxt.f[i][j][k], f[lasi][i][lask] + j + (res - ned &gt;&#x3D; 3)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          if (nxt.f[i][j][k] &lt; 0)</span><br><span class="line">            nxt.f[i][j][k] &#x3D; -0x3f3f3f3f;</span><br><span class="line">    win |&#x3D; (nxt.f[0][0][1] &gt;&#x3D; 4);</span><br><span class="line">    if (win) &#x2F;&#x2F; 判胡牌</span><br><span class="line">      for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">        for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">          for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">            nxt.f[i][j][k] &#x3D; nxt.cnt &#x3D; -1;</span><br><span class="line">    *this &#x3D; nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  bool operator &lt; (const Status &amp;A) const &#123;</span><br><span class="line">    if (cnt !&#x3D; A.cnt) return cnt &lt; A.cnt;</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 2; ++i)</span><br><span class="line">      for (RI j &#x3D; 0; j &lt;&#x3D; 2; ++j)</span><br><span class="line">        for (RI k &#x3D; 0; k &lt;&#x3D; 1; ++k)</span><br><span class="line">          if (f[i][j][k] !&#x3D; A.f[i][j][k])</span><br><span class="line">            return f[i][j][k] &lt; A.f[i][j][k];</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">map &lt;Status, int&gt; mp;</span><br><span class="line">queue &lt;Status&gt; q;</span><br><span class="line">int const MAXN &#x3D; 2005, mod &#x3D; 998244353;</span><br><span class="line">int child[MAXN][5];</span><br><span class="line">int f[2][405][MAXN];</span><br><span class="line">int tong[105];</span><br><span class="line">int length;</span><br><span class="line">LL frac[MAXN], invfrac[MAXN];</span><br><span class="line"></span><br><span class="line">LL qpow(LL a, LL k) &#123;</span><br><span class="line">  LL re &#x3D; 1;</span><br><span class="line">  for (; k; k &gt;&gt;&#x3D; 1, a &#x3D; a * a % mod)</span><br><span class="line">    if (k &amp; 1) re &#x3D; re * a % mod;</span><br><span class="line">  return re;</span><br><span class="line">&#125;</span><br><span class="line">void Init(int Max) &#123;</span><br><span class="line">  frac[0] &#x3D; 1;</span><br><span class="line">  for (RI i &#x3D; 1; i &lt;&#x3D; Max; ++i)</span><br><span class="line">    frac[i] &#x3D; frac[i - 1] * i % mod;</span><br><span class="line">  invfrac[Max] &#x3D; qpow(frac[Max], mod - 2);</span><br><span class="line">  for (RI i &#x3D; Max; i &gt;&#x3D; 1; --i)</span><br><span class="line">    invfrac[i - 1] &#x3D; invfrac[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetStatus() &#123; &#x2F;&#x2F; 上文已经解释了</span><br><span class="line">  Status t, nxt;</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  q.push(t), mp[t] &#x3D; ++cnt;</span><br><span class="line">  while (t.cnt !&#x3D; -1) t.Trans(2);</span><br><span class="line">  mp[t] &#x3D; ++cnt;</span><br><span class="line">  for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i)</span><br><span class="line">    child[mp[t]][i] &#x3D; mp[t];</span><br><span class="line">  while (!q.empty()) &#123;</span><br><span class="line">    t &#x3D; q.front(); q.pop();</span><br><span class="line">    for (RI i &#x3D; 0; i &lt;&#x3D; 4; ++i) &#123;</span><br><span class="line">      nxt &#x3D; t, nxt.Trans(i);</span><br><span class="line">      if (mp.find(nxt) &#x3D;&#x3D; mp.end())</span><br><span class="line">        q.push(nxt), mp[nxt] &#x3D; ++cnt;</span><br><span class="line">      child[mp[t]][i] &#x3D; mp[nxt];</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt; 100000) break; &#x2F;&#x2F; protection</span><br><span class="line">  &#125;</span><br><span class="line">  length &#x3D; mp.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void Add(int &amp;x, int y) &#123; x +&#x3D; y - mod; x +&#x3D; (x &gt;&gt; 31) &amp; mod; &#125;</span><br><span class="line"></span><br><span class="line">LL C[10][10];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  </span><br><span class="line">#ifdef LOCAL</span><br><span class="line">  FILEIO(&quot;a&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  GetStatus();</span><br><span class="line">  int n; cin &gt;&gt; n;</span><br><span class="line">  C[0][0] &#x3D; 1;</span><br><span class="line">  C[1][0] &#x3D; C[1][1] &#x3D; 1;</span><br><span class="line">  C[2][0] &#x3D; C[2][2] &#x3D; 1, C[2][1] &#x3D; 2;</span><br><span class="line">  C[3][0] &#x3D; C[3][3] &#x3D; 1, C[3][1] &#x3D; C[3][2] &#x3D; 3;</span><br><span class="line">  C[4][0] &#x3D; C[4][4] &#x3D; 1, C[4][1] &#x3D; C[4][3] &#x3D; 4, C[4][2] &#x3D; 6;</span><br><span class="line">  Init(4 * n);</span><br><span class="line">  for (RI i &#x3D; 1, x, y; i &lt;&#x3D; 13; ++i)</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y, ++tong[x];</span><br><span class="line">  int cur &#x3D; 0, nxt &#x3D; 1;</span><br><span class="line">  f[nxt][0][1] &#x3D; 1;</span><br><span class="line">  for (RI i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123; &#x2F;&#x2F; 简单 DP</span><br><span class="line">    swap(cur, nxt);</span><br><span class="line">    memset(f[nxt], 0, sizeof(f[nxt]));</span><br><span class="line">    for (RI j &#x3D; 0; j &lt;&#x3D; 4 * (i - 1); ++j)</span><br><span class="line">      for (RI now &#x3D; 1; now &lt;&#x3D; length; ++now)</span><br><span class="line">        for (RI k &#x3D; tong[i]; k &lt;&#x3D; 4; ++k)</span><br><span class="line">          Add(f[nxt][j + k][child[now][k]], 1ll * f[cur][j][now] * C[4 - tong[i]][k - tong[i]] % mod);</span><br><span class="line">  &#125;</span><br><span class="line">  int ans &#x3D; 0;</span><br><span class="line">  for (RI i &#x3D; 14; i &lt;&#x3D; 4 * n; ++i)</span><br><span class="line">    for (RI j &#x3D; 1; j &lt;&#x3D; length; ++j)</span><br><span class="line">      if (j !&#x3D; 2)</span><br><span class="line">        Add(ans, 1ll * f[nxt][i][j] * frac[4 * n - i] % mod * frac[i - 13] % mod);</span><br><span class="line">  ans &#x3D; (1ll * ans * invfrac[4 * n - 13] % mod + 1) % mod;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; created by Daniel yuan</span><br><span class="line">&#x2F;*</span><br><span class="line">     ________</span><br><span class="line">    &#x2F;        \</span><br><span class="line">   &#x2F; &#x2F;      \ \</span><br><span class="line">  &#x2F; &#x2F;        \ \</span><br><span class="line">  \            &#x2F;</span><br><span class="line">   \  ______  &#x2F;</span><br><span class="line">    \________&#x2F;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>自动机</tag>
        <tag>DP of DP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11——范围 for 的那些事</title>
    <url>/2021/03/02/c-11%E2%80%94%E2%80%94%E8%8C%83%E5%9B%B4-for-%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>众所周知在 <code>c++11</code> 中支持了同 <code>python3</code> 一样的范围 <code>for</code> 语句。即 <code>for (int x : vector)</code>。</p>
<p>该语法结合 <code>c++11</code> 中方便的 <code>auto</code> 不定类型名使用体验极佳。</p>
<a id="more"></a>
<p>但是这样仅适用于系统提供的容器，包括但不限于 STL、数组等。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123; <span class="comment">/* do something */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在一些时候如果我们想要如此方便的遍历自己的结构体就不适用了。</p>
<p>这里给出一种可以实现这个效果的方法。</p>
<p>首先我们要知道 <code>for (:)</code> 在程序内部到底是怎么实现的。抛开数组不谈，对于一些可遍历的 STL，我们自己在遍历的时候是用迭代器从 <code>begin()</code> 到 <code>end()</code> 遍历。其实在程序内部，这种范围 <code>for</code> 有一种实现也是这样，即 <code>for (auto x = v.begin(); x != v.end(); ++x)</code>。当然具体如何实现不管，我们只需要知道，对于我们自己定义的结构体，如果能自定义一个迭代器，且该结构体有 <code>begin()</code>、<code>end()</code> 函数供迭代器遍历，那么就可以实现这个过程。</p>
<p>实际上迭代器用指针模拟就可以了。但是因为指针的 <code>++</code> 和 <code>*</code> 已经被定义，不适合当做这里的迭代器。但是我们可以用一个结构体来存储指针并模拟。即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">  T *iter;</span><br><span class="line">  Iterator (T *p) &#123; iter = p; &#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span> *() &#123; <span class="keyword">return</span> *iter; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Iterator&amp; that) &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;iter != that.iter; &#125;</span><br><span class="line">  Iterator&amp; <span class="keyword">operator</span>++() &#123; iter = iter-&gt;next; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了能够适用更多情况，这里的模拟迭代器适用 <code>template</code> 模板。在其中定义了一个指针来储存数据，重载的取值的 <code>*</code>，自加 <code>++</code> 和不等于，即与上文暴力实现的需求相对应。这里有两个注意项，<code>++</code> 的函数中的语句 <code>iter = iter-&gt;next</code>，这需要适用这个迭代器的结构体有 <code>next</code> 指针；<code>*</code> 的返回值必须为传引用，不然的话就不能通过这个来修改了。</p>
<p>考虑怎么使用它。下面给出一个边表的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edges</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to; Edges *next;</span><br><span class="line">  Edges () &#123; to = <span class="number">0</span>, next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">Iterator&lt;Edges&gt; <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&lt;Edges&gt;(<span class="keyword">this</span>); &#125;;</span><br><span class="line">  <span class="function">Iterator&lt;Edges&gt; <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&lt;Edges&gt;(<span class="literal">nullptr</span>); &#125;</span><br><span class="line">&#125; e[];</span><br></pre></td></tr></table></figure>
<p>其中 <code>to</code> 是边表要存的信息，这里不管。<code>next</code> 是连接下一个元素的指针，这里和迭代器中的 <code>next</code> 相对应。在该结构体中我们还需要定义两个函数 <code>begin()</code> 和 <code>end()</code>，这样才能遍历这个结构体。</p>
<p>不难发现最后 <code>Edges</code> 会连出一个链表。用范围 <code>for</code> 遍历的时候，我们传入的是开始遍历的位置。具体的，即 <code>for (auto x : e[k])</code>，这意味着它会从 <code>e[k]</code> 开始遍历，到链尾才会结束。</p>
<p>至此我们就可以实现用范围 <code>for</code> 遍历自定义的结构体了。</p>
<p>❀ ~撒花~ ❀</p>
<hr />
<p>但事实上在算法竞赛中它的用途极少，因为似乎除了边表就没有什么东西需要遍历一个结构体了。但是或许可以写一些算法竞赛之外的东西，<del>用来装 X</del>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>diary</title>
    <url>/2020/10/06/diary/</url>
    <content><![CDATA[<p>本意是在联赛前记录些什么。</p>
<p>因为博主太懒所以咕了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>「LibreOJ Round #11」Misaka Network 与求和 题解</title>
    <url>/2021/01/30/%E3%80%8CLibreOJ-Round-11%E3%80%8DMisaka-Network-%E4%B8%8E%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>求 <span class="math inline">\(\sum_{i=1}^N\sum_{j=1}^Nf^k(\gcd(i,j))\)</span>，其中 <span class="math inline">\(f(x)\)</span> 表示 <span class="math inline">\(x\)</span> 的第二大质因子，每个质因子算多次，即 <span class="math inline">\(f(4)=f(6)=2\)</span>，定义 <span class="math inline">\(f(1)=0,f(Prime)=1\)</span>。</p>
<p>众所周知 Min_25 筛的本质是用 DP 求出所有 <span class="math inline">\(S(\lfloor\frac{n}{1}\rfloor),S(\lfloor\frac{n}{2}\rfloor)...\)</span> 这 <span class="math inline">\(2\sqrt{n}\)</span> 个值。如果可以较好的处理每个数质因子之间的关系的话，是不要求所筛函数是积性函数的，这个题就是一个典型例子。</p>
<a id="more"></a>
<p>直接设 <span class="math inline">\(f^k(n)=\sum_{d|n}g(d)\)</span>，莫比乌斯反演得到 <span class="math inline">\(g(n)=\sum_{d|n}f^k(d)\mu(\frac{n}{d})\)</span>。原式变成 <span class="math inline">\(\sum_{d=1}^ng(d)\lfloor\frac{n}{d}\rfloor^2\)</span>。</p>
<p>后面直接整除分块，现在就只需要求 <span class="math inline">\(g\)</span> 的前缀和。</p>
<p>设 <span class="math inline">\(S(n)=\sum_{i=1}^ng(i)\)</span>，那么 <span class="math inline">\(S(n)=\sum_{i=1}^n\sum_{d|n}\mu(d)f^k(\frac{n}{d})=\sum_{d=1}^n\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f^k(i)\)</span>。后面的求和式又可以整除分块。而前面求 <span class="math inline">\(\mu\)</span> 的前缀和可以用杜教筛（应该也只能用杜教筛）。</p>
<p>考虑怎么求 <span class="math inline">\(\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f^k(i)\)</span>。可以发现 Min_25 筛求积性函数和的时候，每次是剥离了一个数的最小质因子。在这个题中，如果这个最小质因子恰好是次大质因子，那么就可以直接计算贡献，否则贡献就已经在之前算过了。所以我们设 <span class="math inline">\(F(n,x)\)</span> 表示 <span class="math inline">\(n\)</span> 以内所有质因子大于等于 <span class="math inline">\(Prime_x\)</span> 的合数的 <span class="math inline">\(f^k(x)\)</span> 的和，<span class="math inline">\(G(n)\)</span> 表示 <span class="math inline">\(n\)</span> 以内的质数个数。类似于 Min_25 筛的，<span class="math inline">\(F,G\)</span> 只有 <span class="math inline">\(2\sqrt{n}\)</span> 个值。</p>
<p><span class="math inline">\(G\)</span> 是一个经典的 DP，在此就不再赘述。</p>
<p>考虑求 <span class="math inline">\(F\)</span>，有 <span class="math inline">\(F(n,x)=F(n,x+1)+\sum_{e=1}\left(F(\frac{n}{p_x^e},x+1)+p_x^k\left(G(\frac{n}{p_x^e})-(x-1)\right)\right)\)</span>，即分最小质因子大于 <span class="math inline">\(x\)</span> 和最小质因子恰好为 <span class="math inline">\(x\)</span> 分别处理。</p>
<p>最后的真实的 <span class="math inline">\(\sum_{i=1}^nf^k(i)\)</span> 就是 <span class="math inline">\(F(n)+G(n)\)</span>。</p>
<p>总复杂度暂时还不会分析，但是 Min_25 的预处理是约 <span class="math inline">\(O(n^\frac{3}{4})\)</span>，真实求值的时候要用两个整除分块加杜教筛，复杂度可能会达到 <span class="math inline">\(O(n^{\frac{7}{8}})\)</span>（当然这是瞎扯）。总之能过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, sq;</span><br><span class="line"><span class="keyword">int</span> Prime[MAXN], tot, miu[MAXN], Smiu[MAXN];</span><br><span class="line"><span class="keyword">char</span> Notprime[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> Max)</span> </span>&#123;</span><br><span class="line">  miu[<span class="number">1</span>] = Smiu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">2</span>; i &lt;= Max; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Notprime[i])</span><br><span class="line">      Prime[++tot] = i, miu[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * Prime[j] &lt;= Max; ++j) &#123;</span><br><span class="line">      Notprime[i * Prime[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      miu[i * Prime[j]] = miu[i] * <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Smiu[i] = Smiu[i - <span class="number">1</span>] + miu[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> DuDuDu &#123;</span><br><span class="line">  <span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; mp;</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MAXN - <span class="number">5</span>) <span class="keyword">return</span> Smiu[n];</span><br><span class="line">    <span class="keyword">if</span> (mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    <span class="keyword">unsigned</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">      r = n / (n / l);</span><br><span class="line">      ans -= (r - l + <span class="number">1</span>) * S(n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[n] = ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> InitF &#123;</span><br><span class="line"><span class="comment">// g(x) = 1,            G(n, x) = \sum g(i)  i is prime || minprime[i] &gt; x</span></span><br><span class="line"><span class="comment">// f(x) = second prime, F(n, x) = \sum f(i)  i is not prime &amp;&amp; minprime[i] &gt;= x</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> MX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> id1[MX], id2[MX], val[MX];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> G[MX], F[MX], Ans[MX];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Getid</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sq ? id1[x] : id2[n / x]; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a *= a)</span><br><span class="line">      <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re *= a;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (RI l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">      r = n / (n / l);</span><br><span class="line">      <span class="keyword">int</span> x = (n / l);</span><br><span class="line">      <span class="keyword">if</span> (x &lt;= sq) id1[x] = ++cnt, val[cnt] = x;</span><br><span class="line">      <span class="keyword">else</span>     id2[n / x] = ++cnt, val[cnt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">      G[i] = val[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; Prime[x] * Prime[x] &lt;= val[<span class="number">1</span>]; ++x)</span><br><span class="line">      <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Prime[x] * Prime[x] &gt; val[i]) <span class="keyword">break</span>;</span><br><span class="line">        G[i] = G[i] - (G[Getid(val[i] / Prime[x])] - (x - <span class="number">1</span>)); <span class="comment">// (x - 1) = SumG[x - 1]</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span> (; x; --x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        LL cur = Prime[x];</span><br><span class="line">        <span class="keyword">while</span> (cur * Prime[x] &lt;= val[i]) &#123;</span><br><span class="line">          F[i] += F[Getid(val[i] / cur)];</span><br><span class="line">          F[i] += (G[Getid(val[i] / cur)] - (x - <span class="number">1</span>)) * qpow(Prime[x], k); <span class="comment">// (x - 1) = SumG[x - 1]</span></span><br><span class="line">          cur *= Prime[x];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">      Ans[i] = F[i] + G[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">SG</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> L = DuDuDu :: S(l - <span class="number">1</span>), R = DuDuDu :: S(r);</span><br><span class="line">    ans += (R - L) * (InitF :: Ans[InitF :: Getid(n / l)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  Euler(<span class="number">1e6</span>);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">  InitF :: Work();</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> L = SG(l - <span class="number">1</span>), R = SG(r);</span><br><span class="line">    ans += (R - L) * (n / l) * (n / l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>Min_25 筛</tag>
      </tags>
  </entry>
  <entry>
    <title>做多项式题的一点小技巧</title>
    <url>/2020/09/26/%E5%81%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>有一类多项式题，十分考验选手的推式子能力，真正的代码部分仅仅只是几个模板拼凑在一起。这类题目如果出现，往往会造成比较大的分差，所以在此略微归纳一下这类题目的做法。大致如下：</p>
<a id="more"></a>
<p>两个主要思想：在解多项式方程的时候，把多项式当做数看，在允许的情况下，可以等式两边同时加减乘除一个多项式；部分题目的多项式可能是无穷项的，在这种情况下，可能会出现把原多项式经过一些操作之后得到自身。</p>
<p>两个主要套路：一个是先想出一个 DP 的做法，然后根据 DP 转移的特性，发现其卷积的性质并把卷积部分弄成多项式，之后直接卷积加速，或者通过解方程的方式求答案；另一个是直接设求解的东西为一个多项式，然后根据其性质使其可以从自己转移到自己，然后解方程。</p>
<p>具体如何使用请看下面两个题目的题解。</p>
<hr />
<h4 id="集训队作业2013城市规划-题解">[集训队作业2013]城市规划 题解</h4>
<p><strong>题意简述：</strong>求 <span class="math inline">\(n\)</span> 个点无重边无自环有标号无向连通图数目。<span class="math inline">\(n\leq 10^5\)</span>。</p>
<p><strong>题解：</strong>我们设 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(i\)</span> 个节点的答案，直接求并不好求，但是我们可以很容易的得到 <span class="math inline">\(n\)</span> 个点的图的数量，即 <span class="math inline">\(2^{C_n^2}\)</span> ，考虑怎么用 <span class="math inline">\(f\)</span> 来表示它。</p>
<p><span class="math inline">\(1\)</span> 号节点最终一定会有一个连通块，考虑枚举这个连通块的大小，于是就有 <span class="math inline">\(2^{C_n^2}=\sum_{i=1}^nC_{n-1}^{i-1}f(i)2^{C_{n-i}^2}\)</span>。也就是 <span class="math inline">\(i\)</span> 个点形成一个连通块，剩下的点随意连边。</p>
<p>为了方便，设 <span class="math inline">\(g(i)=2^{C_i^2}\)</span>，原式子就变成了 <span class="math inline">\(g(n)=\sum_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)\)</span>。</p>
<p>把组合数拆开，移项得 <span class="math inline">\(\frac{g(n)}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{g(n-i)}{(n-i)!}\)</span>，设 <span class="math inline">\(F(i)=\frac{f(i)}{(i-1)!}\)</span>，<span class="math inline">\(G(i)=\frac{g(i)}{i!}\)</span>，后面的求和就是一个卷积的形式，即 <span class="math inline">\(F\times G\)</span>。</p>
<p>把等式左边也稍加整理一下，就有 <span class="math inline">\(nG(n)=(F\times G)(n)\)</span>。</p>
<p>我们定义多项式的点乘为对应项相乘，再设 <span class="math inline">\(H(i)=i\)</span>，那么就有 <span class="math inline">\((H\cdot G)(n)=(F\times G)(n)\)</span>，即 <span class="math inline">\(H\cdot G=F\times G\)</span>。</p>
<p>又因为 <span class="math inline">\(G\)</span> 的常数项为 <span class="math inline">\(1\)</span>，故 <span class="math inline">\(G\)</span> 存在逆元，所以可以两边同时卷上 <span class="math inline">\(G^{-1}\)</span>。于是就有 <span class="math inline">\(F=(H\cdot G)\times G^{-1}\)</span>，写个多项式求逆就可以得到 <span class="math inline">\(F\)</span> 了。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<hr />
<h3 id="cf438e-the-child-and-binary-tree-题解">CF438E The Child and Binary Tree 题解</h3>
<p><strong>题意简述：</strong> 有无数个点，每个点的权值可以是给出集合 <span class="math inline">\(S\)</span> 中的任意一个，定义一棵树的权值是所有点的权值和，求有多少棵节点数目任意的、形态不同的、权值为 <span class="math inline">\(val\)</span> 的二叉树。对于每个 <span class="math inline">\(val\leq k\)</span> 都需要求解。<span class="math inline">\(k,|S|\leq 10^5\)</span>。</p>
<p>题解：直接设多项式 <span class="math inline">\(f\)</span> 为答案多项式，其中 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(val=i\)</span> 的方案数。特别的，<span class="math inline">\(f(0)=1\)</span>。现在考虑 <span class="math inline">\(f\)</span> 怎么求。</p>
<p>设 <span class="math inline">\(g(i)\)</span> 表示一个点的权值为 <span class="math inline">\(i\)</span> 的方案数，显然 <span class="math inline">\(i\in S\)</span> 则 <span class="math inline">\(g(i)=1\)</span>，反之 <span class="math inline">\(g(i)=0\)</span>。</p>
<p>那么对于当前的，它左儿子的方案数是 <span class="math inline">\(f\)</span>，右儿子的方案数是 <span class="math inline">\(f\)</span>，它自己的方案数是 <span class="math inline">\(g\)</span>，而这个问题把解集合并就相当于是一个背包，那么就有 <span class="math inline">\(f=f\times f\times g+1\)</span>，这个加一是指当前这个点的子树为空。</p>
<p>之后把 <span class="math inline">\(f\)</span> 当做未知数解方程，根据求根公式，有 <span class="math inline">\(f=\frac{1\pm\sqrt{1-4g}}{2g}\)</span>，现在需要考虑正负取正还是负。</p>
<p>我们可以这么分析，当 <span class="math inline">\(g\)</span> 趋近于 <span class="math inline">\(0\)</span> 也就是 <span class="math inline">\(|S|\)</span> 趋近于 <span class="math inline">\(0\)</span> 的时候，<span class="math inline">\(f=\frac{1\pm1}{0}\)</span>，而此时方案数是为 <span class="math inline">\(0\)</span> 的，也就是 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(0\)</span>，那么就只能取负号，所以 <span class="math inline">\(f=\frac{1-\sqrt{1-4g}}{2g}\)</span>。</p>
<p><span class="math inline">\(g\)</span> 常数项不是 <span class="math inline">\(1\)</span>，没有逆元，考虑把分子有理化。就有 <span class="math inline">\(f=\frac{2}{1+\sqrt{1-4g}}\)</span>。多项式开根加个求逆即可。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<hr />
<p>上述题目，第一题用的是第一个 trick，第二题用的是第二个 trick，较好的体现了做多项式题目的技巧。且这两个题目十分经典，不失为练习多项式的好题。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于莫比乌斯函数的一些小技巧</title>
    <url>/2020/09/26/%E5%85%B3%E4%BA%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>总结一些有关莫比乌斯函数的应用以及一些数论方面的东西。</p>
<a id="more"></a>
<h3 id="kgcdxy-leftrightarrow-kx-text-and-ky">1. <span class="math inline">\(k|\gcd(x,y) \Leftrightarrow k|x \text{ and } k|y\)</span></h3>
<p>这个 trick 比较显然，不过还是小小的证明一下。</p>
<p>因为 <span class="math inline">\(\gcd(x,y)\)</span> 同时整除 <span class="math inline">\(x,y\)</span>，所以满足左边一定满足右边。因为 <span class="math inline">\(\gcd(x,y)\)</span> 是最大公因数，如果满足右边而不满足左边，那么一定存在一个 <span class="math inline">\(z\)</span> 使得 <span class="math inline">\(\gcd(x,y)\times z\)</span> 也是 <span class="math inline">\(x,y\)</span> 的公因数，和最大公因数的定义矛盾。</p>
<p>因此，若有式子 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{k|\gcd(x,y)}\mu(k)\)</span>，后面的 <span class="math inline">\(k|\gcd(x,y)\)</span> 就可以换成 <span class="math inline">\(k|x\text{ and }k|y\)</span>，这样的话就可以交换求和符号把 <span class="math inline">\(k\)</span> 提前了。</p>
<p>这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p>
<h3 id="若要计算-fgcdxy可以设-fnsum_dngd-来化简式子">2. 若要计算 <span class="math inline">\(f(\gcd(x,y))\)</span>，可以设 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span> 来化简式子。</h3>
<p>举个简单的例子，我们需要计算 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\gcd(i,j)\)</span>。</p>
<p>当然，这个并不典型，而且大多数人都会枚举 <span class="math inline">\(\gcd\)</span> 做，不过我们现在使用当前的这个 trick 来解决这个问题。</p>
<p>我们设 <span class="math inline">\(f(n)=n\)</span>，且 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span>，那么原式就变成了 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{d|\gcd(x,y)}g(d)\)</span> 。然后就可以通过 trick 1 交换求和符号把 <span class="math inline">\(d\)</span> 提前了。而根据莫比乌斯反演，我们可以知道 <span class="math inline">\(g(n)=\sum_{d|n}f(d)\mu(\frac{n}{d})\)</span>（在该例题中恰好是 <span class="math inline">\(\mu*id=\varphi\)</span>），那么也可以很快地计算出 <span class="math inline">\(g\)</span>。这样就通过这个 trick 达到了简化式子的效果，而且在一些情况下比直接枚举 <span class="math inline">\(\gcd\)</span> 再把式子化来化去简单。</p>
<p>同样的，这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p>
<h3 id="设-dx-为-x-的因子个数那么-dntimes-msum_xnsum_ymgcdxy1">3. 设 <span class="math inline">\(d(x)\)</span> 为 <span class="math inline">\(x\)</span> 的因子个数，那么 <span class="math inline">\(d(n\times m)=\sum_{x|n}\sum_{y|m}[\gcd(x,y)=1]\)</span>。</h3>
<p>可以发现，把所有合法的 <span class="math inline">\(x,y\)</span> 拿出来，然后列出所有的 <span class="math inline">\(x\times \frac{m}{y}\)</span>，这就是所有 <span class="math inline">\(n\times m\)</span> 的因子。</p>
<p>肯定不能感性的就这么理解，考虑严谨一点点的证明。</p>
<p><strong>先证明每个因子一定存在一种方式可以得到。</strong></p>
<p>我们假设 <span class="math inline">\(n=\prod p_i^{a_i},m=\prod p_i^{b_i}\)</span>，设某个 <span class="math inline">\(n\times m\)</span> 的因子 <span class="math inline">\(d=\prod p_i^{c_i}\)</span> 。对于 <span class="math inline">\(d\)</span> 的某个质因子及其次幂 <span class="math inline">\(p_i^{c_i}\)</span>，以及对应的 <span class="math inline">\(n,m\)</span> 的质因子及其次幂 <span class="math inline">\(p_i^{a_i},p_i^{b_i}\)</span>。分两种情况讨论。</p>
<ol type="1">
<li>若 <span class="math inline">\(c_i\leq b_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(b_i-c_i\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((0)+(b_i-(b_i-c_i))=c_i\)</span>，且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(0,b_i-c_i)=0}=1\)</span>。</li>
<li>若 <span class="math inline">\(c_i&gt;b_i\)</span>，又因为 <span class="math inline">\(c_i\leq a_i+b_i\)</span>，所以 <span class="math inline">\(c_i-b_i\leq a_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(c_i-b_i\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((c_i-b_i)+(b_i-0)=c_i\)</span>。且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(c_i-b_i,0)=0}=1\)</span></li>
</ol>
<p>这样的话，对于因子 <span class="math inline">\(d\)</span> 的每个 <span class="math inline">\(p_i\)</span> 都这么构造一下即可。</p>
<p><strong>再证明每个因子只能由这一种方式得到。</strong></p>
<p>根据上一部分的证明，不能发现这个性质其实是显然的。不过还是简要说一下。</p>
<p>对于上文的情况 1，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最小为 <span class="math inline">\((1)+(b_i-0)=b_i+1&gt; b_i\geq c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p>
<p>对于上文的情况 2，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最大为 <span class="math inline">\((0)+(b_i-1)=b_i-1&lt;b_i&lt;c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p>
<p>综上就可以证明这个 trick。</p>
<p>同样的，这个 trick 对于多个元素的乘积同样有效，即：</p>
<p><span class="math inline">\(d(\prod a_i)=\sum_{b_1|a_1}\sum_{b_2|a_2}...[\gcd(b_1,b_2)=1][\gcd(b_1,b_3)=1][\gcd(b_2,b_3)=1]...\)</span>。</p>
<h3 id="若求和式中出现枚举-xy-且涉及到了-xy-时大多数时候需要改变思路枚举-xy">4. 若求和式中出现枚举 <span class="math inline">\(x,y\)</span> 且涉及到了 <span class="math inline">\(xy\)</span> 时，大多数时候需要改变思路枚举 <span class="math inline">\(xy\)</span>。</h3>
<p>其实这个是一个十分普遍的小 trick。</p>
<p>还是用那个老到不能再老的例子举例，求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)\)</span>。</p>
<p>我们来枚举 <span class="math inline">\(\gcd\)</span>，然后变化一下就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]\)</span> 。根据常识，就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{n}{kd}\rfloor\)</span>，直接这么做就是 <span class="math inline">\(n\log n\)</span> 的，而且对于 <span class="math inline">\(n\)</span> 很大或者是多组询问不太好优化。</p>
<p>我们发现求和式中出现了 <span class="math inline">\(d\)</span>，也出现了 <span class="math inline">\(k\)</span>，同时涉及到了 <span class="math inline">\(dk\)</span>，那么考虑设 <span class="math inline">\(T=dk\)</span>，我们来枚举 <span class="math inline">\(T\)</span>，就有 <span class="math inline">\(\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{n}{T}\rfloor\sum_{k|T}\mu(k)\frac{T}{k}\)</span>。这样的话，有个求和变成了狄利克雷卷积，而一般来说卷出来的东西是积性函数。这样的话，前面的东西就可以用整数分块，而后面的东西可以线性筛预处理，或者使用亚线性筛直接求。这样大大加快了代码运行的时间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title>划分数</title>
    <url>/2020/10/09/%E5%88%92%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<p>划分数就是把一个数 <span class="math inline">\(n\)</span> 拆分成若干个正整数的和的方案数，其中这若干个正整数是无序的，也就是 <span class="math inline">\(\{1,1,2\}\)</span> 和 <span class="math inline">\(\{1,2,1\}\)</span> 是等价的拆分。</p>
<p>下面我们来讨论怎么求它。</p>
<a id="more"></a>
<h5 id="简单-dp">简单 DP</h5>
<p>我们可以设 <span class="math inline">\(f_{i,j}\)</span> 表示把 <span class="math inline">\(i\)</span> 拆分成 <span class="math inline">\(j\)</span> 个正整数的方案数。</p>
<p>转移有两种，要么添加一个 <span class="math inline">\(1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\)</span>。</p>
<p>那么我们要求的划分数就是 <span class="math inline">\(\sum_{x=0}^n f_{n,x}\)</span>。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>这个算法的优点是我们可以知道所有把 <span class="math inline">\(x\leq n\)</span> 拆分成 <span class="math inline">\(y\leq n\)</span> 个正整数的方案数，缺点是复杂度过高。</p>
<h5 id="根号分治-dp">根号分治 DP</h5>
<p>可以发现，大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多选 <span class="math inline">\(\sqrt{n}\)</span> 个，所以我们可以依靠这个来优化算法。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示用小于等于 <span class="math inline">\(i\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p>
<p>转移有两种，要么是多加一个 <span class="math inline">\(i\)</span>，要么就把 <span class="math inline">\(i\)</span> 加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j}+f_{i,j-i}\)</span>。</p>
<p>这里的 <span class="math inline">\(i\)</span> 我们只枚举到 <span class="math inline">\(\sqrt{n}\)</span>，这样我们就可以知道用小于等于 <span class="math inline">\(\sqrt{n}\)</span> 拼成某个数的方案数。</p>
<p>设 <span class="math inline">\(g_{i,j}\)</span> 表示用 <span class="math inline">\(i\)</span> 个数大于 <span class="math inline">\(\sqrt{n}\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p>
<p>转移有两种，要么添加一个 <span class="math inline">\(\sqrt{n}+1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(g_{i,j}=g_{i-1,j-\sqrt{n}-1}+g_{i,j-i}\)</span>。</p>
<p>因为大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多用 <span class="math inline">\(\sqrt{n}\)</span> 个，所以 <span class="math inline">\(i\)</span> 的上限也是 <span class="math inline">\(\sqrt{n}\)</span>。</p>
<p>那么最后的答案就是 <span class="math inline">\(\sum_{x=0}^n f_{\sqrt{n},x}\times \left(\sum_{y=0}^{\sqrt{n}} g_{y,n-x}\right)\)</span> 。即枚举小于等于 <span class="math inline">\(\sqrt{n}\)</span> 的数的和。复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>这个算法的优点是比多项式做法容易，且复杂度优于简单 DP。缺点是我们只能求得 <span class="math inline">\(n\)</span> 的划分数。</p>
<h5 id="多项式">多项式</h5>
<p>我们可以类似背包的来构造生成函数。</p>
<p>设 <span class="math inline">\(P\)</span> 为划分数的生成函数，即 <span class="math inline">\(P_k\)</span> 的系数为 <span class="math inline">\(k\)</span> 的划分数。</p>
<p>那么就有 <span class="math inline">\(P=\prod_j^\infty\left(\sum_i a_ix^{ij}\right)\)</span>。</p>
<p>即枚举选择的数的大小 <span class="math inline">\(j\)</span>，然后乘上它的生成函数。</p>
<p>根据常识，原式等于 <span class="math inline">\(\prod_{j=1}^\infty \frac{1}{1-x^j}\)</span>。</p>
<p>然后通过 <span class="math inline">\(\ln\)</span> 和 <span class="math inline">\(\exp\)</span> 化乘为加，就可以求得 <span class="math inline">\(P\)</span>。</p>
<p>我们先不看 <span class="math inline">\(\exp\)</span>，先算 <span class="math inline">\(\ln\)</span>。那么原式就是 <span class="math inline">\(-\sum_{j=1}^\infty\ln(1-x^j)\)</span>。</p>
<p>考虑怎么计算 <span class="math inline">\(\ln(1-x^j)\)</span>，换个元设 <span class="math inline">\(u=x^j\)</span>，我们就需要求 <span class="math inline">\(\ln(1-u)\)</span>。</p>
<p>先求导，即 <span class="math inline">\(-\frac{1}{1-u}=-\sum_{i=0}^\infty u^i\)</span>，然后积分，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{u^i}{i}\)</span> 。把元换回来，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p>
<p>那么原式就成了 <span class="math inline">\(\sum_{j=1}^\infty \sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p>
<p>最后把这一坨 <span class="math inline">\(\exp\)</span> 一下就得到了 <span class="math inline">\(P\)</span>。</p>
<p>不难发现当上界为 <span class="math inline">\(n\)</span> 的时候，这个求和的复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<p>而求 <span class="math inline">\(\exp\)</span> 的复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的，故总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>这个算法的优点是能非常快的计算出 <span class="math inline">\(x\leq n\)</span> 的划分数，缺点是很复杂，且对模数有要求。</p>
<hr />
<p>至此就讨论完了三种求划分数的方法。但是如果你认为这就完了那就 <code>too young too simple, sometimes naive</code> 了，出题人怎么可能就只考裸的划分数呢。</p>
<p>下面我们再讨论一下如果限制了划分出来的正整数个数，或者限制了划分出来的正整数的大小该怎么做。</p>
<p>我们可以发现，上述算法的【简单 DP】是很好处理前者的，【多项式】是很好处理后者的，而【根号分治 DP】中的 <span class="math inline">\(f\)</span> 可以维护后者， <span class="math inline">\(g\)</span> 可以维护前者，合并都不好维护。但是回顾上述算法，你会发现它们在最根本的思想上是相似的，而它们在这方面的性质又不一样，这就促使了我们去探究上面两个限制的关系。</p>
<p><strong>引理：把划分出来的正整数排序，并形成一个阶梯图，这个图在行列上具有对偶性。</strong></p>
<p>这么说比较抽象，我也不知道表达对不对，但是看了下面的图就知道了。（只看加粗部分）</p>
<p><img src="https://s1.ax1x.com/2020/10/09/0DFNCV.png" /></p>
<p>这张图不管是以列划分（左），还是以行划分（右），都可以看做是一个划分数的划分，且它们一一对应。</p>
<p>假设柱状物的个数为数的个数，柱状物的高度是数的大小。</p>
<p>那么如果限制是划分出来的正整数个数不超过数 <span class="math inline">\(x\)</span> ，在左图相当于是柱状物的个数不超过 <span class="math inline">\(x\)</span>，那么在右图就是柱状物的高度不超过 <span class="math inline">\(x\)</span>。</p>
<p>也就是说，限制划分出来的正整数个数不超过 <span class="math inline">\(x\)</span>，和限制划分出来的正整数的大小不大于 <span class="math inline">\(x\)</span> 在本质上是相同的。我们可以对它们进行等价的转化。</p>
<p>这样就可以解释为何上述三个同根的算法性质不同了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>单位根反演学习笔记</title>
    <url>/2021/01/28/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>以下等式被称作单位根反演：</p>
<a id="more"></a>
<p><span class="math display">\[
[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}
\]</span> 其中 <span class="math inline">\(\omega_n\)</span> 表示在所求域内的 <span class="math inline">\(n\)</span> 次单位根。<span class="math inline">\(n\)</span> 次单位根的定义是，若 <span class="math inline">\(\omega_n\)</span> 是 <span class="math inline">\(n\)</span> 次单位根当且仅当 <span class="math inline">\(\omega_n^0,\omega_n^1...\omega_n^{n-1}\)</span> 互不相同，且 <span class="math inline">\(\omega_n^0=\omega_n^n\)</span>。一般来说所求域会是模大质数 <span class="math inline">\(P\)</span> 的同余域，所以若设 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(P\)</span> 的原根，那么在该域下，<span class="math inline">\(n\)</span> 次单位根为 <span class="math inline">\(g^{\frac{P-1}{n}}\)</span>。</p>
<p>关于单位根，有个比较显然的等式，即 <span class="math inline">\(\omega_n^k=\omega_n^{k\text{ mod }n}\)</span>。</p>
<p>基于上面的等式，就有了一种单位根反演证明方法：</p>
<ol type="1">
<li>若 <span class="math inline">\([n|k]\)</span> 那么 <span class="math inline">\(\omega_n^{ik}=1\)</span>，所以右边的式子算出来就是 <span class="math inline">\(1\)</span>。</li>
<li>反之，<span class="math inline">\(\sum_{i=0}^{n-1}\omega_n^{ik}=\sum_{i=0}^{n-1}(\omega_n^k)^i=\frac{1-\omega_n^n}{1-\omega_n^k}\)</span>，因为前提，分母一定不是 <span class="math inline">\(0\)</span>，而分子为 <span class="math inline">\(0\)</span>，所以整体为 <span class="math inline">\(0\)</span>。</li>
</ol>
<p>故得证。</p>
<hr />
<p>虽然单位根反演看上去特别简单，但是在用的时候其实很难把一个式子和单位根反演联系起来，这就需要多加练习。</p>
<p>举个栗子：<a href="https://loj.ac/p/6485">LOJ #6485 LJJ 学二项式定理</a>。 <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=0}^n{n \choose i}s^ia_{i\text{ mod }4}\\
=&amp;\sum_{i=0}^n{n\choose i}s^i\sum_{j=0}^3[4|i-j]a_j\\
=&amp;\sum_{i=0}^n{n\choose i}s^i\sum_{j=0}^3a_j\frac{1}{4}\sum_{k=0}^3\omega_4^{(i-j)k}\\
=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\sum_{i=0}^n{n\choose i}s^i\omega_4^{ik-jk}\\
=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\omega_4^{-jk}\sum_{i=0}^n{n\choose i}s^i\omega_4^{ik}\\
=&amp;\frac{1}{4}\sum_{j=0}^3a_j\sum_{k=0}^3\omega_4^{-jk}(1+s\omega_4^k)^n
\end{aligned}
\]</span> 当然，直接看推式子的话，这道题就浪费了，所以接下来梳理一下解题思路。</p>
<p>首先直接求和肯定是不好求的，因为后面的下标取模非常麻烦，但是我们可以把后面的模枚举出来，就有了第一步。</p>
<p>之后直接套用单位根反演，并且可以发现组合数和 <span class="math inline">\(s^i\)</span> 很像二项式定理，所以对单位根的指数进行一些分裂等处理，使得所有和 <span class="math inline">\(i\)</span> 有关的项全部被分离，并且把带 <span class="math inline">\(i\)</span> 的项通过二项式定理合并。</p>
<p>最后就只需要模拟求和式了，复杂度 <span class="math inline">\(O(9\times \log n)\)</span>。</p>
<hr />
<p>其实很多单位根反演都是把模或者除之类的算术暴力展开，得到一个符合单位根反演的式子之后直接反演，然后通过对单位根指数的分裂与合并，把单位根的各项分配到合适的地方去，之后就通过一些数学方法合并一些式子，使得求和式变得简单。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>反演</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组学习笔记</title>
    <url>/2020/09/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>老忘后缀数组咋写，写个东西记录下。</p>
<p>算法核心：因为后缀是在同一个串内的，要充分利用其它信息。</p>
<a id="more"></a>
<p>考虑倍增，即从小到大按照长度为 <span class="math inline">\(2^k\)</span> 的串进行排序。</p>
<p>先按照长度为 <span class="math inline">\(1\)</span> 的串排序，每个点有一个排名。</p>
<p>然后扩展到长度为 <span class="math inline">\(2\)</span>，现在可以知道每个长度为 <span class="math inline">\(2\)</span> 的串前一半相对的排名和后一半相对的排名，那么显然是要先按前一半的排，如果相等再按后一半的排，用 pair 加快排可以做到 <span class="math inline">\(n\log n\)</span>，但是不够。考虑使用基数排序，就可以做到 <span class="math inline">\(n\)</span> 。</p>
<p>再扩展到长度为 <span class="math inline">\(4\)</span> …… 总时间复杂度 <span class="math inline">\(n\log n\)</span>。</p>
<p>光求这个没啥用，考虑求一个 height，表示排名为 i 的后缀和排名为 i-1 的最长公共前缀有多长。那么任意两个后缀的 LCP 就可以直接通过 RMQ 求。</p>
<p>考虑怎么求 height，设 h 表示第 i 串和排名恰好小于它 1 的串的最长公共前缀。那么有 <span class="math inline">\(h[i]\ge h[i-1]+1\)</span>。如果 <span class="math inline">\(h[i-1]\leq 1\)</span>，那么显然成立，否则 <span class="math inline">\(h[i-1]\geq 2\)</span>，假设排名恰好小于第 i-1 串 1 的串是第 k 串，那么就有 <span class="math inline">\(s[i-1,i-1+h[i-1])=s[k,k+h[i-1])\)</span> 且 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么 <span class="math inline">\(s[i,i-1+h[i-1])=s[k+1,k+h[i-1])\)</span>，因为 <span class="math inline">\(h[i-1]\geq 2\)</span>，那么这个区间不为空，又因为 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么第 k+1 串的排名肯定是小于第 i 串的，而距离 i 越远 LCP 就越小，那么第 i 串和排名恰好小于它 1 的串的 LCP 至少为 <span class="math inline">\(h[i-1]-1\)</span> 。所以可以直接从小到大暴力枚举求。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式学习笔记</title>
    <url>/2020/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前置知识">前置知识</h4>
<h5 id="形式幂级数">形式幂级数</h5>
<p>对于一个多项式 <span class="math inline">\(\sum_{i=0}^{\infty}a_ix^i\)</span>，如果我们只关心它的各项系数 <span class="math inline">\(\{a_0,a_1...\}\)</span>，而并不关心 <span class="math inline">\(x\)</span> 的值以及其收敛或发散的问题，就可以说其是关于 <span class="math inline">\(x\)</span> 的形式幂级数。</p>
<a id="more"></a>
<h5 id="牛顿迭代">牛顿迭代</h5>
<p>对于一个已知的多项式 <span class="math inline">\(F\)</span>，求一个多项式 <span class="math inline">\(A\)</span>，使得 <span class="math inline">\(F(A)=0\)</span> 在模 <span class="math inline">\(x^n\)</span> 意义下成立，其中 <span class="math inline">\(F,A\)</span> 都是形式幂级数。</p>
<p>牛顿迭代是这样的，假设我们已经求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 下的解 <span class="math inline">\(A_0\)</span>，那么可以把 <span class="math inline">\(F(A)\)</span> 在 <span class="math inline">\(A_0\)</span> 处泰勒展开，再模掉 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(F(A)=F(A_0)+F&#39;(A_0)(A-A_0)\)</span>，然后就可以通过解方程求的在模 <span class="math inline">\(x^n\)</span> 意义下的 <span class="math inline">\(A\)</span>。</p>
<h4 id="运算">运算</h4>
<h5 id="加减法">加减法</h5>
<p>就是多项式对应项相加减。即 <span class="math inline">\(C_ix^i=(A_i+B_i)x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="乘法卷积">乘法（卷积）</h5>
<p>多项式的乘法本质上是求 <span class="math inline">\(C_ix^i=\sum_{j+k=i}A_jB_kx^i\)</span>。可以使用 FFT 或者 NTT 解决。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="求导">求导</h5>
<p>对于一个单项式 <span class="math inline">\(kx^n\)</span> 求导，其值是 <span class="math inline">\(knx^{n-1}\)</span>，而对于多项式的求导，本质上是把各个单项式求导之后再加起来。即 <span class="math inline">\(C_ix^i=(i+1)A_{i+1}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>有两个在多项式中常见的求导公式：<span class="math inline">\((\ln x)&#39;=\frac{1}{x},(e^x)&#39;=e^x\)</span>。</p>
<p>特别的，复合函数也可以求导，<span class="math inline">\((F(G))&#39;=F&#39;(G)\times G&#39;\)</span>。</p>
<h5 id="积分">积分</h5>
<p>积分是求导的逆运算，在求导中，有 <span class="math inline">\(kx^n\rightarrow knx^{n-1}\)</span>，那么积分里面就有 <span class="math inline">\(kx^n\rightarrow\frac{k}{n+1}x^{n+1}\)</span> 。而对于多项式的积分，也是把各个单项式求导之后再加起来，即 <span class="math inline">\(C_ix^i=\frac{A_{i-1}}{i}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="翻转">翻转</h5>
<p>对于一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(A(x)=\sum_{i=0}^n a_ix^i\)</span>，将它变成 <span class="math inline">\(\sum_{i=0}^n a_{n-i}x^i\)</span>，就称之为翻转，记作 <span class="math inline">\(A^R(x)\)</span>，不难发现本质上 <span class="math inline">\(A^R(x)=A(\frac{1}{x})\times x^n\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="求逆">求逆</h5>
<p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个多项式 <span class="math inline">\(A^{-1}(x)\)</span>，使得 <span class="math inline">\(A(x)\times A^{-1}(x)\equiv 1~(~{\rm mod}~x^{n})\)</span>。</p>
<p>考虑使用牛顿迭代，设 <span class="math inline">\(B(x)=A^{-1}(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 。假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}=\frac{1}{B_0(x)}+(\frac{1}{B_0(x)})&#39;(B(x)-B_0(x))\)</span>，我们知道 <span class="math inline">\((\frac{1}{B_0(x)})&#39;=-\frac{1}{B_0^2(x)}\)</span>，那么把 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 中的 <span class="math inline">\(\frac{1}{B(x)}\)</span> 换成上面右边的那一坨，然后稍加整理一下就有 <span class="math inline">\(B(x)\equiv 2B_0(x)-A(x)B_0^2(x)~(~{\rm mod}~x^n)\)</span> 。直接这么倍增处理即可，复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。因为相对于最后一次来说，前面的若干次可以忽略不计。</p>
<h5 id="除法和取模">除法和取模</h5>
<p><span class="math inline">\(A(x)=B(x)\times C(x)+D(x)\)</span>，其中 <span class="math inline">\(A(x)\)</span> 是 <span class="math inline">\(n\)</span> 次多项式，<span class="math inline">\(B(x)\)</span> 是 <span class="math inline">\(m\)</span> 次多项式，<span class="math inline">\(m&lt;n\)</span>，给出 <span class="math inline">\(A(x),B(x)\)</span>，求 <span class="math inline">\(C(x),D(x)\)</span>。</p>
<p>显然，<span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，<span class="math inline">\(D(x)\)</span> 的次数最大是 <span class="math inline">\(m-1\)</span>，就把它看做是 <span class="math inline">\(m-1\)</span> 项，高位不足就补零。</p>
<p>先换元，把等式两边的 <span class="math inline">\(x\)</span> 换做 <span class="math inline">\(\frac{1}{x}\)</span>，然后再在两边同时乘上 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(A(\frac{1}{x})\times x^n=B(\frac{1}{x})\times x^{m}\times C(\frac{1}{x}) \times x^{n-m}+D(\frac{1}{x})\times x^{m-1}\times x^{n-m+1}\)</span>，根据上述的翻转式子，就是 <span class="math inline">\(A^R(x)=B^R(x)\times C^R(x)+D^R(x)\times x^{n-m+1}\)</span> 。前面已经说了 <span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，那么等式模去 <span class="math inline">\(x^{n-m+1}\)</span> 并不会对 <span class="math inline">\(C(x)\)</span> 有任何损失，所以就有 <span class="math inline">\(A^R(x)\equiv B^R(x)\times C^R(x)~({\rm mod}~x^{n-m+1})\)</span>，对 <span class="math inline">\(B^R(x)\)</span> 求个逆元乘上就可以得到 <span class="math inline">\(C^R(x)\)</span>，翻转一下就是 <span class="math inline">\(C(x)\)</span>，然后就可以通过 <span class="math inline">\(A(x)-B(x)\times C(x)\)</span> 得到 <span class="math inline">\(D(x)\)</span>。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="ln-和-exp">ln 和 exp</h5>
<p>因为积分是求导的逆运算，所以一个多项式先求导再积分，多项式不变。</p>
<p>那么对于 ln，就可以先求导再积分来求。即 <span class="math inline">\(\ln F(x)=\int_0^n(\ln F(x))&#39;~{\rm dx}\)</span>，前面已经提到了复合函数求导，所以就有 <span class="math inline">\(\ln F(x)=\int_0^n\frac{F&#39;(x)}{F(x)}~{\rm dx}\)</span> 。复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>
<p>对于 exp，它是 ln 的逆运算，考虑用牛顿迭代求。设 <span class="math inline">\(B(x)=e^{A(x)}\)</span>，那么就有 <span class="math inline">\(\ln B(x)-A(x)=0\)</span>，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\ln B(x)=\ln B_0(x)+\ln&#39;B_0(x)(B(x)-B_0(x))\)</span>，上文已有 <span class="math inline">\(ln&#39;B_0(x)=\frac{1}{B_0(x)}\)</span>，把这个 <span class="math inline">\(\ln B(x)\)</span> 带回原式中去，整理一下就有 <span class="math inline">\(B(x)\equiv B_0(x)(A(x)+1-\ln B_0(x))~(~{\rm mod}~x^n)\)</span>。直接倍增求即可，复杂度也是 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="开根">开根</h5>
<p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个 <span class="math inline">\(B(x)\)</span>，使得 <span class="math inline">\(B^2(x)\equiv A(x)~(~{\rm mod}~x^n)\)</span>。</p>
<p>仍然可以使用牛顿迭代法求，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(B^2(x)=B_0^2(x)+(B_0^2(x))&#39;(B(x)-B_0(x))\)</span>。类似的，整理之后就有 <span class="math inline">\(B(x)\equiv \frac{A(x)}{2B_0(x)}+\frac{B_0(x)}{2}~(~{\rm mod}~x^n)\)</span> 。复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的。</p>
<h4 id="其他东西">其他东西</h4>
<h5 id="分治-fft">分治 FFT</h5>
<p>分治 FFT 可以用来干两种事情。</p>
<p>一种是要把一堆多项式要乘起来，如果直接一个一个乘的话复杂度最坏是 <span class="math inline">\(O(n^2\log n)\)</span> 的，而如果每次对半分，左右分别计算然后再卷积一次，单层的复杂度就是 <span class="math inline">\(O(n\log n)\)</span> 的，一共 <span class="math inline">\(O(\log n)\)</span> 层，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>还有一种是需要求一个多项式的时候，前面的项对后面的项有影响，那么就可以用 CDQ 分治的思想，先算前面的，然后算前面对后面的贡献，最后再算后面的，复杂度 <span class="math inline">\(O(n \log^2 n)\)</span>。</p>
<h5 id="任意模数-ntt">任意模数 NTT</h5>
<p>有两种方法，三模数 NTT 和 拆系数 MTT。</p>
<p>三模数 NTT，就如它的名字，选三个 NTT 模数，分别做一遍 NTT 最后用 CRT 合并。最后 CRT 求出来的一定是精确的值，所以需要保证最终的值在三个 NTT 模数的乘积以内。复杂度是 <span class="math inline">\(O(n \log n)\)</span>，9 倍常数。</p>
<p>拆系数 MTT，也如它的名字，就是把每个数 <span class="math inline">\(X\)</span> 拆成 <span class="math inline">\(AM+B\)</span> 的形式，那么如果有两个多项式 <span class="math inline">\(AM+B\)</span> 和 <span class="math inline">\(CM+D\)</span> 相乘，最后的结果就是 <span class="math inline">\(ACM^2 + (AD+BC)M+BD\)</span>，最后乘出来的结果是 <span class="math inline">\(M^2{\rm len}\)</span>，一般情况下可以跑 FFT，用 long double 存。复杂度是 <span class="math inline">\(O(n\log n)\)</span>，7 倍常数。</p>
<h5 id="多点求值">多点求值</h5>
<p>对于一个多项式 <span class="math inline">\(F\)</span>，给出一些 <span class="math inline">\(z_i\)</span>，需要求出 <span class="math inline">\(F(z_i)\)</span> 的值。</p>
<p>对于求出 <span class="math inline">\(F(z_i)\)</span>，我们可以这么做：次数从高到低扫这个多项式，然后把当前项的一个 <span class="math inline">\(x\)</span> 展开成 <span class="math inline">\(z_i\)</span>（即对于 <span class="math inline">\(ax^k\)</span>，把它展开成 <span class="math inline">\(ax^{k-1}z_i\)</span>，然后把它累加到 <span class="math inline">\(x^{k-1}\)</span> 项中去），最后在常数项的那个值就是 <span class="math inline">\(F(z_i)\)</span>。可以发现，这个过程实际上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p>
<p>对于上述问题，有另一种理解方式：设 <span class="math inline">\(F(z)=A(z)(z-z_i)+B\)</span>，那么当 <span class="math inline">\(z=z_i\)</span> 时，<span class="math inline">\(F(z_i)=B\)</span>，所以本质上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p>
<p>在自然数集中，有 <span class="math inline">\(X~{\rm mod}~BC~{\rm mod}~B = X~{\rm mod}~B\)</span>，其实在多项式中也是这样。</p>
<p>所以可以考虑分治。在分治的过程中，把 <span class="math inline">\(F\)</span> 对 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> 取模，最后递归到叶子节点的时候，当前的多项式就只剩下常数项，就是需要求的 <span class="math inline">\(F(z_i)\)</span>。</p>
<p>考虑发现复杂度，一开始需要求得 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> ，分治 FFT 解决。之后需要分治求解，在每一层，多项式的长度都是 <span class="math inline">\(O({\rm len})\)</span>，所以每层的总长是 <span class="math inline">\(O(n)\)</span> 的，一共有 <span class="math inline">\(O(\log n)\)</span> 层。所以总复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span> ，常数巨大。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>奇奇怪怪的容斥</title>
    <url>/2021/06/01/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<h3 id="核心思想">核心思想</h3>
<p>一类奇奇怪怪的容斥，解决形如：</p>
<ul>
<li>对 <span class="math inline">\(k\)</span> 个计数对象计数，且这 <span class="math inline">\(k\)</span> 个计数对象是无序的。</li>
</ul>
<a id="more"></a>
<p>这类问题的难点就在无序上，因为对于某种方案，它会被计算 <span class="math inline">\(\frac{k!}{\prod {a_i!}}\)</span> 次，其中 <span class="math inline">\(a_i\)</span> 是数字 <span class="math inline">\(i\)</span> 出现的次数。我们无法除掉通过某个简单的东西来得到最终结果。</p>
<p>考虑枚举这 <span class="math inline">\(k\)</span> 个数的集合划分（不难得到总方案数是贝尔数），并且钦定同一个集合里面的数相同，不同集合里面的数不同。对于每个划分 <span class="math inline">\(p_1,p_2...p_m\)</span> 算出方案数之后，就只需要对方案数除掉 <span class="math inline">\(\prod{a_i!}\)</span> 即可，其中 <span class="math inline">\(a_i=\sum_j [|p_j|=i]\)</span> 。</p>
<p>接下来对于某个划分 <span class="math inline">\(p_1,p_2...p_m\)</span>，考虑用容斥求它的方案数。一种朴素的方法是用 <span class="math inline">\(O(2^{\frac{m(m-1)}{2}})\)</span> 的时间复杂度来钦定每对划分是否相等，对于没有钦定的情况它们是任意的，钦定完之后实际上我们得到的就是一个朴素的序列问题。</p>
<p>显然上述容斥的复杂度十分高，考虑优化。我们把 <span class="math inline">\(p_1,p_2...p_m\)</span> 抽象成点，钦定它们是否相等抽象为边，那么朴素的枚举方法就是枚举每条边存不存在，然后同一个连通块的点必须相同，不同连通块则没有要求。考虑直接枚举连通块，也就是对 <span class="math inline">\(p_1,p_2...p_m\)</span> 再做一遍集合划分，设划分成 <span class="math inline">\(q_1,q_2...q_n\)</span>，划分在相同集合的 <span class="math inline">\(p\)</span> 强制钦定相同。考虑某种划分的容斥系数，显然就是 <span class="math inline">\(\sum_{G_1 \text{是} |q_1| \text{个点的连通图}}(-1)^{e(G_1)}...\sum_{G_n \text{是} |q_n| \text{个点的连通图}}(-1)^{e(G_n)}\)</span>，其中 <span class="math inline">\(e(G)\)</span> 是图 <span class="math inline">\(G\)</span> 的边数。显然求和之间是独立的，可以直接简化为 <span class="math inline">\(\prod g(q_i)\)</span>，其中 <span class="math inline">\(g(x)\)</span> 表示 <span class="math inline">\(\sum_{G_1 \text{是} x \text{个点的连通图}}(-1)^{e(G_1)}\)</span>。</p>
<p>考虑计算 <span class="math inline">\(g\)</span>，通过常识，设 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(x\)</span> 个点的任意图的容斥系数和，即 <span class="math inline">\(f(x)=\sum_{i=0}^{\frac{x(x-1)}{2}}{\frac{x(x-1)}{2}\choose i}=[x=1]\)</span>。枚举 <span class="math inline">\(1\)</span> 号点所在连通块的大小，则有 <span class="math inline">\(f(x)=\sum_{i=1}^x{x-1\choose i-1}g(i)f(x-i)\)</span>。代入 <span class="math inline">\(f\)</span> 后不难发现只有 <span class="math inline">\(g(x)\)</span> 和 <span class="math inline">\(g(x-1)\)</span> 在式子中，整理即 <span class="math inline">\(g(x)=(-1){x-1\choose x-2}g(x-1)\)</span>，<span class="math inline">\(g(1)=1\)</span>，归纳不难得到 <span class="math inline">\(g(x)=(-1)^{x-1}(x-1)!\)</span>。</p>
<p>至此，我们把容斥的复杂度从 <span class="math inline">\(O(2^{\frac{m(m-1)}{2}})\)</span> 优化到了第 <span class="math inline">\(m\)</span> 个贝尔数的复杂度。</p>
<h3 id="再次优化">再次优化</h3>
<p>不难发现总复杂度大概是一个“贝尔数的贝尔数”的复杂度，尽管已经较优，但是还是可以优化。</p>
<p>考虑把第一个集合划分从第 <span class="math inline">\(m\)</span> 个贝尔数的复杂度优化到第 <span class="math inline">\(m\)</span> 个划分数的复杂度，也就是说我们现在枚举的划分是无序的，我们需要把所有有序的位置分配给这些划分。首先我们把所有有序的位置全排列，方案数是 <span class="math inline">\(k!\)</span>，再考虑除掉一些同构的情况。假设我们的划分是 <span class="math inline">\(p_1,p_2...p_m\)</span>，那么我们首先要除掉 <span class="math inline">\(\prod p_i!\)</span>，因为划分内部是无序的，其次我们还需要除掉 <span class="math inline">\(\prod a_i !\)</span>，其中 <span class="math inline">\(a_i=\sum_j [p_j=i]\)</span>，因为划分之间也是无序的。这样就可以求得所有的方案了。</p>
<p>可以发现的是，如果我们现在对计数加一个条件——这 <span class="math inline">\(k\)</span> 个计数对象不仅无序，而且两两不同。那么它就没有第一个集合划分的复杂度，并且容斥部分可以直接使用上述优化，总复杂度就被优化到了大小为 <span class="math inline">\(k\)</span> 的划分数。</p>
<p>而对于没有两两不同限制的情况，我们依旧可以通过这个优化把时间复杂度优化到“划分数的贝尔数”。当然，在容斥部分我们也可以搜划分数，然后用状压 DP 去计算，直觉上复杂度是比贝尔数要优的，但暂时还不会具体的分析。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>妙题集合</title>
    <url>/2021/03/17/%E5%A6%99%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>一些神题。</p>
<a id="more"></a>
<p>[SDOI2019]热闹的聚会与尴尬的聚会</p>
<p>给一张 <span class="math inline">\(n\)</span> 点 <span class="math inline">\(m\)</span> 边的无向图。选出两个点集 <span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span>，<span class="math inline">\(S\)</span> 没有要求，<span class="math inline">\(T\)</span> 需要满足其中任意两点没有边，<span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span> 之间没有限制。设 <span class="math inline">\(val(S)\)</span> 为仅保留 <span class="math inline">\(S\)</span> 的点和 <span class="math inline">\(S\)</span> 的点之间的边的最小度数的点的度数，<span class="math inline">\(val(T)=|T|\)</span>。构造一种满足 <span class="math inline">\(\lfloor \frac{n}{val(S)+1} \rfloor\leq val(T)\)</span> 且 <span class="math inline">\(\lfloor \frac{n}{val(T)+1} \rfloor\leq val(S)\)</span> 的方案。<span class="math inline">\(T\)</span> 组询问。<span class="math inline">\(T\leq 32,n\leq 10^4,m\leq 10^5\)</span>。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题解
    </div>
    <div class='spoiler-content'>
        <p>考虑贪心。每次选择度数最小的点，把它加入 <span class="math inline">\(T\)</span>，然后删去所有与 <span class="math inline">\(T\)</span> 连边的点，并更新所有点的度数。</p>
<p>设每次删除时的度数为 <span class="math inline">\(deg\)</span>，那么就有 <span class="math inline">\(\sum_{i=1}^T deg_i=n-|T|\)</span>。</p>
<p>而对于 <span class="math inline">\(S\)</span>，在某个时刻直接把剩下的点全部取出来，最优是 <span class="math inline">\(\max\{deg_i\}\)</span> 的。</p>
<p><span class="math inline">\(val(S)\)</span> 最劣的时候就是所有的 <span class="math inline">\(deg\)</span> 都均分，即 <span class="math inline">\(\lceil\frac{n-|T|}{|T|}\rceil\)</span>。这样仍然是满足要求的。</p>
<p>所以直接用个数据结构动态维护 <span class="math inline">\(deg\)</span> 即可，复杂度 <span class="math inline">\(O(T\times (m\log n))\)</span>。</p>

    </div>
</div>
<hr />
<p>CF1174F Ehab and the Big Finale</p>
<p>这是一道交互题。</p>
<p>你有一棵 <span class="math inline">\(n\)</span> 个节点的有根树，<span class="math inline">\(1\)</span> 号点是根节点。</p>
<p>这棵树中有一个隐藏的节点 <span class="math inline">\(x\)</span>，你需要通过询问把 <span class="math inline">\(x\)</span> 找出来。</p>
<p>你可以进行如下两种询问：</p>
<p>1、<code>d u</code> <span class="math inline">\((1\le u\le n)\)</span>。交互库会返回节点 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(x\)</span> 的距离。</p>
<p>2、<code>s u</code> <span class="math inline">\((1\le u\le n)\)</span>。交互库会返回从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(x\)</span> 的路径上第二个点的标号。注意，你询问的 <span class="math inline">\(u\)</span> 必须是 <span class="math inline">\(x\)</span> 的祖先，否则会报错。</p>
<p>你需要在不超过 <span class="math inline">\(36\)</span> 次询问之内找出 <span class="math inline">\(x\)</span>。<span class="math inline">\(x\)</span> 是预先设定好的，不会随着询问而改变。<span class="math inline">\(n \le 2\times 10^5\)</span>。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题解
    </div>
    <div class='spoiler-content'>
        <p>先询问 <code>d 1</code> 得到候选点集合，设其大小为 <span class="math inline">\(cnt\)</span>。</p>
<p>每次把当前考虑的点移动到候选点结合的 LCA。</p>
<p>然后求一遍子树候选点集合大小。如果当前点 <span class="math inline">\(x\)</span> 没有一个集合大小大于 <span class="math inline">\(\frac{cnt}{2}\)</span> 的儿子，那么直接问 <code>s x</code> 就可以把候选点的数量减半。否则往哪个唯一的集合大小大于 <span class="math inline">\(\frac{cnt}{2}\)</span> 搜，每次往重儿子走，直到走到一个候选点 <span class="math inline">\(y\)</span>，然后询问 <code>d y</code>，这时候所有的候选点都可以与 <span class="math inline">\(y\)</span> 求距离然后判断是否还是候选点。假设之后的候选点集合的 LCA 为 <span class="math inline">\(z\)</span>，因为 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(z\)</span> 走重儿子走到的，所以在极端情况下 <span class="math inline">\(z\)</span> 还有两个儿子，且大小各为 <span class="math inline">\(\frac{cnt}{3}\)</span>，所以此时问 <code>s z</code> 就可以把候选点数量减至至多 <span class="math inline">\(\frac{n}{3}\)</span>。</p>
<p>综上复杂度是 <span class="math inline">\(2\log_{3}n\)</span> 的，完全三叉树可以卡到此复杂度上限。</p>

    </div>
</div>
<hr />
<p>CF750F New Year and Finding Roots</p>
<p>这是一道交互题。</p>
<p>有一棵高度为 <span class="math inline">\(h\)</span> 的有根完全二叉树，点的编号从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(2^h-1\)</span>。每一次你可以询问某一个点在树上的邻居，现在请你使用不超过 <span class="math inline">\(16\)</span> 次询问找到树根。<span class="math inline">\(T\)</span> 组数据，<span class="math inline">\(T\leq 500,2\leq h \leq 7\)</span>。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题解
    </div>
    <div class='spoiler-content'>
        <p>假设当前在叶子。</p>
<p>直接跳到其父亲，那么我们可以直接得到当前点的深度，设为 <span class="math inline">\(dep\)</span>。</p>
<p>然后询问一次，然后随机在两个出边之间选一条走，如果走错了，那么就会花 <span class="math inline">\(h-dep\)</span> 次走到叶子，这时候这两条出边的另一个就是跳向父亲的。</p>
<p>当 <span class="math inline">\(h=7\)</span> 的时候脸足够黑的话要 <span class="math inline">\(22\)</span> 次，即主链上 <span class="math inline">\(7\)</span> 次，支链上 <span class="math inline">\(\sum_{i=1}^6i=15\)</span> 次。</p>
<p>不难发现越高的点不小心走错花的贡献越多。我们不希望走错，所以考虑当深度足够浅的时候 BFS——这样我们就不存在走错了。</p>
<p>当这个阈值为 <span class="math inline">\(3\)</span> 的时候，我们可能查询的点只有 <span class="math inline">\(17\)</span> 个，如图所示：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2021/03/d03a9df9a7dc5731.png" /></p>
<p>在 <span class="math inline">\(6,12,15,17\)</span> 我们采取 DFS 的策略，在 <span class="math inline">\(4\)</span> 我们就开始 BFS。</p>
<p>这样一共有 <span class="math inline">\(17\)</span> 个点，看似超出了一次，但实际上这 <span class="math inline">\(17\)</span> 个点中一定有根，如果前 <span class="math inline">\(16\)</span> 次询问都没问到根，那么最后剩下的就一定是根。</p>
<p>实际上我们并不需要找叶子。我们随机一个点，然后随机走直到走到了叶子，这时候我们可以通过路径长度来确定一个深度比较浅的点。如上图如果我们一开始走的 <span class="math inline">\(10\sim 14\)</span>，那么我们就可以直接确定 <span class="math inline">\(6\)</span> 号点的深度 <span class="math inline">\(4\)</span>，因为深度大于 <span class="math inline">\(4\)</span> 的点走不出一个长度为 <span class="math inline">\(6\)</span> 的路径。</p>
<p>不难发现这样确定点不会劣于从叶子开始的做法。故 <span class="math inline">\(16\)</span> 次足够了。</p>

    </div>
</div>
<hr />
<p>CF1368F Lamps on a Circle</p>
<p>这是一道交互题。</p>
<p>Alice 和 Bob 在玩游戏，有 <span class="math inline">\(n\)</span> 盏灯排成一个<strong>圈</strong>，顺时针标号为 <span class="math inline">\(1\sim n\)</span>，初始所有灯都是关着的。</p>
<p>每轮操作为：</p>
<ul>
<li>Alice 选择一个 <span class="math inline">\(k\in [1,n]\)</span> 然后打开任意 <span class="math inline">\(k\)</span> 盏灯（可以重复打开）。</li>
<li>Bob 关闭一段长度为 <span class="math inline">\(k\)</span> 的连续区间的灯。</li>
</ul>
<p>Alice 可以在每轮开始时选择停止游戏，这局游戏的得分就是当前亮着的灯的数量。</p>
<p>Alice 想要最大化得分，Bob 想要最小化得分。</p>
<p>你需要使用不超过 <span class="math inline">\(10^4\)</span> 次操作达到得分上界。</p>
<p><span class="math inline">\(n\le 1000\)</span>。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        题解
    </div>
    <div class='spoiler-content'>
        <p>假设我们把序列分成若干段，相邻之间有至少一个空位，那么最后的答案就是 <span class="math inline">\(\sum size-\max size\)</span>。</p>
<p>因为你在修改的时候，如果至少有二个段，Bob 就不能把你所有的修改都抵掉。所以你最后总会剩且只剩一段，而 Bob 也总能把你企图修改的最大的一段的变回来。</p>
<p>假设你要分 <span class="math inline">\(x\)</span> 段，那一定是平均分最优。所以可以直接枚举段数求该段数下的贡献。</p>
<p>每一轮 Alice 都可以多点亮至少一个灯，所以 <span class="math inline">\(10^4\)</span> 足够了。</p>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>妙题</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的回文划分</title>
    <url>/2021/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>定义一个串 <span class="math inline">\(S\)</span> 的划分 <span class="math inline">\(s_1,s_2...s_k\)</span> 为回文划分当且仅当 <span class="math inline">\(s_1,s_2...s_k\)</span> 都是回文串。</p>
<p>现在考虑求一个串 <span class="math inline">\(S\)</span> 的回文划分数。<span class="math inline">\(1\leq |S| \leq 10^6\)</span>。</p>
<a id="more"></a>
<hr />
<p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始，且 <span class="math inline">\(S[l:r]\)</span> 为字符串 <span class="math inline">\(S\)</span> 中 <span class="math inline">\(s[l],s[l+1]...s[r]\)</span> 这个子串。</p>
<p>考虑设 <span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(i\)</span> 结尾的这个前缀的回文划分方案数。</p>
<p>转移显然，即 <span class="math inline">\(f[i]=\sum f[i-L]~(S[i-L+1:i] \text{是回文串})\)</span>。</p>
<p>如果枚举 <span class="math inline">\(i,L\)</span> 再暴力判断，复杂度会达到严格 <span class="math inline">\(O(|S|^3)\)</span>，如果用一些方法预处理快速判断一个串是不是回文串，可以做到严格 <span class="math inline">\(O(|S|^2)\)</span>。</p>
<p>考虑优化，对于快速找到回文 Border，可以使用回文自动机，这样每次在当前节点跳 <span class="math inline">\(parent\)</span> 边跳到的都是回文后缀，这样就可以直接转移。复杂度是 <span class="math inline">\(O(\sum_i \text{以 i 结尾的回文后缀个数})\)</span>，在随机数据下跑得很快。但是这样显然可以被 <span class="math inline">\(aa...aa\)</span> 卡到 <span class="math inline">\(O(|S|^2)\)</span>。故考虑进一步优化。</p>
<blockquote>
<p>引理 <span class="math inline">\(1\)</span> : 对于一个串 <span class="math inline">\(S\)</span> 的所有长度大于 <span class="math inline">\(\frac{|S|}{2}\)</span> 的回文 Border，它们的长度形成一个等差数列。</p>
</blockquote>
<p>证明：拿出最长的回文 Border <span class="math inline">\(T\)</span>，那么 <span class="math inline">\(S\)</span> 就存在周期 <span class="math inline">\(|S|-|T|\)</span>，所以长度为 <span class="math inline">\(|S|-2(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border，长度为 <span class="math inline">\(|S|-3(|S|-|T|)\)</span> 的这个后缀也是一个回文 Border……把这一组 Border 去掉之后，剩下的回文 Border 长度一定小于等于 <span class="math inline">\(\frac{|S|}{2}\)</span>，不然的话 <span class="math inline">\(T\)</span> 就不会是最长的回文 Border。</p>
<p>这样在 DP 中可以转移的点也可以被分成 <span class="math inline">\(\log_2|S|\)</span> 个等差数列。我们就可以这么做：预处理 <span class="math inline">\(F[i][j]\)</span> 表示 <span class="math inline">\(f[i]+f[i-j]+...\)</span>，那么对于一个等差数列，如果其公差小于一个阈值，就直接查表，否则暴力跳。这样复杂度上限可以被优化到 <span class="math inline">\(O(|S|\sqrt{|S|\log_2|S|})\)</span>，实际效率未知。</p>
<p>我们把某个等差数列拿出来，看看它有什么性质。</p>
<p><img src="https://s3.ax1x.com/2021/01/07/smA5qg.png" /></p>
<p>这是 <span class="math inline">\(4\)</span> 个形成等差数列的 Border。</p>
<p>我们把每个 Border 按照比恰好比它长的 Border 的回文中心对称过去，可以发现它的开头是恰好比它长的 Border 的开头，结尾都在同一个位置。</p>
<p>如果设 <span class="math inline">\(g[x]\)</span> 为在回文自动机上以 <span class="math inline">\(x\)</span> 为末项的回文 Border 的 <span class="math inline">\(\sum f\)</span>，把上图的串从上到下依次编号成 <span class="math inline">\(1,2,3,4\)</span>，那么我们可以发现，对于现在要求的 <span class="math inline">\(g[4]\)</span>，有很大一部分已经被 <span class="math inline">\(g[3]\)</span> 算过了（<span class="math inline">\(g[3]\)</span> 即红色条纹部分，<span class="math inline">\(g[4]\)</span> 即黑色条纹部分），因为我们到现在这个位置计算 <span class="math inline">\(g[4]\)</span> 时，一定会先走过计算 <span class="math inline">\(g[3]\)</span> 的位置。所以就只需要使 <span class="math inline">\(g[4]=g[3]\)</span> 且把 <span class="math inline">\(g[4]\)</span> 额外加上【除掉当前等差数列最小的 Border 的那个 <span class="math inline">\(f\)</span> 】即可。</p>
<p>这样就可以在 <span class="math inline">\(O(n\log_2 n)\)</span> 的时间内解决该题。</p>
<!-- more -->
<p>直接讨论回文划分太抽象了，举个具体例子。</p>
<h5 id="cf932g-palindrome-partition">CF932G Palindrome Partition</h5>
<p>给定一个串 <span class="math inline">\(S\)</span>，把串分为偶数段。</p>
<p>假设分为了 <span class="math inline">\(s_1,s_2,s_3....s_k\)</span>。</p>
<p>求，满足 <span class="math inline">\(s_1=s_k,s_2=s_{k−1}.....\)</span> 的方案数。</p>
<p><span class="math inline">\(2\leq |S| \leq 10^6\)</span>，方案数对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<hr />
<h5 id="solution">Solution:</h5>
<p>乍一看这个题和回文划分没有什么关系，但是我们不妨分析一手。</p>
<p>为了方便，我们定义字符串下标从 <span class="math inline">\(1\)</span> 开始。</p>
<p>考虑逐个考虑 <span class="math inline">\(s_1\)</span> 和 <span class="math inline">\(s_k\)</span>，<span class="math inline">\(s_2\)</span> 和 <span class="math inline">\(s_{k-1}\)</span> 这样的匹配对。我们发现当剩余串的长度固定的时候，留下的是中间某一个固定的段，这样就不是很好，因为我们很难得到中间某个串的信息。所以尝试把这个串修改一下使得每次分段都是一个连续的区间，即改成 <span class="math inline">\(s[1]s[n]s[2][n-1]...\)</span>，这样我们就可以发现，对于一个分段，它都是一个长度为偶数的连续区间，且该串为回文串。</p>
<p>这样问题就转化成了：把一个串 <span class="math inline">\(S\)</span> 分解成若干个长度为偶数的回文串的方案数。直接用上面的算法做即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN], t[MAXN];</span><br><span class="line"><span class="keyword">int</span> child[MAXN &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], parent[MAXN &lt;&lt; <span class="number">1</span>], mxlen[MAXN &lt;&lt; <span class="number">1</span>], cnt = <span class="number">2</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN &lt;&lt; <span class="number">1</span>], bot[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFail</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (now &amp;&amp; s[pos] != s[pos - mxlen[now] - <span class="number">1</span>])</span><br><span class="line">    now = parent[now];</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = (i &amp; <span class="number">1</span>) ? t[i / <span class="number">2</span> + <span class="number">1</span>] : t[n - i / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">//  cerr &lt;&lt; (s + 1) &lt;&lt; endl;</span></span><br><span class="line">  parent[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  mxlen[<span class="number">1</span>] = <span class="number">0</span>, mxlen[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    child[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ch = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    last = GetFail(last, i);</span><br><span class="line">    <span class="keyword">if</span> (child[last][ch])</span><br><span class="line">      last = child[last][ch];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ++cnt;</span><br><span class="line">      child[last][ch] = cnt;</span><br><span class="line">      mxlen[cnt] = mxlen[last] + <span class="number">2</span>;</span><br><span class="line">      parent[cnt] = child[GetFail(parent[last], i)][ch];</span><br><span class="line">      last = cnt;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[parent[cnt]] * <span class="number">2</span> &gt; mxlen[cnt] &amp;&amp; (!d[parent[cnt]] || mxlen[cnt] - mxlen[parent[cnt]] == d[parent[cnt]])) &#123;</span><br><span class="line">        d[cnt] = mxlen[cnt] - mxlen[parent[cnt]], bot[cnt] = bot[parent[cnt]];</span><br><span class="line">        d[parent[cnt]] = mxlen[cnt] - mxlen[parent[cnt]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        d[cnt] = <span class="number">0</span>, bot[cnt] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI cur = last; cur; cur = parent[bot[cur]]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bot[cur] != cur)</span><br><span class="line">        g[cur] = g[parent[cur]];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g[cur] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (mxlen[bot[cur]])</span><br><span class="line">        g[cur] = (g[cur] + f[i - mxlen[bot[cur]]]) % mod;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        f[i] = (f[i] + g[cur]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>广义二项式定理</title>
    <url>/2020/09/26/%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>提前介绍一下广义的组合数，组合数 <span class="math inline">\(\tbinom{n}{m}\)</span> 的定义是 <span class="math inline">\(\frac{n\times (n-1)\times ... \times (n-m+1)}{m!}\)</span>，广义下的组合数只需要保证 <span class="math inline">\(m\)</span> 为非负整数，<span class="math inline">\(n\)</span> 可以是任意实数。</p>
<a id="more"></a>
<p>对于广义的组合数，有个恒等式 <span class="math inline">\(\tbinom{n}{m}=\tbinom{m-n-1}{m}\times (-1)^{m}\)</span> 。</p>
<blockquote>
<p>两式的分母都是一样的，对于左式，其分子是 <span class="math inline">\(n\times (n-1)\times ... \times (n-m+1)\)</span>，对于右式，其分子是 <span class="math inline">\((m-n-1)\times ((m-n-1)-1) \times ... \times ((m-n-1)-m+1)\)</span>，可以发现右式分子的每个单项式和左式分子的单项式一一对应，并且互为相反数，那么最后乘上一个 <span class="math inline">\((-1)^m\)</span> 即可。</p>
</blockquote>
<p>有个很妙的记忆方法：两级反转（和艾克真的一点关系都没有 /doge）连续变化两次，设未知数，下标不变，上标用 <span class="math inline">\(m-1\)</span> 去减，即：<span class="math inline">\(\tbinom{n}{m}=\tbinom{m-?-1}{m}\times (-1)^{2m}\)</span>，那么可以很快得出问号是 <span class="math inline">\(m-n-1\)</span> 。当然直接用上文的证明去推更 nice。</p>
<p>广义二项式定理： <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 这里的 <span class="math inline">\(k\)</span> 可以是任意实数，一般会用在 <span class="math inline">\(k\)</span> 为负整数的时候，那么我们在下面约定所有出现的 <span class="math inline">\(k\)</span> 都是<strong>负整数</strong>，且为了方便理解，设 <span class="math inline">\(n=-k\)</span>。</p>
<p>考虑用生成函数去解释，先把 <span class="math inline">\((a+b)^{k}\)</span> 看成 <span class="math inline">\((a+bx)^{k}\)</span> 那么最后只要把 <span class="math inline">\(x\)</span> 看成 <span class="math inline">\(1\)</span> 即可。</p>
<p>先考虑最基本的情况：<span class="math inline">\((1-x)^{-n}\)</span> 。</p>
<p>根据数学知识可以知道上式就是 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}\)</span> 。</p>
<p>根据生成函数，可以知道 <span class="math inline">\((1-x)^{-1}=\sum_{i=0}^{\infty} x^i\)</span> 。</p>
<blockquote>
<p>设 <span class="math inline">\(S=1+x+x^2+...\)</span>，那么 <span class="math inline">\(xS=x+x^2+x^3+...\)</span>，那么 <span class="math inline">\(S-xS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-x}\)</span> 即 $ (1-x)^{-1}$</p>
</blockquote>
<p>那么 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\left( \sum_{i=0}^{\infty} x^i \right)^{n}\)</span> 。</p>
<p>考虑从组合意义上去计算这个式子：你有 <span class="math inline">\(n\)</span> 种球，每种球无限个，你需要从这 <span class="math inline">\(n\)</span> 种球中选择一共 <span class="math inline">\(i\)</span> 个球，每种球至少选 <span class="math inline">\(0\)</span> 个，其方案数就是 <span class="math inline">\(x^i\)</span> 的系数。那么使用隔板法就有 <span class="math inline">\(\tbinom{i+n-1}{n-1}\)</span> 。</p>
<p>所以 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}x^i\)</span> 。</p>
<p>那么我们再在 <span class="math inline">\(x\)</span> 前面加上一个系数 <span class="math inline">\(p\)</span> ，即求 <span class="math inline">\((1-px)^{-1}\)</span> 。它是等于 <span class="math inline">\(\sum_{i=0}^{\infty} p^ix^i\)</span> 。</p>
<blockquote>
<p>设 <span class="math inline">\(S=1+px+p^2x^2+...\)</span> ，那么 <span class="math inline">\(pxS=px+p^2x^2+p^3x^3+...\)</span>，那么 <span class="math inline">\(S-pxS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-px}\)</span> 即 <span class="math inline">\((1-px)^{-1}\)</span> 。</p>
</blockquote>
<p>那再按照上面的方法去推，就有 <span class="math inline">\(\left( (1-px)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}p^ix^i\)</span></p>
<p>回到一开始的问题，<span class="math inline">\((a+bx)^k=a^k \left( 1-(-\frac{b}{a}x) \right)^k\)</span> 。</p>
<p>那么就有 <span class="math inline">\((a+bx)^k=a^k \sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-\frac{b}{a})^ix^i\)</span> 。整理一下，<span class="math inline">\(\sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-1)^ia^{k-i}b^ix^i\)</span> 。</p>
<p>注意了，这里等式内部的组合数的 <span class="math inline">\(k\)</span> 前面都带个负号，因为上文在推导过程中，设的是 <span class="math inline">\(n=-k\)</span>，所以在组合数中的 <span class="math inline">\(n\)</span> 才是正号。</p>
<p>再根据文首提及的那个恒等式，就有 <span class="math inline">\(\tbinom{i-k-1}{-k-1}=\tbinom{i-k-1}{i}=\tbinom{k}{i}\times (-1)^i\)</span> 。</p>
<p>可以发现两个 <span class="math inline">\((-1)^i\)</span> 抵掉了，那么 <span class="math inline">\((a+bx)^k=\sum_{i=0}^{\infty} \tbinom{k}{i}a^{k-i}b^ix^i\)</span> 。</p>
<p>把 <span class="math inline">\(x=1\)</span> 带入原式，即可得 <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>快读相关</title>
    <url>/2021/02/18/%E5%BF%AB%E8%AF%BB%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>琢磨了一下午，在输入输出流上面有了一点点自己的理解。</p>
<a id="more"></a>
<hr />
<p>关于重载运算符读入结构体。</p>
<p>对于一个结构体，如果要读入它我们是不能直接用 <code>cin</code> 的，但是我们可以重载输入流的运算符 <code>&gt;&gt;</code>，从而使得它可以支持这个操作。</p>
<p>输入流 <code>cin</code> 的数据类型是 <code>istream</code>。我们不妨把 <code>&gt;&gt;</code> 看成是一个二元运算符，其左操作数是一个 <code>istream</code> 的变量，右操作数是一个需要读入的东西。</p>
<p>不难发现，我们有时候会连写 <code>cin</code>，如 <code>cin &gt;&gt; a &gt;&gt; b</code>，注意到 <code>&gt;&gt;</code> 是左结合的，所以可以看成是 <code>(cin &gt;&gt; a) &gt;&gt; b</code>。可以发现后面的操作符少了一个左操作数，所以 <code>cin &gt;&gt; a</code> 的返回值应该还是 <code>cin</code> 这个输入流变量。</p>
<p>这样我们就有了一个大致的想法，重载运算符 <code>&gt;&gt;</code>，左操作数读入 <code>istream</code>，右操作数读入 <code>structName</code>，读入完之后返回 <code>istream</code>。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, structName &amp;a) &#123;</span><br><span class="line">  <span class="comment">/* Input a */</span></span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把这个重载写在全局是没有问题的，但是如果写在结构体内就会 CE。</p>
<p>这是结构体的特性导致的，在重载二元运算符的时候，其第一个参数会默认为它自己（比如在重载矩阵乘法的时候），所以需要加上 <code>friend</code> 标识使得它合法。</p>
<p>即如果把重载写在全局，那么就不需要加 <code>friend</code> 标识，否则必须在重载定义前加。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, structName &amp;a) &#123;</span><br><span class="line">  <span class="comment">/* Input a */</span></span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，输出也是这么重载。输出流的类型是 <code>ostream</code>，标识是 <code>cout</code>。其它规则与输入一样。下面给出一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, structName a) &#123;</span><br><span class="line">  <span class="comment">/* Output a */</span></span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>关于重载运算符的快读。</p>
<p>快读用的时候不太爽，因为如果要读很多个数就要一个一个 <code>read</code>。考虑用上面的重载运算符优化。</p>
<p>但是如果直接重载 <code>&gt;&gt;,&lt;&lt;</code>，而且用输入输出流的 <code>istream,ostream</code> 的话，这个快读是无效的，因为 <code>c++</code> 内部的读入就是通过重载实现。</p>
<p>所以考虑自己定义一个读入结构体 <code>Input</code>。重定义左操作数为结构体 <code>Input</code> 右操作数为整形的 <code>&gt;&gt;</code>，然后在运算内写快读，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> Input&amp; <span class="keyword">operator</span> &gt;&gt; (T &amp;n) &#123;</span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; fin;</span><br></pre></td></tr></table></figure>
<p>在使用的时候，<code>fin</code> 和 <code>cin</code> 是类似的用法。如果需要增加功能，如输入字符串等，就直接新定义 <code>&gt;&gt;</code> 即可。因为根据 <code>c++ template</code> 的性质，函数匹配会优先匹配实参，也就是说如果在这个结构体内还有 <code>inline Input&amp; operator &gt;&gt; (char *s) &#123;&#125;</code>，然后在输入的时候右操作数是 <code>char*</code> 的话，会优先匹配这个函数。</p>
<p>快输同理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">  <span class="keyword">char</span> ouf[<span class="number">1000000</span>], *P1 = ouf, *P2 = ouf;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span> </span>&#123; fwrite(ouf, <span class="number">1</span>, P2 - P1, <span class="built_in">stdout</span>); P2 = P1; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    *(P2++) = ch;</span><br><span class="line">    <span class="keyword">if</span> (P2 == P1 + <span class="number">1000000</span>) Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> Output&amp; <span class="keyword">operator</span> &lt;&lt; (T n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) pc(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) pc(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) pc(*(--O1));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> Output&amp; <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">char</span> ch) &#123; pc(ch); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  ~Output() &#123; Flush(); &#125;</span><br><span class="line">&#125; fout;</span><br></pre></td></tr></table></figure>
<p>因为我们这里使用的是 <code>fwrite</code>，所以在程序结束的时候可能在输出数组中仍然有未输出的字符，这时候就需要 <code>Flush</code>。但是为了避免在程序结束后忘记 <code>Flush</code>，我们给 <code>Output</code> 类型的结构体一个析构函数，在程序结束析构它的时候进行 <code>Flush</code>。</p>
<p>还有一点就是不管是快读还是快输，函数的返回值一定要是 <code>Input/Output &amp;</code>，即传引用。不然在 <code>return *this</code> 的时候会把这个结构体复制一份返回，这不是我们期望看到的。</p>
<p>但是这样还是有点奇怪，因为 <code>fin</code> 和 <code>fout</code> 我们不习惯写，我们可以 <code>#define cin fin</code>，<code>#define cout fout</code>。而且可以 <code>define endl</code> 等。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结</title>
    <url>/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>数据结构的一些小 trick。</p>
<a id="more"></a>
<h3 id="并查集">并查集</h3>
<h4 id="支持撤销">支持撤销</h4>
<p>每次合并的时候按照集合的大小进行启发式合并，并且用一个操作栈记录本次操作。</p>
<p>在撤销一次操作的时候，只需要按照记录还原并查集即可。</p>
<p>合并查询操作单次 <span class="math inline">\(O(\log n)\)</span>，撤销操作单次 <span class="math inline">\(O(1)\)</span>。这种并查集在一些离线算法下有大用处。</p>
<h4 id="维护不可逆的覆盖操作">维护不可逆的覆盖操作</h4>
<p>考虑这么一道题目：给一棵 <span class="math inline">\(n\)</span> 个点的树，有 <span class="math inline">\(m\)</span> 次操作，每次操作会把一条路径上的点染色，且颜色会覆盖之前染的颜色，求最后每个点的颜色，不强制在线。<span class="math inline">\(n\leq 10^6,m\leq 5\times 10^6\)</span>。</p>
<p>一种 naive 的思想是用树链剖分和线段树维护颜色，但是这样是 <span class="math inline">\(m\log^2 n\)</span> 的。</p>
<p>考虑把操作倒序，那么每次执行的是不可逆的染色操作。</p>
<p>对每个点维护并查集，表示它到根路径上第一个需要被染色的点是什么，一开始显然指向自己。</p>
<p>如果一个点被染色了，那么就把它的边连向它父亲。每次染色就直接按照并查集的链接暴力跳，然后染色即可。</p>
<p>因为每个点最多被染色一次，在并查集使用 <span class="math inline">\(n\alpha(n)\)</span> 复杂度的版本下，总复杂度仅为 <span class="math inline">\(O(n\alpha(n))\)</span>。</p>
<p>这个 trick 虽然可能不会单独成题，但是可能会被穿插到一些题目中。它对复杂度的优化还是挺大的。</p>
<h3 id="栈">栈</h3>
<h4 id="对顶栈">对顶栈</h4>
<p>例题：你需要动态维护一个长度为 <span class="math inline">\(n\)</span> 序列，有 <span class="math inline">\(q\)</span> 个操作，每个操作为头尾加删元素或查询一些信息。</p>
<p>假设只能从尾部加删，那么我们就可以维护一个类似于栈的东西，每次加进来一个就把它压入栈，并更新一些信息，删掉一个就把它从栈弹掉，并把信息复原。</p>
<p>现在我们两头都要支持加删，一种直接的想法是维护两个栈，并且把它们的栈底顶到一起，这样头尾加删和普通的加删就没有什么区别，只有查询的时候需要额外计算跨过两个栈的贡献。</p>
<p>但是这样会出现一个问题，可能有一次删除会把一个栈的栈底给删了，这样原先的结构就被破坏了，这是很麻烦的。但实际上只需要再从序列中间开始，重新构造两个栈就可以了，这样总的重新构造的点的数目的上限是 <span class="math inline">\(\max(n,q)\)</span> 的。</p>
<p>因为维护了这两个栈的顶着的，所以我们称它为对顶栈。</p>
<p>好像这种套路就能干这一件事情，博主也就在某次考试中遇到了一次，不过了解一下它的思想总是好的。</p>
<h4 id="栈-1">2048 栈</h4>
<p>因为没得名字，随手取了一个。（侵删）</p>
<p>当你需要动态维护一个不好加入元素的东西的时候（如 AC 自动机、凸包等），你就可以用这个 trick，花费额外的一个 <span class="math inline">\(\log\)</span> 的代价去较为方便的维护它。</p>
<p>这里就用 AC 自动机举例。</p>
<p>维护一个栈，每个栈内的元素都是一个 AC 自动机，并且记录下 AC 自动机内的字符串数目。</p>
<p>对于一次加入，就在栈顶加入一个新的 AC 自动机，内部保存这一次加入的这一个字符串。</p>
<p>如果此时栈顶的两个 AC 自动机内的字符串数目相同，就把这两个 AC 自动机合并，并且建出一个新的 AC 自动机，一直这样直到栈顶的两个 AC 自动机不满足这个条件。</p>
<p>不难发现，每次更新栈的时候，AC 自动机的大小就像 2048 一样，相同即合并，且都是 <span class="math inline">\(2\)</span> 的倍数。故每个字符串只会在它所在的 AC 自动机的大小为 <span class="math inline">\(2^k\)</span> 的时候有一个贡献，所以总复杂度是总长度乘上 <span class="math inline">\(\log\)</span> 字符串个数的。</p>
<p>特别的，这个 trick 是可以在线维护的。</p>
<p>boshi 提供了一个题目 <a href="https://www.luogu.com.cn/problem/CF710F">CF710F</a> 。</p>
<h3 id="线段树">线段树</h3>
<h4 id="时间和序列的对调">时间和序列的对调</h4>
<p>一般线段树都是维护的序列信息，如区间和，区间积。</p>
<p>但是在某些问题中，它的操作是区间修改，查询是单点查询，这时候就有一个对调时间和序列的 trick 。</p>
<p>正如 trick 的名字，我们把时间和序列对调，每次一步一步地在序列上面走，同时对时间维护线段树。</p>
<p>那么对于对调前的区间修改，现在就变成了两个单点的修改，对于对调前的查询，现在就变成了一个前缀的查询。</p>
<p>在某些方便不维护前者，而较方便维护后者的题目中，这个 trick 是非常实用的。</p>
<p>比如说 <a href="http://172.16.11.217:5283/problem/170">某场公开的考试题</a>。</p>
<h4 id="懒信息">懒信息</h4>
<p>也是随手取的名字，其实这个 trick 挺常见的。（侵删）</p>
<p>懒标记是不下传的标记，懒信息就是查询的时候不合并的信息。</p>
<p>在一些题目中，对于查询操作，如果各个区间的信息是独立的（也就是说并不需要把区间信息合并就可以得到答案），且合并区间信息的复杂度远大于通过单个区间的信息得到答案的复杂度，就可以把信息懒化。</p>
<p>例题：维护一个序列，支持两个操作：往后面加一个数，查询 <span class="math inline">\(x\)</span> 在区间 <span class="math inline">\([l,r]\)</span> 的排名，操作数 <span class="math inline">\(\leq 10^5\)</span>，保证查询的时候序列长度大于等于 <span class="math inline">\(r\)</span>，强制在线。</p>
<p>先设操作数为 <span class="math inline">\(n\)</span>，序列可能有 <span class="math inline">\(n\)</span> 这么长，所以先开一个长度为 <span class="math inline">\(n\)</span> 的线段树。</p>
<p>每个点维护一个有序的序列，表示它控制区间内的数排序之后的结果。</p>
<p>不难发现每层最多 <span class="math inline">\(n\)</span> 个数，一共 <span class="math inline">\(\log n\)</span> 层，所以空间复杂度 <span class="math inline">\(n \log n\)</span>。</p>
<p>对于每次往后面加数，就把对应位置的数进行更改，并且往上更新，更新的规则是这样的：如果一个点的儿子是满的，那么就更新它，否则就不更新它。</p>
<p>更新的时候可以使用归并排序，复杂度是 <span class="math inline">\(O(len)\)</span> 的，因为更新的规则，每个点只会被更新一次，复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<p>对于查询，naive 的方法是把查询定位到的区间归并，然后看 <span class="math inline">\(x\)</span> 的排名，这样复杂度又回去了。</p>
<p>因为 <span class="math inline">\(x\)</span> 的排名就是 <span class="math inline">\(x\)</span> 前面有多少个数，所以我们没必要把查询定位到的区间合并，直接在每个定位到的区间内查询有多少个数小于 <span class="math inline">\(x\)</span> 即可。使用二分复杂度就是 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>更加复杂一点的还有 <a href="https://uoj.ac/problem/46">UOJ #46</a>。</p>
<h3 id="平衡树">平衡树</h3>
<h4 id="替罪羊树">替罪羊树</h4>
<p>trick 不是这个数据结构，而是它拍扁重构的思想。</p>
<p>如果你要动态维护一棵树，而且想要让它尽量的平衡（树高在 <span class="math inline">\(O(\log)\)</span> 级别），那么就可以通过控制平衡因子拍扁重构。</p>
<p>比较经典的是动态加点，动态维护点分树。因为点分树如果要保证复杂度，需要树高在 <span class="math inline">\(O(\log)\)</span> 级别，而动态加点并不好维护。那么我们就干脆在每次加点的时候，就把这个点看做一个子分治中心，并连向父亲。然后像替罪羊一样，如果某个子树太难看了，就直接拍扁重建。</p>
<p>比较经典的莫过于 <a href="https://www.luogu.com.cn/problem/P3920">[WC2014]紫荆花之恋</a> 了。</p>
<h3 id="根号算法">根号算法</h3>
<h4 id="根号分治">根号分治</h4>
<p>应该是一个比较普及的 trick。</p>
<p>差不多就是小于根号的暴力也无所谓，大于根号的也就根号个东西。</p>
<p>比如出现次数大于根号的数不超过根号个，图中度数大于根号的点不超过根号个等。</p>
<p>这个 trick 比较简单，但是也容易被忽视，注意一下就可以了。</p>
<p>这方面的话可能比较简单，<a href="https://www.luogu.com.cn/problem/P3396">哈希冲突</a> 是一个比较好的例子。</p>
<h4 id="时间分块">时间分块</h4>
<p>似乎对时间轴操作的 trick 都挺重要的。</p>
<p>如标题所说，就是把所有的操作按照时间分块，那么在块的内部就有一个很好的性质：时间线的变动量不超过块大小。所以就可以在块内按照其它东西排序，对于询问就只需要动时间线，可能会更加方便。</p>
<p>比如说 <a href="https://www.luogu.com.cn/problem/P5443">[APIO2019]桥梁</a>。</p>
<p>当然，一些其它的题目也可以用这个思想，可以把时间线的变动看做是别的东西的变动，比如 <a href="https://www.luogu.com.cn/problem/P3247">[HNOI2016]最小公倍数</a>。</p>
<h4 id="操作分块定期重构">操作分块（定期重构）</h4>
<p>也是一个比较妙的 trick。</p>
<p>在一些题目中，如果操作不好应用于序列，且很多个操作可以放一起修改序列，且操作对查询的影响比较好求，就可以用这个 trick。</p>
<p>这个 trick 的意思是先把所有的操作屯着，查询的时候可以先在原序列查，然后再去屯着的操作里面查。当屯着的操作达到一个上限的时候，就把它们一起放出来，把整个序列翻新一次。</p>
<p>这个 trick 也不常见，不过其思想也十分有意义。</p>
<h3 id="其它">其它</h3>
<h4 id="树的坐标表示">树的坐标表示</h4>
<p>其实也不是什么高科技，也就标题唬人。</p>
<p>把树上每个点的坐标看做是 <span class="math inline">\((dfn,dep)\)</span>。</p>
<p>这样的话，一个子树就代表着一个只有左右边界上下无界的矩形，子树内离当前点距离为某个范围内的点就对应着一个矩形，我们就可以把树上问题转化成二维平面上问题。</p>
<p><a href="https://ac.nowcoder.com/acm/contest/6944/C">这道题</a> 是个不错的例子。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列相关</title>
    <url>/2020/11/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>设 <span class="math inline">\(F\)</span> 是斐波那契数列，其定义是对于 <span class="math inline">\(x\leq 2\)</span>，<span class="math inline">\(F(x)=1\)</span>；对于 <span class="math inline">\(x\geq 3\)</span>，<span class="math inline">\(F(x)=F(x-1)+F(x-2)\)</span>。</p>
<a id="more"></a>
<h4 id="gcdfxfyfgcdxy">1. <span class="math inline">\(\gcd(F(x),F(y))=F(gcd(x,y))\)</span> 。</h4>
<p>一个非常实用的结论。下面考虑证明。</p>
<h5 id="引理-1fxfytimes-fx-y1fy-1times-fx-y">引理 1：<span class="math inline">\(F(x)=F(y)\times F(x-y+1)+F(y-1)\times F(x-y)\)</span>。</h5>
<p>        把递推式逐级展开就可以得到这个式子。</p>
<p>        即 <span class="math inline">\(F(x)=F(x-1)+F(x-2)\Rightarrow F(x)=2F(x-2)+F(x-3)\Rightarrow F(x)=3F(x-3)+2F(x-4)...\)</span></p>
<h5 id="引理-2gcdfxfx-11">引理 2：<span class="math inline">\(\gcd(F(x),F(x-1))=1\)</span>。</h5>
<p>        仍然是把递推式展开迭代。</p>
<p>        即 <span class="math inline">\(\gcd(F(x),F(x-1))=\gcd(F(x-2)+F(x-1), F(x-1))=\gcd(F(x-2),F(x-1))...\)</span>。最后就可以得到 <span class="math inline">\(\gcd(F(2),F(1))\)</span>，这时结果显然是 <span class="math inline">\(1\)</span>。</p>
<p>有了这两个引理就可以证明上述结论了。</p>
<p>先假设 <span class="math inline">\(x&gt;y\)</span>，那么 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(y)\times F(x-y+1)+F(y-1)\times F(x-y),F(y))\)</span>。把这个式子套用上述两个引理，就有 <span class="math inline">\(\gcd(F(x),F(y))=\gcd(F(x-y),F(y))\)</span>。可以发现这就是一个辗转相减的形式，直接套用欧几里得就有 <span class="math inline">\(\gcd(F(x),F(y))=F(\gcd(x,y))\)</span>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数学习笔记</title>
    <url>/2020/09/26/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="下降幂和上升幂">下降幂和上升幂</h4>
<p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次下降幂记作 <span class="math inline">\(x^{\underline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x-i)\)</span> 。</p>
<p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次上升幂记作 <span class="math inline">\(x^{\overline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x+i)\)</span>。</p>
<a id="more"></a>
<h4 id="第一类斯特林数">第一类斯特林数</h4>
<p><span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}\)</span> 表示第一类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个圆排列的方案数。圆排列不能为空。</p>
<p>第一类斯特林数有一个递推式，<span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}=\begin{bmatrix} n-1 \\ i \end{bmatrix}\times(n-1)+\begin{bmatrix} n-1 \\ i-1 \end{bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个圆排列，要么就跟在某个数的后面。</p>
<h4 id="第二类斯特林数">第二类斯特林数</h4>
<p><span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}\)</span> 表示第二类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个无标号的集合的方案数。集合不能为空。</p>
<p>第二类斯特林数有一个递推式，<span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}=\begin{Bmatrix}n-1 \\ i\end{Bmatrix}\times i+\begin{Bmatrix}n-1 \\ i-1\end{Bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个集合，要么就放在之前的某个集合里面。</p>
<h4 id="斯特林数和自然幂下降幂上升幂的关系">斯特林数和自然幂、下降幂、上升幂的关系</h4>
<p>对于自然幂和下降幂，有这么一个式子。<span class="math inline">\(n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\)</span>。</p>
<p>考虑从组合意义来理解它。<span class="math inline">\(n^m\)</span> 相当于是把 <span class="math inline">\(m\)</span> 个有标号的球放入 <span class="math inline">\(n\)</span> 个有标号的盒子的方案数，考虑枚举有多少个盒子有球，假设为 <span class="math inline">\(i\)</span>，那么选盒子的方案就是 <span class="math inline">\(\begin{pmatrix}n \\ i\end{pmatrix}\)</span>，然后把 <span class="math inline">\(m\)</span> 个球放到这 <span class="math inline">\(i\)</span> 个盒子里面去，方案是 <span class="math inline">\(\begin{Bmatrix}m \\ i\end{Bmatrix}\)</span>，而因为第二类斯特林数的集合是无标号的，这里是有标号的，所以最后需要乘上一个 <span class="math inline">\(i!\)</span>，然后把组合数展开，就得到上面的那个式子。</p>
<p>对于自然幂和上升幂，有这么一个式子。<span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}n^i\)</span> 。</p>
<p>考虑用数学归纳法来证明它，对于 <span class="math inline">\(m=0\)</span> 式子显然成立，假设现在已经证明对于 <span class="math inline">\(m\leq k-1\)</span> 式子成立，需要证明对于 <span class="math inline">\(m=k\)</span> 式子成立。</p>
<p><span class="math display">\[
\begin{split}
n^{\overline{k}}&amp;=n^{\overline{k-1}}\times(n+k-1)\\
&amp;=n^{\overline{k-1}}\times n+n^{\overline{k-1}}\times(k-1)\\
&amp;=\sum_{i=0}^{k-1}\begin{bmatrix}k-1 \\ i\end{bmatrix}n^{i+1}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~\\
&amp;=\sum_{i=1}^{k-1}\begin{bmatrix}k-1 \\ i-1\end{bmatrix}n^{i}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~~~~\\
&amp;=\sum_{i=0}^k\begin{bmatrix}k \\ i\end{bmatrix}n^i
\end{split}
\]</span></p>
<p>故可以证明原式子成立。</p>
<h4 id="斯特林反演">斯特林反演</h4>
<h5 id="反转公式-i">反转公式 I</h5>
<p><span class="math inline">\(x^{\overline{k}}=(-1)^k(-x)^{\underline{k}}\)</span>，<span class="math inline">\(x^{\underline{k}}=(-1)^k(-x)^{\overline{k}}\)</span>。</p>
<p>这两个式子把它们拆开就可以证明相等了。</p>
<h5 id="反转公式-ii">反转公式 II</h5>
<p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}\begin{Bmatrix}i \\ m\end{Bmatrix}=[m==n]\)</span></p>
<p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{Bmatrix}n \\ i\end{Bmatrix}\begin{bmatrix}i \\ m\end{bmatrix}=[m==n]\)</span></p>
<p>对于第二个证明如下： <span class="math display">\[
\begin{split}
n^m&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\
&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i(-n)^{\overline{i}}\\
&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix} i \\ j \end{bmatrix}(-n)^j\\
&amp;=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m \\ i\end{Bmatrix}\begin{bmatrix} i \\ j \end{bmatrix}(-1)^{i-j}\\
\end{split}
\]</span> 把 <span class="math inline">\(n\)</span> 看成是一个未知数时，对于一个多项式 <span class="math inline">\(\sum a_in^i\)</span>，<span class="math inline">\(n^m\)</span> 可以且仅可以用 <span class="math inline">\(a_mn^m\)</span> 来表示，所以最后的式子只有 <span class="math inline">\(j=m\)</span> 的时候为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>对于第一个式子，有 <span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}(-1)^i(-n)^i\)</span>，把后面的自然幂展开成下降幂，然后再推一推就可以类似于上面讨论证明。</p>
<h5 id="斯特林反演公式">斯特林反演公式</h5>
<p><span class="math inline">\(f(n)=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}f(i)\)</span>。</p>
<p>和二项式反演类似，只需要证明一个方向，另一个方向显然成立。</p>
<p>正向证明如下： <span class="math display">\[
\begin{split}
g(n)&amp;=\sum_{i=0}^n[i==n]g(i)\\
&amp;=\sum_{i=0}^n\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\
&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\sum_{i=0}^j\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\
&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}f(j)
\end{split}
\]</span></p>
<h4 id="第一类斯特林数求自然数幂和">第一类斯特林数求自然数幂和</h4>
<p>设 <span class="math inline">\(\sum_{i=1}^n i^k\)</span> 为 <span class="math inline">\(S_k(n)\)</span>。 <span class="math display">\[
\begin{split}
&amp;\because n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\
&amp;\therefore n^{\underline{m}}=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\therefore n^m=n^{\underline{m}}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\therefore \sum_{n=1}^X n^m=\sum_{n=1}^Xn^{\underline{m}}-\sum_{n=1}^X\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\begin{split}
\therefore S_m(X)&amp;=m!\sum_{n=1}^X\begin{pmatrix}n \\ m\end{pmatrix}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}\sum_{n=1}^Xn^i\\
&amp;=m!\begin{pmatrix}X+1 \\ m+1\end{pmatrix}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)\\
&amp;=\frac{(X+1)^{\underline{m+1}}}{m+1}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)~\\
\end{split}
\end{split}
\]</span> 故 <span class="math inline">\(S_m(X)\)</span> 可以在 <span class="math inline">\(m^2\)</span> 的时间复杂度内求得，且不要求模数是质数。</p>
<h4 id="快速求两类斯特林数">快速求两类斯特林数</h4>
<h5 id="第一类斯特林数行">第一类斯特林数·行</h5>
<p>我们知道 <span class="math inline">\(x^{\overline n}=\prod \begin{bmatrix}n \\ i\end{bmatrix}x^i\)</span> ，那直接算出 <span class="math inline">\(x(x+1)(x+2)...(x+n-1)\)</span> 就行了，分治 FFT 解决，时间复杂度 <span class="math inline">\(n\log^2 n\)</span>。</p>
<p>但是这样似乎有亿点点慢，考虑优化。</p>
<p>设 <span class="math inline">\(F_n(x)\)</span> 表示 <span class="math inline">\(x^{\overline n}\)</span> 形成的多项式，那么 <span class="math inline">\(x^{\overline {2n} }\)</span> 的多项式是等于 <span class="math inline">\(F_n(x)\times F_n(x+n)\)</span> 的，用二项式定理把后者展开，会发现是一个减法卷积的形式，所以可以在 <span class="math inline">\(n\log n\)</span> 的时间内求得 <span class="math inline">\(F_{2n}\)</span>，倍增的处理就可以做到 <span class="math inline">\(n\log n\)</span>。</p>
<h5 id="第一类斯特林数列">第一类斯特林数·列</h5>
<p>考虑用生成函数解决这个问题。</p>
<p>设由若干个数形成 <span class="math inline">\(k\)</span> 个圆排列的生成函数是 <span class="math inline">\(F_k\)</span>，这恰好是我们要求的。</p>
<p>因为用来形成圆排列的数是可以区分的，所以这个生成函数表示的应该是排列而不是组合（或者可以这么理解，设 <span class="math inline">\(x_1\)</span> 个数形成 <span class="math inline">\(y_1\)</span> 个圆排列的方案数为 <span class="math inline">\(z_1\)</span>，<span class="math inline">\(x_2\)</span> 个数形成 <span class="math inline">\(y_2\)</span> 个圆排列的方案数为 <span class="math inline">\(z_2\)</span>，那么由 <span class="math inline">\(x_1+x_2\)</span> 个数形成 <span class="math inline">\(y_1+y_2\)</span> 个圆排列的方案数并不是 <span class="math inline">\(z_1\times z_2\)</span>，而需要额外乘上一个组合数 <span class="math inline">\(\begin{pmatrix}x_1+x_2 \\ x_1\end{pmatrix}\)</span>），故 <span class="math inline">\(F_k\)</span> 是指数型生成函数。</p>
<p>假设我们现在已经知道了 <span class="math inline">\(F_1\)</span>，那么 <span class="math inline">\(F_k=\frac{F_1^k}{k!}\)</span>，即先生成 <span class="math inline">\(k\)</span> 个有序的圆排列，然后把序去掉。</p>
<p><span class="math inline">\(F_1\)</span> 很容易知道，即 <span class="math inline">\(\sum_{i&gt;0}(i-1)!\frac{x^i}{i!}\)</span> 。化简一下就是 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 。</p>
<p>那么我们就可以通过多项式快速幂得到 <span class="math inline">\(F_k\)</span>。</p>
<p>至此我们就已经可以得到某一列的第一类斯特林数的值，但是这个式子有那么一点点丑，考虑把它美化一下。</p>
<p>仔细观察一下 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 这个式子，会发现似乎这个东西有亿点点眼熟。先把它求导，得到 <span class="math inline">\(\sum_{i\geq 0}x^i=\frac{1}{1-x}\)</span>，再积分，就得到了 <span class="math inline">\(-\ln(1-x)\)</span>（实际上，博主是通过对 <span class="math inline">\(-\ln(1-x)\)</span> 求导积分得到 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 的）。</p>
<p>所以 <span class="math inline">\(F_k=\frac{(-\ln(1-x))^k}{k!}\)</span> 。（虽然这并不能简化运算量，甚至还加大了难度（因为需要手动展开 <span class="math inline">\(\ln\)</span>），但是它变得好看了）。</p>
<h5 id="第二类斯特林数行">第二类斯特林数·行</h5>
<p>第二类斯特林数有一个人尽皆知的式子 <span class="math inline">\(n^m=\sum_{i=1}^n\begin{pmatrix}n \\ i \end{pmatrix}\begin{Bmatrix}m \\ i \end{Bmatrix}i!\)</span> 。</p>
<p>设 <span class="math inline">\(g(n)=n^m,f(i)=\begin{Bmatrix}m \\ i \end{Bmatrix}i!\)</span>，对原式使用二项式反演得到 <span class="math inline">\(\begin{Bmatrix}m \\ n \end{Bmatrix}n!=\sum_{i=1}^n(-1)^{n-i}\begin{pmatrix}n \\ i \end{pmatrix}i^m\)</span> 。把组合数展开，不难发现右边是一个卷积的形式，所以可以通过 FFT 在 <span class="math inline">\(n \log n\)</span> 的时间内求得第二类斯特林数的一行。</p>
<h5 id="第二类斯特林数列">第二类斯特林数·列</h5>
<p>同第一类斯特林数一样，用生成函数解决这个问题。</p>
<p>设把若干个数分到 <span class="math inline">\(k\)</span> 个集合的生成函数是 <span class="math inline">\(F_k\)</span>，这恰好是我们要求的。</p>
<p>同样的，用分析第一类斯特林数的方法来分析第二类斯特林数，可以发现 <span class="math inline">\(F_k\)</span> 也是指数型生成函数（可以参考上文理解）。</p>
<p>假设我们知道了 <span class="math inline">\(F_1\)</span>，那么 <span class="math inline">\(F_k=\frac{F_1^k}{k!}\)</span>，即先形成 <span class="math inline">\(k\)</span> 个有序的集合，然后把序去掉。</p>
<p><span class="math inline">\(F_1\)</span> 很容易知道，即 <span class="math inline">\(\sum_{i&gt;0}\frac{x^i}{i!}\)</span> ，特别的，它的第 <span class="math inline">\(0\)</span> 项为 <span class="math inline">\(0\)</span>。</p>
<p>这样我们就可以通过多项式快速幂得到 <span class="math inline">\(F_k\)</span>。</p>
<p>然后这个式子还不够美观，考虑把它美化一下。</p>
<p>根据常识，<span class="math inline">\(\sum_{i&gt;0}\frac{x^i}{i!}=e^x-1\)</span>。</p>
<p>所以 <span class="math inline">\(F_k=\frac{(e^x-1)^k}{k!}\)</span> 。</p>
<h4 id="贝尔数">贝尔数</h4>
<p>定义：对 <span class="math inline">\(n\)</span> 个数集合划分的数目。符号 <span class="math inline">\(B_n\)</span>。</p>
<p>根据定义不难得到 <span class="math inline">\(B_n\)</span> 是第二类斯特林数第 <span class="math inline">\(n\)</span> 行的和。</p>
<h5 id="递推式">递推式</h5>
<p>枚举第 <span class="math inline">\(n\)</span> 个数所在集合大小，有 <span class="math inline">\(B_n=\sum_{i=0}^{n-1}\begin{pmatrix}n-1 \\ i \end{pmatrix}B_{n-i-1}\)</span>。因为 <span class="math inline">\(\begin{pmatrix}n \\ i \end{pmatrix}=\begin{pmatrix}n \\ n-i \end{pmatrix}\)</span>，为了美观一般把递推式写成 <span class="math inline">\(B_n=\sum_{i=0}^{n-1}\begin{pmatrix}n-1 \\ i \end{pmatrix}B_i\)</span> 。</p>
<h5 id="生成函数">生成函数</h5>
<p>设 <span class="math inline">\(B_n\)</span> 的生成函数为 <span class="math inline">\(G\)</span>。</p>
<p>上文中，对于第二类斯特林数的第 <span class="math inline">\(k\)</span> 列，有 <span class="math inline">\(F_k=\frac{(e^x-1)^k}{k!}\)</span>，其中第 <span class="math inline">\(n\)</span> 项是 <span class="math inline">\(\begin{Bmatrix}n \\ k \end{Bmatrix}\)</span>。那么 <span class="math inline">\(\sum_{k\geq 0}F_k\)</span> 中第 <span class="math inline">\(n\)</span> 项就是第 <span class="math inline">\(n\)</span> 行斯特林数的和，就是 <span class="math inline">\(G\)</span>。</p>
<p><span class="math inline">\(G=\sum_{k\geq 0}F_k=\sum_{k\geq 0}\frac{(e^x-1)^k}{k!}=e^{e^x-1}\)</span> 。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>机房日常</title>
    <url>/2021/03/11/%E6%9C%BA%E6%88%BF%E6%97%A5%E5%B8%B8/</url>
    <content><![CDATA[<p>神说记录机房日常可以涨 RP。</p>
<p>积积积积积点点点点点阳阳阳阳阳德德德德德。</p>
<a id="more"></a>
<p>博主是老鸽子，咕咕咕咕咕。</p>
<p>因为博主太懒了，下文的时间是倒序的。</p>
<hr />
<h3 id="section">2021.6.14</h3>
<p>机房欢乐一大把，这篇博客写不下。</p>
<h3 id="section-1">2021.4.28</h3>
<p>Dan 咕了太久了心里有些过意不去，决定更新一手。</p>
<p>但是似乎没有什么好写的。</p>
<p>算了不写了。</p>
<h3 id="section-2">2021.3.23</h3>
<blockquote>
<p>XiG: 我发现把眼镜反过来戴脑袋会特别晕<br />
lsqs: 因为度数不一样啊<br />
Dan: 那我先反一下，再反一下……<br />
All: 那和没反有什么区别吗？</p>
</blockquote>
<h3 id="section-3">2021.3.22</h3>
<blockquote>
<p>Dan: 给个提示 <span class="math inline">\(F^2_{k-1}\equiv c \pmod {F_k}\)</span><br />
All: 也就是说对于所有的 <span class="math inline">\(k\)</span>，<span class="math inline">\(F^2_{k-1}\bmod F_k\)</span> 是常数咯？<br />
lsqs: 那不是求出 <span class="math inline">\(k=1\)</span> 的值就可以了吗？<br />
Ima: <span class="math inline">\(k=1,2\)</span> 的值不一样诶！<br />
Dan: 不是啊，对于不同的 <span class="math inline">\(k\)</span> 来说 <span class="math inline">\(c\)</span> 可能不同啊。<br />
All: 那给了个啥提示啊？<br />
Dan: 哦~【恍然大悟】</p>
</blockquote>
<h3 id="section-4">2021.3.21</h3>
<p>PETS 考试：</p>
<blockquote>
<p>Q: Do you like your school ?<br />
A: Yes, of course.<br />
Q: Why ?<br />
...<br />
A: I think ... the students are kind. XD</p>
</blockquote>
<h3 id="section-5">2021.3.11</h3>
<blockquote>
<p>Imakf: 为什么这么做最优啊？<br />
Qiu: 因为这么做最优。<br />
Imakf: ？<br />
Qiu: 显然啊。</p>
</blockquote>
<blockquote>
<p>Qiu: <span class="math inline">\(n\times 2^{\frac{n}{4}}\)</span> 过 <span class="math inline">\(n\leq 100\)</span> 不随便过？</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛 70 E 题解</title>
    <url>/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7509/E">题目链接</a></p>
<p><strong>题意简述</strong></p>
<p>定义若二元组 <span class="math inline">\((a,b)&lt;(c,d)\)</span>，则有 <span class="math inline">\(a&gt;c\)</span> 或者 <span class="math inline">\(a=c \text{ and } b&lt;d\)</span>。</p>
<p>给你 <span class="math inline">\(n\)</span> 个数，第 <span class="math inline">\(i\)</span> 个数是 <span class="math inline">\(a_i\)</span>。</p>
<p>现在系统会生成 <span class="math inline">\(n\)</span> 个二元组，第 <span class="math inline">\(i\)</span> 个二元组是 <span class="math inline">\((a_i,i)\)</span> 或者是 <span class="math inline">\((a_i+1,i)\)</span>，然后给每个二元组一个排名，设排名数列为 <span class="math inline">\(rk\)</span>。</p>
<p>求有多少种不同的 <span class="math inline">\(rk\)</span> 数列，两个 <span class="math inline">\(rk\)</span> 序列不同当且仅当存在至少一个位置 <span class="math inline">\(x\)</span>，使得两个 <span class="math inline">\(rk\)</span> 数列的 <span class="math inline">\(rk_x\)</span> 不同。</p>
<p><span class="math inline">\(n\leq 5\times 10^5,a_i\leq 10^6\)</span>，时空限制：2s 256M。</p>
<a id="more"></a>
<p><strong>样例</strong></p>
<p>输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>解释：有以下八种二元组的搭配方式，以及其相应的 <span class="math inline">\(rk\)</span> 序列。</p>
<p><span class="math inline">\((1,1),(2,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((1,1),(2,2),(3,3)\ \ \ \ rk:3,2,1\)</span></p>
<p><span class="math inline">\((1,1),(3,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((1,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((2,1),(2,2),(2,3)\ \ \ \ rk:1,2,3\)</span></p>
<p><span class="math inline">\((2,1),(2,2),(3,3)\ \ \ \ rk:2,3,1\)</span></p>
<p><span class="math inline">\((2,1),(3,2),(2,3)\ \ \ \ rk:2,1,3\)</span></p>
<p><span class="math inline">\((2,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p>
<p>不同的 <span class="math inline">\(rk\)</span> 序列一共有 <span class="math inline">\(5\)</span> 个。</p>
<p><strong>题解</strong></p>
<p>比赛的时候一直认为是一个组合数学题目，没想到是一个 DP。</p>
<p>先下一个定义：若两个由前 <span class="math inline">\(i-1\)</span> 个二元组形成的序列，无论 <span class="math inline">\([i,n]\)</span> 中的每个二元组是 <span class="math inline">\((a_x,x)\)</span> 还是 <span class="math inline">\((a_x+1,x)\)</span>，这两个序列最终形成的排名序列都是相同的，那么我们把它们称作<strong>不可区分</strong>的。</p>
<p>首先把所有二元组按照 <span class="math inline">\((a_i,i)\)</span> 排序。为了方便，下文默认输入就已经保证了 <span class="math inline">\((a_i,i)&lt;(a_{i+1},i+1)\)</span>。</p>
<p>考虑 DP，设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i-1\)</span> 个二元组组成的<strong>可区分</strong>的序列个数。</p>
<p>那么第 <span class="math inline">\(i\)</span> 个位置既可以放 <span class="math inline">\((a_i,i)\)</span> 也可以放 <span class="math inline">\((a_i+1,i)\)</span>，所以有 <span class="math inline">\(f_{i+1}=2f_i\)</span>，但是这样显然会算重，所以考虑容斥。</p>
<p>考虑对于一个位置 <span class="math inline">\(i\)</span>，找到一个极短的区间 <span class="math inline">\([l,r](l\leq i\leq r)\)</span>，它需要满足存在一种在 <span class="math inline">\([l,i-1],[i+1,r]\)</span> 放置二元组的方案，使得第 <span class="math inline">\(i\)</span> 个位置放 <span class="math inline">\((a_i,i)\)</span> 和放 <span class="math inline">\((a_i+1,i)\)</span> 是<strong>不可区分</strong>的。这样的话，这种放置方法的贡献本来只有 <span class="math inline">\(1\)</span> 但是被算了两次，所以 <span class="math inline">\(f_r\)</span> 就需要减去 <span class="math inline">\(f_l\)</span>。</p>
<p>因为这个区间是极短的，所以可以恰好不重不漏地把所有的不合法的方案都减掉，最终的 <span class="math inline">\(f_{n+1}\)</span> 即为答案。</p>
<p>不难发现，因为我们一开始排好了序，所以 <span class="math inline">\(l,r\)</span> 是单调递增的，<span class="math inline">\(i\)</span> 也是我们单调枚举的，所以 DP 的总复杂度是 <span class="math inline">\(O(n)\)</span> 的。（有趣的是，复杂度的瓶颈在于排序）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, id;</span><br><span class="line">  Node (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _id = <span class="number">0</span>) &#123; x = _x, id = _id; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x ^ A.x ? x &gt; A.x : id &lt; A.id; &#125;;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; read(n);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(a[i].x), a[i].id = i;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; i &amp;&amp; (Node(a[l].x, a[l].id) &lt; Node(a[i].x + <span class="number">1</span>, a[i].id))) ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; (Node(a[r].x + <span class="number">1</span>, a[r].id) &lt; Node(a[i].x, a[i].id))) ++r;</span><br><span class="line">    f[r] = (f[r] + mod - f[l]) % mod;</span><br><span class="line">    f[i + <span class="number">1</span>] = ((f[i] + f[i]) % mod + f[i + <span class="number">1</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  print(f[n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>妙题</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>用二进制模拟 K 进制</title>
    <url>/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<p>被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。</p>
<a id="more"></a>
<p>先考虑怎么用二进制模拟三进制。</p>
<p>用 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s_0,s_1,s_2\)</span> 依次表示某数在三进制下，数位为 <span class="math inline">\(0,1,2\)</span> 的位的集合。</p>
<p>不难发现 <span class="math inline">\(s_0,s_1,s_2\)</span> 两两无交。</p>
<p>那么对于两个数的三进制下位运算，就可以通过枚举两数的 <span class="math inline">\(s_0,s_1,s_2\)</span>，得到两数在三进制下数位为 <span class="math inline">\(0,1,2,3,4\)</span> 的位的集合。且这些集合也两两无交。</p>
<p>之后再通过位运算的定义，把五个集合重新整理成新的 <span class="math inline">\(s_0,s_1,s_2\)</span>。</p>
<p>复杂度是 <span class="math inline">\(O(9)\)</span> 的（因为需要枚举 <span class="math inline">\(s_0,s_1,s_2\)</span>）。</p>
<p>类似的，这种做法也可以推广到 K 进制下，复杂度是 <span class="math inline">\(O(K^2)\)</span> 的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数位</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>瞎谈网络流和图匹配相关</title>
    <url>/2021/05/04/%E7%9E%8E%E8%B0%88%E7%BD%91%E7%BB%9C%E6%B5%81%E5%92%8C%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>队爷们写论文都用“浅谈”，我这连浅谈都谈不上，干脆瞎谈得了。</p>
<a id="more"></a>
<h2 id="网络流的几类模型">网络流的几类模型</h2>
<h3 id="最大流">1. 最大流</h3>
<p>RT，就硬流。这是网络流解决问题的最基本形式。</p>
<blockquote>
<p>例：XX 酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有 <span class="math inline">\(p\)</span> 间房间，一天只有固定的 <span class="math inline">\(q\)</span> 道不同的菜，每个房间只能住一位客人，每道菜也只能给一位客人食用。</p>
<p>有一天来了 <span class="math inline">\(n\)</span> 个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间且吃到喜欢的菜）。</p>
<p>要怎么分配，能使最多顾客满意呢？</p>
<p><span class="math inline">\(1\leq n,p,q \leq 100\)</span>。</p>
</blockquote>
<p>每个满意的配对都是 <code>房间——人——菜品</code> ，这启发我们把流也设置成 <code>房间——人——菜品</code> 的形式。</p>
<p><code>S</code> 向每个房间连流量为 <span class="math inline">\(1\)</span> 的边（每个房间只能用一次），每个菜品向 <code>T</code> 连流量为 <span class="math inline">\(1\)</span> 的边（每个菜只能给一个人吃），而对于人，直接</p>
<p>你会发现这个流网络中的每个流都有实际意义——它甚至是类似于匹配的。</p>
<p>这是应该是最简单的网络流模型了。</p>
<hr />
<p>好像是咕了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>神奇分治</title>
    <url>/2021/07/01/%E7%A5%9E%E5%A5%87%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。">
  <script id="hbeData" type="hbeData" data-hmacdigest="c05f1b17da1346c3f5bdac516b6036cf041f5549df8ee209b76dcb360bc4d5db">db04d9dc6c0c619199a2f58108234d077e2da1292f5c2a331ac629bdf05d505d086b73d92b24c6dfcd6a5bcd08b7f312875757dbdc0f3617d4ef398325f5a7da276e06ca5b4374ca740011773808ac26c39a6b08b9864a4726399864efac9d2f36c29020c04d904beb0e8947ba248117672fa65d71ed7f2cde0ff8c5ee51f8c26153978ea0b65b3500b8b18ce0e166162aacbc55342905011195699efe0177e2b51fa8945990c17b5e62e012eb389aefdf36bb1141d7b20e74fd9930fe1d5914a28fdc47b43098ed121f514a1eded27d20cfc6b9270263364f9d00c9333fe8480c3ad3034323c69c253e2ba12ce44c9b1812f8b3c6b51b1b849b6435661bebceb8952ec8828c2ac6e6207391387e932656d21a1c24ba76bd431d720bd5a1fb8e33017875c35e139a813ded6e3cb0c74c7c11addbe58f105c056257a547c61081041eaaa8c1ece24d8f92934b41bb9d20baa72ffaed64ab9343918b8a5bb5576dec2fc3c8189ffe21869f0924fb6f52048d25002c3595d1334b87b6d9efc416bc68f1a909086f5f9ba31d2edfa6fa6640c9f01c1b475474734f5789048dc8031e387ede643ddf3f22259e451473fb4779d49efb418b9b75e67140e86e49d404cad5f367311acb98059826739c05131627108b4b1e0bb5df7c045ce400cede206191e67a84fc1c3768c440a674bc4a2ee6d731774b6dce6ae463755cef356f6b6a09e429b2fac1e86f21fe36ff2280d0949a5c5b79814cb6f66fd61f6c2ebcb26c855722ca59c1876ee5bdb8b2209fb7a23e43e326298b1facd5dacd9ba9ac8619565f1050d0b9cd5215071e9d223f795b3a1558f983f38cbcd52eda49455c2e8a8e52169e595b52118d64d8ad038687141618f8a9a97f18ca1a58a34b81ff0b2aa48d3c5f1d7b4cd802cf432bd2f649d9b73549c874392751ecdf37f4ff9cf3c891ed8f5d9a192f4741f3b8ea51f66165be1d1aa4f442df1fd78bd9f776b9d7aabdbc4313744d6e0a168bd76d2753c278f1c81a9301b90e0a728d021357ce7053c0d899b18f7ddaac2a33e7fdbacd1611756d9ba1090c81bbe22e2301cde803eb93c8edee0ac1ccb339494e6848f24d071f59754b9576c9d9c23569154ac82357777fbc18a82b824fcba9ff4a1ed82e1264f19c9abe0efad78b346a95f0676e47098d0f6175f184e69ff6858f2f0be1b46f8cd438879f11f4ce758fd46bd54d959ebe22004b9d99fe8c4f594e60d4b6d35b02c7393082ad45b818c3cd8274f450991d055221f9f9933371738f34a0f1276e69e7f2aa76ad1e02be27b4a7b77323d76b85b079682819a3c982795d06e97a2e3d2bef145ddd069d57e73fc381fe0dc47f31069146843882f1be4d59e2a6383c94427a1e4e763cff408006aa84b9f23afd4204680416342eab58bd1465260a7f8ace14d33ae8cafffbfe6013ef5e5974afa906e47d3dab51f1b8650e2295ebec1dc549d3537da71944abc41fc75ca593128d59cb394e33c952b349fa9eb2e527be76afe2d30d48c84a355eaa90db84d1db519bc8c15dc1d5343f56e7386a311866554c8f9aff1ef5256dad76a78f3533147c56a0a27bb60ea99ab5792d9dbeb12ce05dd193c11733a4d34f22e8c5cecc09662ca8bc30168c942690698f655f9764dffc88140033e09775f41f45efbadbfb65f15c29eef2341149aa1ce3648acec6f42f6b5978e6864456c10eacf9c1ed60b1d49fb1c48d20417cd556ce947820f0ce6759dcb0b37078b6f8e1d87523d28dce54f7b3813ad8c0a39722cfa270f73a62349404bdedd1bc082db5305df428dca21b0d41b9809fc449088cc3f18a9414d51b3eb383264c98c53a24bd69950c36b66d68351941ede0ec10710f3267b01ee2de94d7f18f72235b4d0dbe6ec616c76a221c14a78dec13fcf0f1bc107ee09b16d2432593ea63ba0593fe0a9840ec43c744ec4f530ee8c0743c82acf470f95360f891305c412f49fbefe50731d707cea76c58f3b39f39b38775c2fc6b88e373f1e74a51c87dfe45bcec76386503628765d90410b828ec12f38716b2b291b5f1056f61c4cce4dadce40d04665e8477b246924c9cfe1d9ef6b7c3cb22f3734dea73d531ac457ee24bc97c2ba655c5058492e9dc4bd0b6aa148f6dc844a407ff7b2776f34c98dc92113e14dad555dcf9ad62a222e8d126e0ad1097c51ee2cf356549a682bf2368da4bd78f4e34626367073b034ab6d32ef9f1027f71348e4658eacca5e4bc4995de2bf4d57beeda5e914d13d3eaf8fa2911d23d16fb51f52a239d83ee7465568ee15a1c413f5e677d010c613e24490a64065c83901feced0989ff70485c2e8171403dc17fe7186ca1149b2411627f782dbbf00b26a3907804fef158abdeab7223c04c36604e148a8c191097028802a579d604320b3d8b9a5f379ec98695d98bf74135c75abc6dae86cb57e2b3611f4c6afa1fe71927073e68037440783e087a7052e35d1989d588d173923f277d9b46dfdfe4b41c69deda5d5fec399150b1dd82c0ccf57c49eaf43d07854ccf796c1ea4ebd6e767fdbb9f72f40739e3d271d9300bd187f68f31601ffea5f65fa6af72590985c593beb03535d90b93b452ff847837939135a032489b2c59bc2de44e479a37ba2bdeec23364be189e421e584be1bf3e08063a8c5669a870f76fdac88800b81404ce44190699aeb3ba6d8b44a7705d09268fe4d2149b4f3ec999551785147583ce9e98a35d0179eb1c635a1706bd76a52744b0998d051f555408255e5248df30c3bcca4935771a69adb7c6b467f17fb5763c3e883c64b62ef680d3dadc0d0a696ada1c1f363cefe8d13f375d1d5fa5c99cf6eb8dc59c2ba40ea54067ee6237064f4095f52f2681982d255567214824648b7fd4a95a1845868a3badebf97154fad338ed85b3a45cc8c90bbfd2b18b985c5b6cd733d1a948965e68609e1523d0b808e23c6157aedc3e0f06d3aff64da4bde45710cf9fd86aa6bcb0a921645aa7b0e90d7cd8c97679e43330e58429f0f682f489914f61974d0cece755c151ebe76fdee4ae0aa681e7f5ad2c26b01b5a6aa0248e9387257d9a2177d6d1fdcf6d38ea54d4f6bfa1b043673e7527b6a55381d13418e021d5462778f5d7e81335d4c797fb5bdef4439e6e9d53b4a0e10ed7e1a93d3cbebed1606608764b1fcc6186448df95e73f11e8ceb69445f5a207fbd6cddb77007f0ff023ff81243882bf68b3ed2216e540eddca6397ef0e8d7b1486a04f09fd781958f63e827c3a01153db086a2f686fb9df228642b99758e6f5989bdc0ddbb165f81262c59b860acc210486b1e4dd052003846ac4a0b4f9e3e4df862b093909cb072f218464c7c48254719a0a82748ca8263a586f68018d81fd6f9c29f58d88f7a073563002bb058ce0a2a72247478cbdf24502689f288113a1dbb7e2a120cf7275a7eedd644572aded81864b5307e3c49d09944edb9f7402337732eb01b0fda26ca3749150cff1d02aaee3bd321454005d0653c571fc7b744730ef70096d484637ecd5780abf7add3ce3df2285f3790d00beae5d7eaf78f0ff550bc8e3eff105cc038ef04a90f8339ba287bbf8758709ecc9268fe8dccc0e9bd050f8468bd7498c682df9c68bc150bf75004edf5ec742d0fc499516c01568aefd46fc30f2035799bdd646ef2aec20e90df83f3408e2886ba8b4d3362018c640f9ddc4c6db29594e11cd1cf3788035101937fb5de7626e5eb9591918d982ce8ce22e8b7803ec4a4eb1f0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">用魔法咒语解开它吧。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>简单模拟费用流</title>
    <url>/2020/12/27/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
    <content><![CDATA[<p>众所周知，只要把模建好，什么题都可以用网络流/费用流跑。</p>
<p>随着这些算法普及度的提高，出题人也就不再局限于单纯的网络流/费用流，而模拟费用流就是其中衍生出来的一个上限很高的算法。</p>
<p>由于博主水平有限，在此记录一些比较简单的模拟费用流问题和思路。</p>
<a id="more"></a>
<p>不知道为什么就咕掉了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>费用流</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数优化矩阵快速幂</title>
    <url>/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>如果我们需要求维度为 <span class="math inline">\(c\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 次幂，那么一个显然的方法是用快速幂，复杂度为 <span class="math inline">\(c^3 \log m\)</span>。不过当需要用到高精度的时候，该算法速度会大大下降。</p>
<p>考虑这么一个事情，<a id="more"></a> 如果可以找到一个矩阵 <span class="math inline">\(C\)</span> 和一个对角矩阵 <span class="math inline">\(P\)</span>（只有主对角线上的值不为 <span class="math inline">\(0\)</span>），使得 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>，那么 <span class="math inline">\(A^m=C\times P \times C^{-1} \times C \times P \times C^{-1}...\)</span>，不断的使用结合率，就可以得到 <span class="math inline">\(C \times P^m \times C^{-1}\)</span>。因为 <span class="math inline">\(P\)</span> 是对角矩阵，那么 <span class="math inline">\(P^m\)</span> 本质上只要对 <span class="math inline">\(P\)</span> 中的每个值跑一个实数的快速幂。这样就可以把复杂度优化到 <span class="math inline">\(c^3+c\log n\)</span>，即实数的快速幂和两次矩阵乘法。</p>
<p>现在的问题就是怎么得到一个合法的 <span class="math inline">\(C\)</span>。</p>
<p>引入两个概念：特征值和特征向量。</p>
<p>一个数 <span class="math inline">\(\lambda\)</span> 是矩阵 <span class="math inline">\(A\)</span> 的特征值，当且仅当存在一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>，使得 <span class="math inline">\(A\times B=\lambda B\)</span>，我们把这个向量 <span class="math inline">\(B\)</span> 称作特征向量。需要注意的是，对于同一个 <span class="math inline">\(\lambda\)</span>，<span class="math inline">\(B\)</span> 可能不止一个。</p>
<p>如果我们求出了一组特征值 <span class="math inline">\(\lambda_1,\lambda_2...\lambda_c\)</span>，以及对应的特征向量 <span class="math inline">\(B_1,B_2...B_c\)</span>，那么就有 <span class="math inline">\(A\times [B_1,B_2...B_c]=[\lambda_1\cdot B_1,\lambda_2\cdot B_2...\lambda_c\cdot B_c]\)</span>，设 <span class="math inline">\(C=[B_1,B_2...B_c]\)</span>，右乘一个对角矩阵相当于每一列 <span class="math inline">\(i\)</span> 乘上一个对角阵中的元素 <span class="math inline">\(a_{i,i}\)</span>，所以可以构造对角矩阵 <span class="math inline">\(P=\begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots&amp;0\\ 0 &amp; \lambda_2 &amp; \cdots&amp;0\\ \vdots &amp; \vdots&amp;\ddots&amp;\vdots \\ 0&amp;\cdots&amp;0&amp;\lambda_c\end{bmatrix}\)</span>，就可以得到 <span class="math inline">\(A\times C=C\times P\Leftrightarrow A=C\times P\times C^{-1}\)</span> 。</p>
<p>考虑怎么求特征值，因为 <span class="math inline">\(A\times B=\lambda B\)</span> 那么就有 <span class="math inline">\(\lambda B-A\times B=0\)</span>，所以 <span class="math inline">\((\lambda I-A)\times B=0\)</span>，因为 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span>，所以必须有 <span class="math inline">\(\det(\lambda I-A)=0\)</span>，那么可以通过行列式列方程求得 <span class="math inline">\(\lambda\)</span>。</p>
<p>考虑使用反证法证明 <span class="math inline">\(\det(\lambda I-A)=0\)</span>。设 <span class="math inline">\(G=\lambda I-A\)</span>，那么如果 <span class="math inline">\(\det(G)\not=0\)</span>，那么如果把 <span class="math inline">\(G\)</span> 看作是一个方程组的系数矩阵，<span class="math inline">\(B\)</span> 为未知数，那么 <span class="math inline">\(B\)</span> 将会是唯一的。而因为等式右边等于 <span class="math inline">\(0\)</span> ，所以无论如何用高斯消元，最后总会有 <span class="math inline">\(B_c=0\)</span>，那么一直往回迭代就会得到一个全 <span class="math inline">\(0\)</span> 向量，与 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span> 冲突。而如果 <span class="math inline">\(det(G)=0\)</span>，那么 <span class="math inline">\(G\)</span> 至少有一个自由元，那么就可以通过自由元，得到至少一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>。</p>
<p>由此我们就可以求出所有的特征值，对于某个特征值，把它带回矩阵，通过初等矩阵的行变换把它变成一个最简形式，然后把自由元带入任意一个值（一般为 <span class="math inline">\(1\)</span>）就可以得到一个特征向量 <span class="math inline">\(B\)</span>（当然对于任意的 <span class="math inline">\(k\cdot B,k\not=0\)</span> 都是符合要求的）。</p>
<p>至此就可以得到所有的特征值及其对应的特征向量。那么就可以得到矩阵 <span class="math inline">\(C\)</span>，求个逆就可以得到 <span class="math inline">\(C^{-1}\)</span>（消元可以用辗转相除法，就可以避免求逆元），就可以用上述做法优化了。</p>
<p>下面就举个栗子，用此方法得到斐波那契数列的通项公式。</p>
<p>众所周知，斐波那契数列的递推矩阵是 <span class="math inline">\(A=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\ \end{bmatrix}\)</span> 。</p>
<p>先求出该矩阵的特征值，设其为 <span class="math inline">\(\lambda\)</span>，根据定义，有 <span class="math inline">\(\det \left ( \begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \right) = 0\)</span> ，所以 <span class="math inline">\((\lambda-1)\times \lambda-1=0\)</span>，解出 <span class="math inline">\(\lambda=\frac{1\pm\sqrt{5}}{2}\)</span> 。</p>
<p>再根据定理，列出方程 <span class="math inline">\(\begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ \end{bmatrix}=\begin{bmatrix} 0 \\ 0 \\ \end{bmatrix}\)</span> 可以解出两个特征向量 <span class="math inline">\(\lambda_1=\frac{1-\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_1=\begin{bmatrix} 1 \\ \frac{-1-\sqrt{5}}{2} \\ \end{bmatrix}\)</span>，<span class="math inline">\(\lambda_2=\frac{1+\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_2=\begin{bmatrix} 1 \\ \frac{-1+\sqrt{5}}{2} \\ \end{bmatrix}\)</span> 。那么根据定义，设 <span class="math inline">\(C=[B_1,B_2]\)</span>，构造对角阵 $P=\begin{bmatrix} _1 &amp; 0 \ 0 &amp; _2 \ \end{bmatrix} $，就可以得到 <span class="math inline">\(A\times C=C\times P\)</span>，所以有 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>。故 <span class="math inline">\(A^m=C\times P^m \times C^{-1}\)</span>。</p>
<p>通过手算可以求得 <span class="math inline">\(C^{-1}= \begin{bmatrix} 1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; -\frac{\sqrt{5}}{5} \\ \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; \frac{\sqrt{5}}{5} \\ \end{bmatrix}\)</span>。</p>
<p>对于斐波那契数列第 <span class="math inline">\(m\)</span> 项，即是 <span class="math inline">\(A^m\)</span> 的 <span class="math inline">\(a_{1,1}\)</span>。显然 <span class="math inline">\(P^m=\begin{bmatrix} (\frac{1-\sqrt{5}}{2})^m &amp; 0 \\ 0 &amp; (\frac{1+\sqrt{5}}{2})^m \ \end{bmatrix}\)</span> ，那么 <span class="math inline">\(C\times P^m \times C^{-1}\)</span> 的 <span class="math inline">\(a_{1,1}\)</span> 为 <span class="math inline">\((\frac{1-\sqrt{5}}{2})^m\times(1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5})+(\frac{1+\sqrt{5}}{2})^m\times \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5}\)</span>，整理之后就为 <span class="math inline">\(\frac{1}{\sqrt{5}}\left((\frac{1+\sqrt{5}}{2})^{m+1}-(\frac{1-\sqrt{5}}{2})^{m+1}\right)\)</span> ，即为斐波那契数列的通项公式。</p>
<p>因为出现了根号，所以整个过程看似比较麻烦，不过在递推矩阵满足一些性质的时候有较快的方法求特征值和特征向量（比如在整个矩阵是一个上/下三角矩阵时，特征值就是主对角线上的值，自由元就是项数变少了某行，设它为 <span class="math inline">\(1\)</span>，就可以在矩阵大小的复杂度内求得一个特征向量）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基的瞎操作</title>
    <url>/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="查找某个数-x-可以被给出基底-a-如何异或得到">1. 查找某个数 <span class="math inline">\(x\)</span> 可以被给出基底 <span class="math inline">\(A\)</span> 如何异或得到</h4>
<p>把基底 <span class="math inline">\(A\)</span> 做线性基，并且在线性基的同时维护线性基中每个元素是由基底中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>，那么在查询的时候，把对应位置的 <span class="math inline">\(S\)</span> 也一起异或，就可以得到最终所求。</p>
<h4 id="把基底-a-的一个数-a_i-与另一个数-x-交换保证交换后基底-a-仍然满足基底的性质">2. 把基底 <span class="math inline">\(A\)</span> 的一个数 <span class="math inline">\(A_i\)</span> 与另一个数 <span class="math inline">\(x\)</span> 交换，保证交换后基底 <span class="math inline">\(A&#39;\)</span> 仍然满足基底的性质</h4>
<p>同上，在线性基的同时维护线性基中每个元素是由 <span class="math inline">\(A\)</span> 中的哪些元素异或得到的，记作 <span class="math inline">\(S\)</span>。先查询 <span class="math inline">\(x\)</span> 怎么被 <span class="math inline">\(A\)</span> 表示，因为 <span class="math inline">\(A&#39;\)</span> 依旧满足基底的性质，那么如果用 <span class="math inline">\(A\)</span> 来表示 <span class="math inline">\(x\)</span>，那么 <span class="math inline">\(A_i\)</span> 一定会被用到。所以 <span class="math inline">\(A_i\)</span> 也可以用 <span class="math inline">\(A\)</span> 中的数和 <span class="math inline">\(x\)</span> 一起表示，那么就可以直接交换 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(A_i\)</span>，然后去更新线性基中的每个位置的 <span class="math inline">\(S\)</span> 即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数位</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流进阶</title>
    <url>/2021/01/09/%E7%BD%91%E7%BB%9C%E6%B5%81%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>网络流进阶。主要是有上下界的各种网络流或费用流以及几个消负环的方法。</p>
<p>在看这个 Blog 之前你最好已经熟练掌握了 Dinic 网络流和 EK 费用流。</p>
<a id="more"></a>
<h4 id="无源汇有上下界的循环流">1. 无源汇有上下界的循环流</h4>
<p>这是最简单的一种有上下界的网络流，也是所有有上下界的网络流的基础。</p>
<p>其所求大意如下：对于一张网络流的图，每条边有一个流量限制 <span class="math inline">\([l,r]\)</span>，现在需要给每条边分配一个流量，使得每个点的流量平衡（即流入等于流出），且每条边的流量满足限制。</p>
<p>考虑先把每条边的流量设为其下界，设置完之后我们得到了一个初始流，这个流的流量都满足边的限制，但是不一定满足流量平衡。</p>
<p>考虑构造一个附加流，使得初始流加上附加流在满足边的限制的情况下满足流量平衡。</p>
<p>因为这个附加流仍需要满足边的限制，所以原来的一条边 <span class="math inline">\((u,v,l,r)\)</span>，可以看成是一条 <span class="math inline">\(u\)</span> 连向 <span class="math inline">\(v\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的边，这样在附加流中这条边的流量就只能是 <span class="math inline">\([0,r-l]\)</span>，一定会满足边的限制。</p>
<p>然后就只需要考虑流量平衡。对于一个点 <span class="math inline">\(x\)</span>，如果其流入大于流出，那么它就仍然需要流出一些流量。考虑新增一个虚拟起点 <span class="math inline">\(S&#39;\)</span>，连一条 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(x\)</span> 流量为流入和流出的差值的边。这条边每有 <span class="math inline">\(1\)</span> 个流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流出增加了 <span class="math inline">\(1\)</span>。类似的，如果点 <span class="math inline">\(x\)</span> 的流出大于流入，那么它就仍然需要流入一些流量，就新增一个虚拟终点 <span class="math inline">\(T&#39;\)</span>，连条 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(T&#39;\)</span> 流量为流出和流入的差值的边。这条边每有 <span class="math inline">\(1\)</span> 流量，就代表在附加流中 <span class="math inline">\(x\)</span> 点的流入增加了 <span class="math inline">\(1\)</span>。</p>
<p>最后对新图 <span class="math inline">\(S&#39;-T&#39;\)</span> 跑一遍最大流，由前文的构造附加流的过程可知，可以使得其流量平衡当且仅当该图的最大流使得所有 <span class="math inline">\(S&#39;\)</span> 连出的边都满流（<span class="math inline">\(S&#39;\)</span> 连出的边都满流等价于 <span class="math inline">\(T&#39;\)</span> 连入的边都满流），否则的话无解。</p>
<p>最后每条边的流量就是下界加上附加流中该边的流量。</p>
<h4 id="有源汇有上下界的可行流">2. 有源汇有上下界的可行流</h4>
<p>有源汇和无源汇的最大的区别就是源点 <span class="math inline">\(S\)</span> 和汇点 <span class="math inline">\(T\)</span> 的流量不平衡。</p>
<p>考虑连一条 <span class="math inline">\(T\)</span> 连向 <span class="math inline">\(S\)</span> 流量下界为 <span class="math inline">\(0\)</span> 上界为 <span class="math inline">\(+\infty\)</span> 的边，这样 <span class="math inline">\(S\)</span> 的流出和 <span class="math inline">\(T\)</span> 的流入就都可以靠这条边来弥补，使得其流量平衡。</p>
<p>这时候就只需要求循环流了，即 1.。</p>
<p>不难发现，<span class="math inline">\(T\rightarrow S\)</span> 的流只可能走我们新加的边，所以附加流的总流量就是新加边的流量。但是这并不意味着新加边的流量等于 <span class="math inline">\(S&#39;\rightarrow T&#39;\)</span> 的最大流，因为原图中可能有环。</p>
<p>而可行流的流量就是 <span class="math inline">\(S\)</span> 的流出量（也就是 <span class="math inline">\(T\)</span> 的流入量），也等于新加边的流量。故可行流的流量等于附加流的流量。</p>
<h4 id="有源汇有上下界的最大流">3. 有源汇有上下界的最大流</h4>
<p>和 2. 类似的，我们可以先求出一个可行流。</p>
<p>此时对原图的残量网络再跑一次 <span class="math inline">\(S-T\)</span> 的最大流即可。</p>
<p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(S-T\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(S&#39;-T&#39;\)</span>。</p>
<p>如果你在跑 <span class="math inline">\(S-T\)</span> 最大流的时候，去掉了前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边，那么最大流就是残量网络上求出的最大流加上附加流的流量。否则，根据网络流的性质，此时可以通过所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边的反向边，直接从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 流附加流的流量，所以最大流就是残量网络上求出的最大流流量 。</p>
<h4 id="有源汇有上下界的最小流">4. 有源汇有上下界的最小流</h4>
<p>和 2. 类似的，我们可以先求出一个可行流。</p>
<p>然后考虑从 <span class="math inline">\(T\)</span> 向 <span class="math inline">\(S\)</span> 退流，这样就可以使得流量尽可能小。</p>
<p>即在残量网络上跑一遍 <span class="math inline">\(T-S\)</span> 的最大流。用附加流流量减去这个最大流的流量即最小流。</p>
<p>需要注意的是，这里跑最大流的是原图的 <span class="math inline">\(T-S\)</span>，而不是构造出来求附加流的虚拟节点 <span class="math inline">\(T&#39;-S&#39;\)</span>。</p>
<p>此时前面所加的 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边必须要去掉，不然会通过这条边退 <span class="math inline">\(+\infty\)</span> 的流导致求不到答案。</p>
<h4 id="有源汇有上下界的最小费用可行流最大流最小流">5. 有源汇有上下界的最小费用可行流/最大流/最小流</h4>
<p>为了方便，暂时不考虑负环，后面会提到两个消负环的算法。</p>
<p>最大费用和最小费用等价，所以暂且不考虑最大费用。</p>
<p>其实本质上就是在 2.3.4. 的基础上，加上一个最小费用。</p>
<p>即在一开始每条边强行流 <span class="math inline">\(l\)</span> 的流量的时候，把总费用加上 <span class="math inline">\(l\times cost\)</span>。</p>
<p>所有辅助边的费用都设为 <span class="math inline">\(0\)</span>。</p>
<p>在求附加流的时候是跑的最小费用最大流。最大流不满流仍然无解。</p>
<p>最后在残量网络上面跑的时候，如果是 <span class="math inline">\(S-T\)</span>，跑的是最小费用最大流，如果是 <span class="math inline">\(T-S\)</span>，跑的是最大费用最大流（正着流费用最小就是退的流费用最大）。</p>
<h4 id="有上下界的另一种连边方法">6. 有上下界的另一种连边方法</h4>
<p>为了省事，可以把边 <span class="math inline">\((u,v,l,r,c)\)</span> 拆成三条边。一条 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(r-l\)</span> 费用为 <span class="math inline">\(c\)</span>，一条虚拟起点 <span class="math inline">\(S&#39;\)</span> 到 <span class="math inline">\(v\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>，一条 <span class="math inline">\(u\)</span> 到虚拟终点 <span class="math inline">\(T&#39;\)</span> 流量为 <span class="math inline">\(l\)</span> 费用为 <span class="math inline">\(0\)</span>。并把总费用加上 <span class="math inline">\(l\times c\)</span>。</p>
<p>不难发现这种连边方法和 1. 的连边方法本质相同。只是把之前所考虑的一个点总流入和总流出的差分解成了若干个部分，或者说可以看成是之前直接把所有形如 <span class="math inline">\(S&#39;\rightarrow x \rightarrow T&#39;\)</span> 的流全部流完了。</p>
<h4 id="消负环算法">7. 消负环算法</h4>
<p>对于一条负权边 <span class="math inline">\((u,v,l,r,c)\)</span>，我们可以先强行把这条负权边流满，并获得 <span class="math inline">\(r\times c\)</span> 的总费用，然后这条边就变成了从 <span class="math inline">\(v\)</span> 连向 <span class="math inline">\(u\)</span> 的流量为 <span class="math inline">\(r-l\)</span> 的费用为 <span class="math inline">\(-c\)</span> 的边。这样强制流之后显然不一定满足流量平衡，所以需要用上述的附加流的方法使其流量平衡。</p>
<p>因为在整个图中一开始没有出现负环，所以在整个过程中也不会产生负环（可能比较糊……暂时还没有证明，或许显然？）。</p>
<p>另外还有一种很神的消负环算法，可见<a href="https://www.cnblogs.com/lsq147/p/14232399.html">这位神仙的博客</a>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队的奇技淫巧</title>
    <url>/2020/12/02/%E8%8E%AB%E9%98%9F%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
    <content><![CDATA[<p>莫队算法是一个很妙的算法，它可以通过对查询离线分块来降低算法复杂度。</p>
<p>但是仔细分析你会发现，莫队所有的复杂度都是修改左右端点造成的，而查询是 <span class="math inline">\(O(1)\)</span> 的。</p>
<p>也就是说我们可以在莫队中套一个修改 <span class="math inline">\(O(1)\)</span>，查询 <span class="math inline">\(O(1\sim \sqrt{n})\)</span> 的数据结构，这样总复杂度依旧是 <span class="math inline">\(O(n \sqrt{n})\)</span> 的，但是它却可以做更多的事情。</p>
<a id="more"></a>
<blockquote>
<p>例：有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(\{a_1,a_2...a_n\}\)</span>。<span class="math inline">\(m\)</span> 次询问，每次询问一个区间内最小没有出现过的自然数。</p>
</blockquote>
<p>这个题目是洛谷的 P4137。</p>
<p>这个题的经典做法是主席树或者回滚莫队，我们现在考虑另一种做法。</p>
<p>先直接上莫队，这样我们是不好维护删除数的操作的。</p>
<p>考虑在莫队里面套上一个值域分块，修改的时候 <span class="math inline">\(O(1)\)</span> 修改，查询的时候 <span class="math inline">\(O(\sqrt{n})\)</span> 一个块一个块的跳。</p>
<p>虽然套了一个分块，但是复杂度是加在查询上面的 ，总复杂度仍然是 <span class="math inline">\(O(n\sqrt{n})\)</span> 的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>麻将相关</title>
    <url>/2021/01/19/%E9%BA%BB%E5%B0%86%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p><del>不会打麻将的 OIer 不是好 ACMer。</del></p>
<p>虽然看完这篇博客你可能并不会变成雀神，但是你可能看到和麻将有关的题目就不会那么慌了。</p>
<a id="more"></a>
<p>麻将的一般规则本文就不再赘述，啥搜索引擎上都有。<del>实在不行下个雀魂玩玩也是可以的。</del></p>
<p>麻将题一般有两种做法：搜索和 DP。</p>
<h4 id="搜索">搜索：</h4>
<p>大多数时候是给出一副牌，看至少需要再摸几张牌才能胡。</p>
<p>考虑枚举合法终态，然后用牌数的差更新答案。</p>
<p>因为刻子和雀头都是多张同一个牌，所以这一块可以贪心，即从四张相同到一张相同的牌依次去匹配刻子和雀头，为了方便，可以设 <span class="math inline">\(dp_{i,j,k,l}\)</span> 表示有 <span class="math inline">\(i\)</span> 个四张，<span class="math inline">\(j\)</span> 个三张，<span class="math inline">\(k\)</span> 个二张拼成 <span class="math inline">\(l\)</span> 个面子加上一个雀头最少需要多少张牌，在搜索顺子的同时维护一下 <span class="math inline">\(i,j,k,l\)</span> 的值，然后直接更新答案即可。</p>
<p>然后考虑怎么搜索顺子，我们事先把所有的顺子预处理出来，共 <span class="math inline">\(27\)</span> 个，然后按层搜索枚举每个顺子有没有。这样复杂度是 <span class="math inline">\(O(27^4)\)</span>，显然不好。实际上，我们枚举的顺子在此刻至少要有两张牌存在于手牌中，因为如果只有一张，那么对额外牌数的贡献为 <span class="math inline">\(2\)</span>，而这张牌形成的刻子贡献的额外牌数也是 <span class="math inline">\(2\)</span>，这样可以把它算到刻子里面。</p>
<p>实际上这样优化下来判定是十分快的，博主认为其复杂度不会超过 <span class="math inline">\(10^4\)</span>。</p>
<h4 id="dp">DP：</h4>
<p>搜索写起来比较方便，但是搜索毕竟复杂度是指数级别的，它的速度还是慢了点，所以再介绍一种 DP 的做法。</p>
<p>依旧是考虑给出一副牌，看至少需要再摸几张牌才能胡。</p>
<p>设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1/2/3/4,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，以 <span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，以 <span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，面子一共有 <span class="math inline">\(0/1/2/3/4\)</span> 个，有 <span class="math inline">\(0/1\)</span> 个雀头的最小花费。转移的时候枚举下一种牌有几张即可。后面一堆东西看似有 <span class="math inline">\(90\)</span> 个，但是实际上仅有 <span class="math inline">\(50+\)</span> 个，且转移的时候转移边数不会很多。如果在这个上面再用上【搜索中的优化】，效率会更加高。（似乎这里不太严谨，但是跑得很快就对了）</p>
<p>从这也可以衍生出判定一个牌的集合中存不存在一个胡牌子集的方法，即设 <span class="math inline">\(f_{i,0/1/2,0/1/2,0/1}\)</span> 表示考虑前 <span class="math inline">\(i\)</span> 种牌，以 <span class="math inline">\(i-1\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，以 <span class="math inline">\(i\)</span> 开始的顺子有 <span class="math inline">\(0/1/2\)</span> 个，有 <span class="math inline">\(0/1\)</span> 个雀头的最大面子数。如果有一个有雀头的状态的面子数到了 <span class="math inline">\(4\)</span>，那么就可行。</p>
<hr />
<p>想必看完之后你就已经会打麻将了，<a href="https://www.luogu.com.cn/problem/P5279">[ZJOI2019] 麻将</a>和<a href="https://www.luogu.com.cn/problem/P5301">[GXOI/GZOI2019]宝牌一大堆</a>自然不在话下（其实后者真心就是只考了上述内容）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>DP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>trick 合集</title>
    <url>/2021/03/18/trick-%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。">
  <script id="hbeData" type="hbeData" data-hmacdigest="165276196e986bacebaf6637d2c96248e2c872e35149054d112c9d0c51e63e68">db04d9dc6c0c619199a2f58108234d07eb701a2864b421de98f0ad25c6380ef368724ecd1569c4fcbd1e0223790396e176ebfd85d66053d788ee545aed487c7621ec81374509228c98acd64f7a744683f3a36d01857587da1c7d6098c9675144301e1c21862003dcab0d4e139b71e21474ac0c2eb3891501ba30b75a57895ee3c04d39ac93c651100f996fef16058fff172c3134a2a752df9de7bdd23c9908b34b2b0e55a520f996e2c52eb2dd67af65205ec1bc80c969163be4c83231f8f564bc1a8a71cb70c32997c96bcce5e9d917096d2f1c23209565424657edd6990d9d4766323f84d7b70e5cd688354d62e40e6030b80b9674a49534ca97defcacc85a73eee59fc81e59924670d914fa9c2f8e4aacabd475fe513b3f3302556497b9ee47d40454eb71c66575c7bb921fb8e7f3ae7f0664ff6d4558f1d98f1905637f7577a855535b5fd5ff83217b326fada0242f9036214078ebd238eae7af61bc1396bf4697c688ae66c5964ee74ffe8445459f131e089f70dfdf53f0dabefd4f586c79fe64d1312375544ddaa9ca22e1503ac78f10059f308c6d9e9661834f77a6f4741aa4261ff98da28c00f7196b8b8962019add0aba0dea0ac800fda4b8e052f9a9c245105f49f97aba659f5f6de728fb3c1880abd761a8111e9de861195f334d42bab398033a2243c51062e6deedffd2d340ae298d1c08abe614e0bc689e5775f9100328ac881399b61e3d200c8a19379926c9cae2f2034d166cd51c0e38e38265470a4489e5984009873e6d931a2fa5b7e1b43d1fe36979bd83e0e9687134404c744723b3f4727630ceaaba71526990f1cf94b992e3978144372bc3d3d0fd642bfe37f6f717470adb600749a1afb1405ca6099aca4836880c22e7437e774633248456d0299d7a8960be3355c43866114a9a911f442e49c67effebe8cdcd1750cdf56636753c625277d199f4aa796ef6ba80490f3f1f248fa76ea44de8b52f37b61aeb62bcad8da478a5cb9552f8c259a04d46d7ea0a99fb1fe1a011f7850d49eedead64ee2181ebd5250afb47ec729eb5bbb399202332bef0e096d0c5c79e6f1e7637421e308e3136da9747e4170b526e3be95b342bc4c2cbf506797147e339300b9e4e67e4ef1a2e7d1901e58555aa43fca2cf7f963c520d7232d026536dd33c40f853596ae2e8c14f46b65d127818fc3e02edd2d3172df2a7de64d6cdbfefcc1e267afcc5382ea8c6f74bc9f907488e54084f4f4c1b5ca07b8da2b9d4a98ab7dd5fcc0b859feec59e5962097fe9d027947a25dc298a9c652131b04a4300cf2bbaacdb74c8e5014087c11950666801a1e877fa275305f31811bacf6722b46a496c3439c3122e626d844efc84a5c119950435068aa1b7e1d1f66c949718455c4a3d4da74e0d194f0642b4d0cbfe2ba8ce2ecb03b93d10c9556a9922b354db7a9773fc7117a6f2f44866257003b731d0d3aaa308215c7af2e9bcf5502399c941f1898493961fabe016a609d42ea887ad98a3df54c0ed0feed53af2c4960f059952ae602b85949e5a51d49b32a07347a8456bbf9bbf421bcbfbdf7000455c116a62b28a8a665c92241c4d6d802414deb3434633835a6f63ea009989b2982539c1fd6d7442b0a4a7dd1bd06eae892d7a2970ab51fe74a1124df951eb19ec07915634e18b6002360ada961375ecc925821bcd064b934bd27ef1abdcaf80dbb7b8c46610e2c9c848a44ad046ab04943300a8bbd10574f7db1b3a1b05ef5f757f668a2912e48ff13a3fce16c3c37e67e0d958c0db938cfb8d8e88a33685e631c68ea801ba1ec3d85165b5f32ab8d49043558bd28b6fe92b3d253f85d67b12a49404c413899a39480390428395213f0d0e7f60f0015e6e23ade92fc32800f2ed227b8c38623a84180c5be5cca4cb0a1472b24cf09bb33b29166bb1c97ee9af0b61054c7a2ed9febc19aba2b2191cd3f7b4f1fa97286862089914a6b46cb415a7c4c90229968c4255abe19ca0390a53280ad8bc023e4ad2e785657c6525f4195f0c8efa6b45b53639506a4345401a4f2b440de95952c060a6e4f0dd63c7c6bcb869ee5c1dfcf52303ce96514a4cd588089180a50750b5d6805334b0b25197af5a97f817ed334c3d0deb9c2466139dd2cfa06c38a1a5ff62ce04908ec7785fd9c3850e2abc433cd3200b6680c1ecb4d65ffe2d86b13f81cdf7d957bd6ef68848336825fe15a241ad55c77e30bba184e2ae8333f04b603ccfbb2003233d26895a8348e3f7e2a58774d8afb985ac635abbe9118039978a13e223f813e2a120028ef606f43f301cf25f5c464da1cca7ae1ff9f7798dff23672c5c2d3025433ed63c5a4f27790099f85de215fec436d8b0d51dddc4bc47fc18fd22975d31893046dfbedfcfc618b2886ddef72728dfcaf7867038bc62e6185b837ec2af608a31b4273a9ad4d889e439bf4069e04cd6ac821d6a22f5f000c3b7f4ce0b38ae3461f4148a78f392e618e06abd9f6fd96d0f9f9210880411a1d1dae796c2fec00c1ede58cd67c082c1497171949ccb3f01d2508dd0c0dea840f86fcdb58904f9a5488ac36af550e80bad9f89e2619273964e1f4707112bb758de4996b12cd86742804b99f5861819c7be5f121927a1ce3694cc8aece0b7cbe4465208eeba799d09370fefb5556dff9eec9e0b1dff2be8f24946802c669ee965c2d3e7146c93a737e8b912f818d2a85912f4b341bf0abdfeabee23c5eb511cea6153893d3094cda1537784fe116479f999431c43909b57b9778dea1599028be0b6dca7750bd6f1ba4876141de8a66fc85999eaebd68c5eb69ed2908295bdb3ad138ceb08edfc83cf5cdf736184b9347347ac83fb37ac9753af88528cd71a9551bcb2f77b1a75b06a807c55ece68caa2aaf65e39cc3ffb8f74ee58d1f62a34fc8e3d63bf61af0748e0a825d196056429584e2f89ccee00a33cccfdad6ecdcce17e53bfd40dd684124854273838462362bd391d50c3c77e0eeee39cba2e60c5eb8df1982f2c267b6887bcb4a4115509cfe9671143786e2b0099f0864613e37c432cd369b9b46aec2546ea83e6d6b3de4538952d908e7e757e4f9026f1ae1f59202bcde0490eda32785c61f377bba8db2f4d6b7c97149455321ef339fa351659284f805841089190b61f00f67ffda465237a6833a36f98a107ae68b6fdf1e184d915227ee32a7dfee52aa15f6628ed0689d740cbe72f4c2fb8af7ddd5e87c8c34d535650ad14673e1e6e376aafe0afd766e7f3bde9dfc97bd016e7bfc6cc154f02fa0b2a1795eb49a5d82520d21d33b7ac80f582c2282973780bdf69e2d1aa516634a3fa205c067f2d70cc3228b75bf0c46f4e6451274fec40b59390add52e1e5628223d3978e92d7866bb6ac4465e80dd833e88fb0a99e3985368b9838868f48136a1f46915389f64af0da0a2285a6db5c3938054fd55e3e76f0b19cb5f5113025055ff5c2b24e51885781b2c62420b855086820e6ed4c3fa6ef38f84bdc0e369338a7e428a3b81adb57865c3a491c83bb99b15cb2a44ff6ee00672069434c7abb71d8a7c0707633989019ff83871cea105243ae8e59fe79262f125216e1e021034c8e77399803578b56530358d6fe0111c8b455c60de870656df0606410e1d80cbf49362a044bbf73703000c4514b15612e748b3facc377d4d1b1aa6539e1c8b47bb35b73cff5146f175a8cd28b2cf9c0cd0430ae8b5595964405df89412af142044b9827d52614e77e194e5d000ac1430abad73515ca7e53c85c3ef2d87422d1129839087ded7457db95a076af2763008280f2263f743ab40292f93db69d42e9a891aca9aeeb868b825f0c8d965b12516bf045f6cd29b17f1bdb182acf94977bff37061159749409202ddbc7e276b033d936b4dcdfa2d95f0d25166a5431c78585046da41b7be53e3e25fdee39b2214204a3aeb369de93d7eb0aca20e1097d5c8751a7f2a35064a16036a33b37350dbbbbc3542b32b2875b7da7bdb1bd94b3b6a2db315323ce3e1e62fbc9b8ad956850d293e3a4193f2e4c4a17f884fdc8e4041c19107040c0af053e68b1743297eb4adb8d4f98a7c321dc8845339a3fd0d414be3cb786cf5ef6623f6e9b5ad65dae602c6c1c425f68fec36215789f19559b6b11639e117d29552edc355210d484aac75fc48d1fb845cd58bc533948017793a43aabd74858f53ac7768d1d36d5ff43bc3622c40742ad68714e60840dcf2f0903b81b69f720d45a22921acfcfa1e523d4cfd2d6d996dc0d709725d14450a76fd9d5c5ece2da32b007fef4e40a74d12834dbce0cb7de7e271c9c73bbbfc8b99c82116ec55b6dbc5207d9bbef979c7e0379fc9e087fb4aa3b12fc6943ffb79043e167101c45905343de24fab2cc9457a66f3783c603c8fd1401d6f0fcbcba8e8d30abc3c170f80b301fdde579e4ae3a18eab7203e6750ff20fda1b3df8228c551e7706b8bc28b03b756dc8f9f50423c86001e8b148a6efd29dc17ae67a1934954f768c630f92591f3e5b536edcd81edf07f52d1656156a941c1c4b2ab05400ee0e42d834b903d73727fc1e2c6a16cbb005923c730b500eb115b82ccf53055487cddebbfb8c757ed8f4bfe5a85cb2b4821dbff9921a4cc122ef28b480cc21b4ebffc6245291fa01a342df12e2b8be4fb8f01f797233a7d1b6c2063f3952b8baf48b72f1a13d73589f14bba548c2a84031c3ef2903945a434ef8c2cc2ac0ef94b1428f2a2bf82261ae39de0d7ea9ed8f159965bb2959e6a2fecc42c6d91b1338c53895238b56415788b18f10895a195087318c8c6f872b6be19df64680be76ff9beccb8c4636704d916b5b00a6aad5390a520720cc5c25fd3607c4edbb32c10be66dc53a2fc1f83bf280984e13d259d46149d0fcf03a0a6af5c21ccde72cee0df300b21ee18a1fa2622cfb8fcfd19da606a7f1b3ce755eba5a299067323496485d92753fd75f90924073d6715d66500b8b51d67dc284413a7cfb9d06b0cb365c0a30e168d2864b62e0ce0ee717c609ef14c2661386fe7b9d9fa0946e52ba66f8e0b79b71470fe545e0fa0d33929b70ac9e08267df5357b6f3a83bd48185160a2e3e6b8da748babb70c59a95945fd34b0f464b46588699f821997d0df5e597c8248c7124fcc333b4b33d000346a71ab77c4bcc9b553293efcb06bcf3da1ab0a218d552dc62ed2ffa2b6f6af3c50b30d99eb6eaad185ee472331e9d33d11931bc543f2b590f70593bd87fd10f0d864680a32375b65a440e7f9e9d6d18654ef30b36d37931c345d102442c7a17fb940cbd940f04d8279bd45aee8ff3416720ffabd30e11486a6088376100140d2ff51e06ff35257ff74f7390afebcc0d13594272a58bb8076b8c6065edc626e2e998d5556d23efd04ea20771295b416178f269fed89e896232c2701f2d995d802e74689506c5e3b5aa5a61ed2e63fbdd1a17ec8a360338c97a5459c72cc38f9a429d8337de581e19f7a6992da5442e7f741b24969d6196050aeefba27717727377fe08b0ec256d8cc90b4532ab6f05a237aac8b6cee0dca43d00f8114ef0e5f9d369e1973c2ba30f374735589356c43e64335a098f3c29f9635a8a982fdc16a87a0fc79bd2bcc27951b61845be06412a047bb5e647500a6517c3277d3c50b0f2c5e3e2719fc44d45bcd90c023928dd069aa2995faa081ac503898485cc9c602e1256e8bb197e79af92ee166e634600e9159c30b1571a59c811c9b8d6c98318dbb1fe6064f9946faef1d8258f8d43fe11b41514696953b7f2dc0796f8fc2c7411388852e47b2608bd6e1df3f00316cac6e58d3eeb45ee9ab25f62433964ec26048d85c25323c48ca698666561bab9c1c4b10643fd1b876389f6c952374bd72970e4cfac71c3a5f5d010b75b579264a8472a73d8d1ee9816473d13fb1762ecbd6012f2e434433520e3982868f00a17019553fa713f90482ef598ff7ed9f9d76263c580816736d26f7c8a3d1e908688cccf71e70269fa7e6d4eb58c211448ec9f01898c42c3fa357a1853c7079a69b8bd94181aa111f38686a30bc318be244b2b36b34e70ee5d49000868401c337d233f0d8d5a676148346ae097f2564c03a368abca703207c2d438f3dfaf459f1d2365b3b9504a5f88b854b57625563acf9da4df65847d39e0ba4923a61b0a11f6c2a739e9e4214a2d8147f3245a22b48fa9980e64adf549b44e8a136792d0ed6dcb95dd21ba01f790eb663d4ac3775052908e8560edd8897f92f57d1c1c78fe8748368823469e1d0ed3d613276e9d1cef1ef2b37897c219ea8c1a82da7570ed7c0ceaee240a470f18619fee11b4a825a44f543d9b35fe32109a80d92ef234711cd724839a2e15e4f8fb59ad90d6c4d230c0e4de55dde7e1bf5511ab2fd09df5926270ef77cb7f4145881fbcdc67192afa2dc950781288979adb1111025d3cf4040bd1f8c064a3dc20bbdf4b83bfb83c9417fb3fe06fd979881694cbcedce7e4ab0442fc99c2d3828d22c17a74d3f62ed0aeebc8065d5c7cd107619acc1a49607b43e95e29f3af611f447a4af8043dab7a88ddc76c4cd8b5e06b37ecab19c909aa43f4ce07fb8364eee77c0a87f196c052ac9f4f46ea3b3edcbce19e22e006a1c0eee70664b2fcee8f9bfa4e3e4908442a0161fc5aa198e75fb3b15cf93b4e214febe295d548ed1235cb28d87f304dfd971ba913147f3a9962421f94f38e5cbf7999f87e39ef18ca5f5c2f16361a2f96d359fd5b5d174683198c3833d05ef527167f3fff93502ac611f708d5a41927b57634b5eb6634d6eaeef8b42fad6f78c21631c4d3bff5b54deda8d3388b4d701d7d35f8baabc932d980e028dbac36fae438f7e4954685bf59bd99e20cca4a1ecb98721ddacf55123bc71747172cfffa7ad0f4dc6332383c122f22860998b78680792027de797db69346bf0c31e9fe1b9452f38c34d538a966aca963abe80de2734222ba5ceaeeda2b4a9e270044996afa674d40948ddee7eb88e912319875b23644719bc0fd18890dcb8f95dd20431385993be33188951b458714604b6acc8d8eec8bc1c7cd990b9787e3f9d712ebc5c0ca9dbbaaeef677e43abc66c12aa92659e38d3b431f55aa3022fee0455d5a600d4f768ea78af8e790ac28bd5e4c757cb576fc0eeeafb553e2ea7540c50ca9887d539e2a96bc32af0c3b057ef1f379ac12ad87e0ee4229c2b1b37ff73f3da351fb67f4e9cf1635e36b99de2232183f7c5b00a207145e0c53e433c5d1fbb3bf77ab3fa0dc7261a4221f6bb3cb337170b95fce034c95d38bd49c2b00a187577073bbb322b2bc9e9c7e534c954e7224aeb2af1c2baf7723202af478490fe617bf1ebf8e06282fcb15af565c214fec4e3390c4f4093f74177bc8265e89d63c7c7d2536e0027568fc8be1b755aa9650e49d06d6d5221b49c8007410a8df74df650742092fd53f4d846a73feb3e0be79809080d085c59ff42d1e7d2440512d66f1c5fc7e6b8f87fefef28df1ecd6892034fbb95f1a366090603fb4f758f2d13fa7818be021c670927eba0e3338d8b5e3f9c0c336809364dc0b2bc5e0449abed9e906f9d08694affa123b756ef8dd9ea90f1d87d8bcc3309909d33bcdbcd80a45946e640c45658f08c102cb6707580207cd3f53374fa66423e17f0f2f59b758978139294e2ab7d495e113af3e512e1ae34db6abcfa3de0ea99d3b6cac1d0bdd55555913beed63edb02bccd1ba301c0dd6384b5c0da4feae5d725cd97f38c82e91a98b846eae0d26792774d580db32e111ace8177b2e2b162108bc904d3febfb6d28e34b86854566b9c24211c2da50b540341d482cc5fcf8567b15ce976b5d8db9fed28528a15adb2753bbe9ee9157a7e425d37ab7b052c823206561d807040f88b33fede86c56d1cd52a1aa9c9253c42fcb96eb2cc830b4db304fcea9f7986456fbd0c79ef3efac25fee49612eab5fa8318394528a19b6fec71e4a21930f7a628695b471a07d74dd70f66ccdb1916e3c9ad36e7172fac7c5b5312386cd8a187f2cabd8bc85cb68805e3efff5280af61f40001043e96aace4bd46886727100af25d6d3f514c993f12e25958112eabc9b2f8267d81e4918276af35fee98ee46758ea869c1ef2faaac91366048c27301fdfb759a471f9f99bfe58d00734339b1c61c1e80b25f439174e74b781adecb4fee4e0a0b6f681f897490823c165952932e256f3315507539703f68dd4f7987d35eb081893de183604bc6b59e0cfa74a72f61cef6d421b239976cedf69362546c245847cab133309673e710103069976ead366b400bb00cc0beaac47e7197b0233a8b42284a3c5e8c53597d24a7837963bfb061a7950fc760cb4fc4a94a75428c6f02173ff1c33250789784f2e750d0ad300ab4d5dc2e31899e5b0c868008cded162015406170e9b996dd12031da6459a7eecd7797e29180c0eca8f640d624c456727c2bd1db1db336a007fa7d8a86e4b631dd862ff4878f7dd5f687003ca66cfb26a3f00c530db1ad86734c05b223604ac7f8660b2411d0852113730c42ac63f08fb95d6ce1c725172094b9bb1ea0e502727bd503d708b1b0247b99dfeed0f3da9effe1f1fb1bfb4266281f030fad5e929d71bb679cdbe9a452b1bd061a0bc2f96ac36de63e6656e42c388123f4117c0b6e407074d334cf05af36291141a878fc7ef88f237b3c2f5e19dbe2b3553424d2a37d31dc31a6976edca4ddcd75a0228221b8a4ea0a5a6439c8e5061d0779dffde1daa95bdb1dddd5facd143dfbb80e751566f3b9897c1cedb4a73dff8027c01767b7ddb77a7ce62b917d6a0e9f552bc173b1978d0cba1edf9c88bfa0db06beef910e497d419e02c9beb9139a3174665f6e9051b48cfdcbb3a5cd39c7654ad641bdb7c496ec72532cd28a1ae56684a9ea43b8d76f263a179b5a998b1e6afecd40ed6b1105559e9774f8b80b80402152777b312270b9f7e61ae7d8656470746e0cd53d6afc3886fb677221584416d02959d4ef957ad60baf689ffe058485ebaef105dbaab46324fa494cde881fedbe2d344e190dc831d118840f22e5f680e5bfbad8869f45df31769bf7ad6ea338474020012ea854262c2f70b983451c1ee2ba64e52e46929211079d0384f2a4fe27224347a259ae20de1fbba8a5bcffc594a6d6f9b8bddfd34ff4d8d916c3fa9cc3a77f6479dfe688b23e18739d59181f522f99d488c52dc432e117e93bbc8f111b4786f17f35e454037be76db8ac289f9e8f5f4a6271ec80ae5304e25cac6ee98b48b072e8e8bdbe9cca8696e09fd14e4313dd38a6b7cfa022b23f8ecc7f05131297ee3a6e2bb9af4f9713197a933235b226bff7579f665cd8e95f5e357e49a363a6f8512a7099555bf404a39a206f493797d43cbd5649e6d809358103f1b4425cb1c85a91b612bd3350a1017fa8fec86946bdaf3938a0755f20a11fb5c6bf80a15ad86deeabbdf8ba573cb8d411b77aa3558da19b13a312424b405e3718aca77c9e70baefb5f9baaead9c02ed11e32549bdaa1162c7e1057034c883f18d615cb360fd69cb7065d6f1e5a8df5005d71eb88949ca3f7e05d02ff66e531861cba516e0dff00673d572fffb5d7ffb656ebfefd15a8192acf4e389fc7378685bf093e702c95c5ce331cdb279e20ef4e2b716a5bf37569dd784db23ac4a8f0d82ca715893bfa8f42187d21e4fc9f5dae4386e41835ffb67abd7ba4d458f67bc6a04517661a431f9bee6f10d8bc9736df2fd045b80963b4de43b8843c07f295438a0b0f77d0c6b36502ff2f95e4a54131fd088f2140ffd3977ba05371ae2f4f9dffe564e3be8305d8fba89baf34248b86c72d53c9464a2d561511ec003f4b543134130052b141b0baf12a78a917867929ff67c50b911721ed7bb79094b3ea4a12a3d4dfd34fa4db25ddf7e27b366250628413c9bade287126dda78d87d7835b3bc1c2b77034832c7e1f7133b9122eade3134abb49fb90fca32feedb377acae130a0d17ea36e1aaabcd32097ee9e5860056e5d52277676e4c04b3e2c994c48f8e089db7a3087956820f7ec7a0e936dcab4ac8245fb294f920385feb286e88078eb021d11ef804f34545aaac9cc35f61b9c60cae6dc99da6cc3ef0e02d8b8b542fdf3360e51a925cfd96e1c28ea8be7eab4d9a7ba62e651c47d841dc6906269a24177b088db64752f183edaa86ff015c183a0710d9416a70e68a9ee343241b1eeff73815fb3fc194dec55d60d7edcd8004b9a6e64f713c5024a72446b1a504d8934d1d907e65d731998cee74e386edf6d30501431d63974faa1c3e8450b7d695c0d81cc2a9bbfc70ffc37ca15909b05eef468adacb43af5ebda01703f02d940dc9b459eb491df2770d2ab3e6b7e110b12f1ed06a18526df8458aa64935ceb9e6c67c032e2f0a4d9d0f4b2cdbd94d7f7d8b49e769ec1a49be2a615f2c6e6a0091c61f714c60d897b39ab6358cda721bda56e3bc0f9f014d90cf5fb0a1988422eca790b162354299d8427f0408ea3f1ab02cde221473498423fce537cf5513f83a59add886cd0312c28d23fdda6b9fb5e2367d5cf26b94e790f78ead5094455e99d1e18ad605132e9743ddc924684f08e705bbce85ff5a3ffec791aa0310d1dfb22784267d76303e67f0491219ef13f419e2edef8a69c92de4be13181c9a297e4fbc2b44e9b40deb161277db279184a7af1fc76cec41ff57f6285d31430f3af347b0a2d413fa8eabf1d5076136464f0c52f969e267c162489cb43d0288f5284c6bd0d51d390785912c8295841b9e9ae47d9546afcb4c670cff863af891c1c628de2f7329ed647860f7a5dce2b0be04c98a88fbb8d26b755d760c0dcfb7594060bd73cf26e41c1c78d73ecc85821688bfb97bb34d6424660c00ab1be8ef052c461e9a299b2603d9c2137764d304e46862c4e30a3ac50c821ae4d37b316eeee24d5882b3cd58c5f628116b617d181560cd0bb8c4eecdc078c1103054c05b3e144ed276ef0444d1ec518943190630cae180908b245b78e6f133426befe824156ff0ac496d2a653e3cc248b966e7c06eddebd66a1cc0b777638c4732da2c4c81eb54ba849dd608da54a92a6037fd9468ea0cc741c0246d216f8e077663cd7e253c5481138cab1808346eb91d2fd0791af61508321d18bd87b5d50b895a14bd5586d918d640d6cf3e4c0b2f888ff39d118ead3cd58d7eb58d980f6277e3bed5485501c5418bd21c2702456efa5adda548842641b30da79a498a4ef5673e9469a611296ac78ef4353b6d732cc12a1bf69a266baf0da646eb27f6e2e827205e5c1f35bcd9fd918427fb3005223a3bf37618269264772e50dd290f82aabb49d27deca88243432e0bd19ccc5ebee6b27bac4f44b9f2cf697e4e2c54b1e68d36af5d7e4b3d5f6d6de70d4997e15724a784d449f95ae08c11eedbf23ff4f4fed6e202eeba3125c775e734f8e5d3c8004fc650cf452c405c6c71e404b5b454564b98bb4a1d03aa6b18ac5c3bf3a22bd5e68882e3e547baf3dfb1d5ef55c037daee69e7a7760a92e144c6d931aa1e05089e48ccecc5be463507dcc0efc56fcba7209c817f24fa60e0bd93c376675cb5ceedfb529896d1e12d7bb2bc480a56daf3d0170ec688f3b20d9251d30fb2009d544e44b5ebc943ba96df6de08277643422f9368b8044a1b6347879f84a76ad6bd06850676c3ed3c5dd1b192e75da884b8d59f681afbbc693be92168eaf67d46084eae57223cc7ecf100558ad157259da46f08d3cf23d552364745dc3661797938347ada345d93173a684559252d3fe02bbbd647100f3ae319e811b81ffade05bb03bffa88a4412a267833ce062e4a49a32c148eca294e51273e964b8e83a6d02965414501d269cdb440ceac559e4bfce8905bc466b31f56c37298e595e8d3454ce3dc8a95bd4cef8ac2d771612b237702bae3c1e004ee283f1dfcf149aa2512a0c3e97adb6aab9face7d8acd33affb400c85ec937a9eb596c11291d77eaebcc7f40e2524efe8f1a19df75795897d8dabf3a603f47af5a727fb193ed267346f977690cbe465882f2bc4ab753efc4e681f0d9881f3945b4042606861c572eb8c091bb677df3aed67844deec8454c5ae41d6dd53fdab453f3c6ae22285010b9420e1fb261d1688341752a50656caaa2366db24853e5de982772b6178be84543db5d6aeab9df174429f947189622d6c79cb8542f5da9c1fa544bfa95486025e00268a1079aa0f9f9ba375e1aad00f67b9c31fdf43d972e5c138d85840a935ecc0db6515c6652fd96e753e1f53a17beabb1b75c8318d9cd9b69909656e25c6219f57b3d8f6e22b376204f48dab3c764fc445d5ea76f0de0e1a0b83d56759108397fd133f5e007a70cbddac37f40371ddfb79e6101dcf1be4590138a7fdcf9d0404e36a0c6525bccbe8fa589d5924eef07aeb9302cec3c3ae65633bc4c8b2f26d57727c180e0c9d944ae5b5701ec89de507a5e82f6acac591ac2ed3abbbd5ce5ebdfc0b4284a93b209baff3eee4254329ebf4d555fcdbfe7be1ddf002565b3153717ad6c666e345bc68a6f32ac32c901e4782b673eebe9f68cd9894f0c5f86e1b9374c4a61eb9b5462873a1b560504738d2ec6960e9f4a3a2428e4b97da9acdd3de7493428b2d1e198afcb55d440bfd9d26528f22e46a43c3742b21ad3e1c1258fa0fc2949db42c5577976870a9958de0bcaf76292467d92ce1f756ac776e542cf6e5abf74b885688c3abf88e2a73b8caa0291849bf31760c976a365860a71beaea461bf770c686532ff8600aa6f1e9f236a88ef853c66f9b12e0cb771bcf5f1a54c8a9c14c292bd04a7eef7bfb8515a22fdd0fab3ce7ad0df2bcd9eec6ea1701a2ab6001d567f8700e54fae08bb2607ff2202bb4acede36c8bcd04953d6a779f392157fafa044af9c0f7934136124fac875d0fc3aef7f2caba6b4cb22a2fe413603d781daf911a57a79f17840a2bf2eb91d5be4b1c420c8bf0d839153489ccde90cf000b6e5c8cebedf13717595a3fe45fad9894ebb91d6e6fe1b434432fc5548adca8334ffe3bb0c953aa7cb2466a97e6eeb6bc41c8eba2e9aecad69aa8f9bd9b8d13f27db71fc2b33845da1f340bcbaf80c315cf09c67edafa5327ed833b8edf9565d7a8c720ce1707065aec8626b396b3a94768ef37156afdd828d62df3ac2be176bfc0a5c6025bd6d67a0a03632d90c4b41a1d9182c79a56c5e83f602512899d63125bcec9a59fb0d0218a45570554818d60696514e775cf3e7bb4da3b0774da292df920339e00bfb27a08168973cdb8d620f76bf85f1eabbeedf8d051f07ff6503c11b54e3abbb3babe3f135e45010d25f9a9fb752267f20107b40177973a68767d57c8f8e17632228f23bf14849c98da2a8992d377d40638f21f7aa752be3283ed817826b0d14ea20be831f6bf4fd0d6dc6e8e4806a9a0251fac45b13783013a9bbcca1bfdfd934b3cfde865ce70d53fcb2c49e47ace1955210e9579933315225a2b2a227f8c737a3b66b9bbae5c6465a6f585ce9b7d6165b2f34f65dba8af52ac854c7780e3abd5c9ea007a3ad76d5516cea7f624fffa559ceef297e88208b19795ac34aa695afd52dce900faa6bf24432ae8506abf644b3aaf6c4d13f0a7161f23f88c33daf5fbd0049a3e1742ccec4fcf9cf1ea242e299901f317a524f76113820aedb9e8d923c07dbec7a45ec45381391d2a91f05eaf79a67605b744784c676a21a41d0266a455a30aa4205ad0bd62307709f0562bf81dc4084824fc8cfc296ce4904cbf7c68f790cfd4eaca582444285e866502b12ad68a466cb8b1781c0c891ed229aa7af5de6e6c9cc6d8bba6a39d3a50dfc8b0e57f89524dee4abd966f5e692444755636c7204aee01d0cf543546a5bf18844b5a26b995cfab0b6e3172826a60df91bd8ef960134aa2d9f26654ce50ad85823477c32b713f7a1c975964c035c931f34d50aa1aa53e7d66fbb17ac629a5ce7e131f97445a242533700391e5c4a102c975a19944155b7b2a15a2119cb16a9679117e87acee9fc0632abb46205299eaa6e5bec040f90ddfaae3720ae8f9a788d9548a2619df72baff6ad497be5782543d3818883d8d39e507d05154c41e9cc8d1ec1da40e9b76c9a6830ce680bb5ceb410ff6abf1e6198c90216e2c4382a91a51a85fb914c504df5e86f3a1678772a8ff24cae26304a7666023f1c50758afa42abf3f9e215b4841abfb6bcfaeb444cbb4e53454a377ec6e4c6d4d141affdc04032b28c3c7952665283c3590b7bc387d73268fcebbf6058b0d5e6f64c1f9136e320b55b5ac68afbe81854608861e7a3c60eefe3410ca2d8547f73a0ebcd229606a0636a99b928f932977bc7598f07e092529905b60577d27d0bf29eecd3bf06e850fd6856bb0be26de21df823bb5da885f45112cad02bc46850b3d7490f80a17e21f90ce630cdd776a9071e1ab400e3bd1ec43a4e348cda528e550d8c02c06d3ba16dcbf665d4289b87a565e5c45cb1a6773ee309866217ce8949696cd09dad915bf6f99102f5f240ef691c2ab888afd0915f3f24298163511387a0229d891940a23778a828e9f3eedaba735e079383a59b9d8271f90a62602100a7e146af378b6efb99dfbc5d8e89b2780251bf51acd8596df23f8be98a2d51c6a850080c4ae62da46b074e13b20a5102a1b9076629a763f0a50b024670593db24a6390dc8eb33e329e89357a7fbab776a68cdcb92404ed200866cbf336d8296e2e48ee1268a56775f9ac2886606428802ae6196f3018c326d0fa1f900b7789087d4f80aaa0496a547e77b7e34e7c83dd8e392c87ce6cbfebc59ce269e58bc748bb9f590a72c76399df3f4eb8cd26d75cd5901bccfee4d8f5fbe636feda5a0d1f114518aec6395b99493cc614109d7b14278d2dd0114c195073087f4df6552ce0b0f785e01d87a1d0adbc6edbe50a7b8c8df1586e62f3d74eda832cffc7ca2fab9fd684d55414346c2e09d8c2de511c1328076e80c67fbc885aa4a2a4bf0304d05bd846c8f6456a6101be6a0b841b4a1bafc1d7897ff9826419249db363473904ec50ff07be5762df884e77d734528d6c81903ca8311af7763a7563ec76d275e3aa0d301840657f3292993422dcd7401bbb2251beb882411c5f1f4336da4671f6a9869b83cad89f16c50c1b15fd37f158a0da7076ff6231095c461c015041fd2527b943cd8d83e64f86f1e95e0c7da50a459ed93432c8ffd5ea6dc9314987b2da98a85a779efdf2dfe84c86d238e9c636306909779bce41d38affd7b38119040f64c68123e55f3a5cddef1af8f011c095f98aa4a98fc81b964728ec2847a6054db9ddd6e23a3e6e3aff131a6247103854aca865122b34dde68a44ce94a453c61171f1b12cad5dde5b6b2daa0f9e665705c9e143635bd88e53cd3dbcbf653e07fda48959d14a7098fa72b93603fb2b0d5b2ec5e0dfd8227f60d48fedf2a8b5f1644ab7826eb20279b40b453d2eb1b0f1097c12c432fecc33af7f6f65795910e038a2a5ee80621d4c641d96f0e138bd97997f4b657afc3da8fc2f27b44a1e5c1adcf075bf980e9da353c3a2585b2e43d56838822e5d02e1653d344e2c103bc44d323fe589d74f6f83379f65873f06c450dca9d2fd585399decd5c64c875b76aef8817f301079a6c800f1e69d663de22e8843a048c76ff0ec54964dce53529750b6c7198688305c8521222250ddc14ed2d60ca9be60533196e75a26429ff450b56c74ee686daa60d07016369b6e501f27f4d9f8d649253ee47c5fc0dd73a9a5e1b99d2d2ae8ef9d1976b622270c685b4b3d36f97f3d5d9bd414ad536f49e2f714bc330625c973d00c3dcf2d79d8b5046b60f2694c2d7621529b20e9c64985aa596dda264214200ef35f08ba7ddac99a8a3e0f65ae27f7184995c22d70819048953addd31082476d6f5c805edc3771d36dbeb99384ceafdb9c95645bb132cf869316740dac83f6233d272ab33f50c24d4b66f824a99f7aa018ae4b0ee539a5b0f2f17a11e0ee5a03ef8fd2b406933b193b0e830d18c18e0a4d0ea610f1d1a3b149fe0e06037c7b5f09aa23e02e82fe3a4f989fa74807354318b6800b75e8a3c40f582d77c5f55f2739dc5e813ec651a65c61e479e2dd602312151ba66dd1f0ac21c45d3addd77e62f2c532d0fced2a7023eb612e74c471497dc48224ff6d5ace5f9394c65aec77030927e145fd0095558d08830cb0180571021f122371a6c2fbf452c1f3bb118be774896e975580067a605b7b7260da654952e68e0beed3114b429b98f6687f59650ac3506502360df23f0342c6255dfd744fb489c815d0b6a274788b3a05a74753497ee8e2587ca8a5ed79e068720ab474b9c6242af03d02750490833953ab436ef2d491fa7340cbe4bf8562ddf89ce58a88edd0496358dd43189ec6002f0456fa841b5c83684e05cfede02d399468aab1d3546d2963014b2c49c4c2b1e885b99e9f0cefd3d3b24b00ccbe65fe87fb0f46d49a14a23e4e692f618bc79536f9d3844bef68dc380e44415c8360a7c1b8b16885058dffafa18bdd66c5ab69b22e377dc9e5568d4af3e93017af91be64911eef4441d5451ae4d2ac0025db46987bba0b4ebf3462494107971db8f205d1f86c4acbd01ec973baafe1018b9f3250bb8e17bef9c61f8028ad71cefcd40d1607c4b5fd701c85e9e3310ecdab76f4920c38365e51ea3e507a6dda5f5624fa19c610a6cb953d4f803395a3c2bab0946d2e06b4ae9f0b20e3fe7fa40c6b72d5cabb8be2a4cc2e46106f4c392e55d3cf1f2dac8541bc0e8fd792789abda8e3ca794330c364fdafabb2f3a81f0f0009734363339d99dd3e4b5add53bcc7f14b79cb02cc8db32874d00b49d2d4a986aa7964ee50a902df606ac0b2354c1e6a586808650932e253c416627dcb0c833d31de22e4c28ae1c563b0a22b8b451ece7d7a4a8e42da91425da4a38b88eb6933bbfaab6a8753f2a919bad868fde9d01719ad03697423d6cce7f490bb412db5dce9d4865f8076b34d2334802590fe50ffae2a20187ab573ddde0d4f9b698a22415f10bb83baf008f77c9036f7255ea70d3b4ba759fc36551082e977c7a9e0a65b60c673f60acc6c56e8a08a8436aae24a529f9fdedead96707b803d012b5872e0ed285557055128e8d8ff28aeee0a94e79e1aac73a9c54e9cbef1a8a285695041b57996fa15314d48f6273197fe2f6f4a6b98bb6b24d483689b485ad1af9fb0db32655c210e87f4ab5e63182309436db84b957fa967db975915d6a504c28914bb5f9350b17706323c591a93f87a6f0f9cbfd6eba3260b74b45345fc24f5073281503efff9935b98fd660b1055df208dfa7ee39c0cfc8d42b4ed6acef77cac25ef03233c47a4a442013ec66f191eb05c0852e7b65deef160456b17c029ca9cac5686e068f06ec934f6497f25b0257332992b7d67be082f9836da5ac1479bf24f8a0afab8f22eade48b793f22a318b71ea7151092b2ccbc73d832aaf5a743c94eaf9169d2a12bd2ee8154bdab57cd782f1744053c0517d1a0ec29058fd9f14b2ed27a81682b9399408ced8806ad76c6813c3a1e767f722544f5e8b53b6752ec959267cc0d761d98418d71ace76cca53dfe92c8ca308f5760aa5ac2810a765cc173c110a6d013895e3b171657894d7e4e7407e0125fd5f2fbaebd12e8f653902752d09484be63399cb06d8c6a968bb88c387366781ba2336597a4cd0b59c9444fe855076407de5069b3a31d6a983d10de69436383df390ffc701bdbd81280bb82761ac9fc5e5885cfa45b12190767262caf0b067785f9cbd3124aec50689da84aa0546fd55f4c2410062a33ffed26381e901ef6d00721efd180da9ad46af0168d0976bab579b45565da8694d96c498334eab5863a6e5735572d2300ba713185bbda76b1dfdd1b5d51c7ceabd3e234a3f1a226d003915f6a8551c72532fdadf3c453792c45eead4b99e9bcea13e66d75bdb8842f83785f37088ec75d52de72eb5e3b445769d87a1d6cc2489291d229365bafe3173b352c38ef1d74b67e72be4cfb0441eebebeb0346ce54d1a5444adbfa95413893c55473069ff4de8950a81df36b8d1da32e04f51a5066bfea47c95c9aff466a3324b98f4a5326c003f2be0c5303eed1e01f79fa72485477866bc90b04b7456b2091aa85c63df3708aa0c999a53e8659693e7b4511ec72560bd8a0abc0039b1dcf6ba245a7f8ff6bdfdc3eccb34af2bfccdd177f1cb2902ba489a37b90bdc640841100e25d500ad23f11f6e4746dead6f0ef0b280c34671ad804340654cc9cfe12dbb70866928602ebde93e63b5834f57428fc4c6e16fa3bd9317e1a8769647908760db87c954c14f902bcac42cdefa365946c74e84141a4ac089d496f79721c703ff08781a567559cc3bcf8b1f71ac437db479e1aca5cc9579314d5528158fd8706ca3a499be51c650f6ce8a61c70906adb1745dac279fe36b3f7f2ce425e82ab5367267fa2add859cfca49babecc814a6a0bd994ba9afbe79ea9eb4a0151e539f80fcfe5eb8154530266622c1cae625f9a03efbcc99c4f42ee94f252ec32d583ee8a4f22d585252c2436cdf9319d0e840c5e6a8218b74bfabba1b1da5d442f346813b2085972855a5ef9be9c8fe433fa0edcc7484509f8b5cfb534db27a6ebd161145efbaf65693a1b45ece88addd31ee7de8321686440de5cd025aa66e280a7cd81a929319f7de0d24c339e0f045e01c486fd8662a3fefa518e4582ea733e4c57a76184d8dbd5d79438690d15e6f0c67fb11bcc78c8fc0a286ca09a4a3b52d3d843b6a07e3a0ae6c748d7f4e976220c389c521a39c8c248f410cdcefcece56b91e7474e54c232f5b085060dd3c8258b68223cdd68f6fb742af8b62765764f51f110d64875507fd7d241f11abf44c1b51a76a511324fbb4e7ba81e36314215d8ed4a7277543b9eff78563b249b16c7d9ff9454eeb1ce2c1715af64539ac29332db5d438622390015769501b6c087efe1de1b864651f179452ee2a67209aa790b2efcf1db9416667ca1cfbe34c0be39922826d740979125b107bd85bf3cf265a7cb55fc5d4eb03ca40dbb864c2526c9b5aa2c2966ac721b06a2a9c8838311a65f3e06d1851e6b8ca23030a066609dc23c1d117faddf14b914a495ed4b8f5942d37174b09d6b58885fe037b53276e15b17751c30514e7e4e653b62e7c93ff7bd2a42e05458ec6d6423def3044c5e3342c0ab6e26e815818aa2f74648c94253934242636128511fd7e79f58ec0fc782e56c266586ee7043f39c82a59da8dbdef68f74982b9ab468f80b1374ea23c1600b5321f593520e57051edc14c33e980be921dfa9d4df357ad2a2ef126739dfd75d05a1bdc7fa55c6735e7220b058eb739c3756acad29ef808a6f6481ec70c391c7a63a2ffc60b18ee8d40e3fc7a4b2c6dd83ce4905294ba902a5ba01fc13259740f1f5dee059ec2b3bdd67d9bd0af5e8c043264fe5be3ca8982305ac80695b76ab4da6b0ea5e9f44ebde21fd615f18801023a9c237612033ed217fe072da284c4f99de69dac26a88f1514fb051dbb8ced495536a166a6fbfec63a5466a6b49557702fbd3f1320b24ea581ae66e81739c53721cce7e2d61b4833abd755472ced0f557c9dd9080c932ec4e126bc9fe2075f8802802b13b452387974d00577a5de433f7fe5672b8009f59cee08675575df080534f94c83b94d201ae4cdf2d1915d5083774b47e8f2fc3c4f4a14a1d59598617437c82c0823cdb96887d307d5dbc3da18e4d5706082438ea21bf52e364ba642389755549de78cf89eabbe322b9d3915e908359c55db51e6d3dec74378fafafdfafa0596711a06799ee845fdec2d656ff811b07d7729b694a795d9647f43bfdd7ba5a0a0501e76639196166829c7390f0a54d60532c51fd958d2cf5d06884c305f13391e24ccabfb3c5ab60163d881c5a127208e88253e6d278fa613faf8ea799955f2c8def5040051e57f97d7b0360a0ed1da2db2dba37e393f5d1337a79ac097590c46ab972895db86052937a356cfc6150ab23805bfa18d2bf1db0d3001a94bda1a4488be180ceac58a550fc6a2573c28b26810cad68063be50f59af57fe4d70535cb5bf4ef5324ed6619c533cce33d079401b4b5e9240161589b51f63510685ba18b026ac4c162cdeccbf399570301394b3831a2a2f943c666ee4760777a0fef0145589fb24ab1fc05e30b7523d52333226983117ac8d7b92d5cf0d7c55de9e08fc4df218c1fe2e6af92279194d4b5da88097a39227b1d1d5f77cbdcca9dd234c0e5771b871bee14f0d92b8be963b4e4393dc6d896324be11b9ac2213499f4572e2d6eef964001ad6a1a6324c588a07fed029955ce6cb14ea4936900331b814bcbf2f8baf4816a13a9335745158879c184c2b5bc0ab492ae44002291f36833bef54492c8fdaf190f07e7e325b6dcb34b0bc0fa58f433f24b43e17dc5f4f8b070bf02d1fcf49dd739afc1139ef56b85d0cdad6944cd1e784ca706af69cc748620fd6bbb416f15945ff4b8502b858273fcea346421cd42171408cbadcc8428aed4edffa55566d4e3a0e4904442938b4fc27f673ec5bbe9b1fdfa7a6e61946646fee3be912d7394200b43f7e1b81c61a7431d1c4be4946297027e572246b4f17e564d0df07a7303a21c210f064fe58a8c5d32ab85a39fb96a7e030976392aef49c7438f2fa4e32fd23069cf3bfb4a1bb2b5dd90a87ed23e425b17115daec178bb136be296240dba4bcfce74a13fab2b9a3d491af96bf0118f1d1a57991257d3f80ca850f8771396fa17a9f1ee7b3b3f701061ec6a78180b4299db4e222c8580bd9d3073aea14cd1030be36a17249ee619b4a5bb56ae333ffb9ade15f14724fc7806069182b3995031fac162b96eaf601b81a585f5d72dcd4229877ebed7caa3c9051d73d79f435ba177296ad5659f8356875a3228c178d0a082663cc5b895c0298075a4aa4ea42effacf7a1603ad8f3fe29357006268e8ce703f5277a6ff46953d7d9012a00556b02a889b89c0430b9cc8c3c9e443ec6e29799a2b279bf0ebffc8ac929f3735d68d0b5f6403d61ffc1d94c1d1e520b4ebd410c1b04f91896eac9f879ed923a29f25c2d1c155fd8dcad6096ca410069933e2402501b128caec9d2f474988d039287cd55f3bb72d04e1dfa2526891e2a1ca8120cd1d7d21990773d92c17b4f0220826a4d25e198367ab86ea45d664822a7345d1848bf841f51bbf70fc4fd0ec34a53e87d2aadd55ed8297ecf5da7633dd6e3c4098f25ee98ce84e5f0d7c07404689eb0a2b08841a7b94e17c4a798a867b1bcaf16edf365bfdd5ba8f5fcb53d4745806fa89ce72de47068f2af94af79e81378d3c106f6b08dc82ab9ba090047a18c3f36a8c5fd532bbf1c104acef242fb91203fee489fe6dbf87ae6bb57e2d37cd5479cdc1eaba77061595dd59207393107cbbfa702f86d1f6092d4108bb40802ffea52ebc816e4452cfb9156b70eb7bbdb356fd6263e1f6a381d4034203902b8dadeccb3ed14e183debab77f9029d37f24345685f4fa6195d199f6825d55d0006f4e2446e6078043486daeb099e49aecb37d7531a33b15281442fb0121d49fc7d24e5467705d4621bb071997d65dd9384e4045dcad8e86dc87294bccc30b32ca95c207e524e448c7f8976cf1b4c700cb001c9c7568c2a6cff4ee6ee460b3c4b5a04894bcbe695f0b087d7c596cf8ac9c904da9deb9c89b1be845c26442f76596a48bb26e1f4d0ca5caabcba71b8367c7881470eb380fc23d2a68f80114beb3b31e636deee42c1ecda044a446eeb60c9726c836041dc8774ac83cd5b03bae1112d20425e11b5eb7aa85709bdda15f448c2cb8c8e88e9b9eba1dd3b89c9f6225c0dae9495e73c0ec8eb23cfd88277ece08199302c06e4de72f4c23ce57db379d29ef87e2393d57b827d5fad4b825028ae4f2ccb20d254555c4a9e3271366bc663a55a3f2636fb7ffa785fe37657e1d746d9707853e0857863888270263fecd596d1ab0db9c8247039384138ce357f9bb6000b0927b8bd7185ee38d451a08983af6463fb19d5b228a01be66c7e46f8c532e679702657c7b5ebab763e710e996c3197fe0293365c165d2d8b7d3c3a9219433916085067a210336da52333888c4ede77d026b5bef774981c17500f34f299c9177fb3e97691207fd9ee43561c541124b97020e10ee529d0aec5001c1cf269c0e20d1ced9da111fe345d404a5e812f939d974f0924a843cd5fd723ea0ba75d59156b095f34fe477a30a73a650627f456649061daa304d4040df34338eef9c703729c2abcc6a7af9de085bfc80e3601a90ea701e4d2126a248a39e0152a91b13ec20bafb28716c101a3f4c5a48528c2ee73a4170424838daedb652e218f7589508bd399db2d27a7580400f171cba6944a75e771559eae7e1cbf77b77a997ee77be06e8b311302981bf248f358d054b38f015405f3626b46839c3456c46c78daf1ed19ba79591100d1cd894750f4514622b633c84af0cdca9509ce382c5e2ae36307cb1719da646e221ee2cb6d2cb7a52f74eb7fc78be726ea2d1e7877b6bb26269bc833b80f7b364d09df0f92315100e4911802755375b744a594e20ad71a042dbe34aa1b30bab95cb3689879cff81c66d81262324f3aebdb9373ea411f2cb77c29284e17b5a3aed3f4c100c0cc98e1db0bf455d0bb76c03191ad6eb12a6b6492e3cf58b99936ed99947607c444e7240281c7f2d1044540314e04007ab5a1690faba6496b8edb124c96c159e7e37097983788f8eea0633b551cfb4fe32d5c1129021c9093c6101ac4b83bfa90cb4093b4579da54df165128c8353f375061dca6be48914e23b08011de7ab5b7e9299c7d8175efa99ea957873f3b9d0870758842909e00dd995ff73e5b9ced7a70536bb14630177c0b9e80861013f4b344b04fded5178f4f703f60046614b1d4ac2687d15394125b2a59b9f37f35c9d85c5d99a00a25acd1794abc261015b673cab0e0fe5bed44d57400b2e3be0c408bd348797a449cb1ad54dc84b88c57f7f689cec3757a8ab16c315f68992e75bce6c3be8cc843fd68fe90e4b32542a11ea7b832c5843f4fb7fb47d4c23eaddfa4cc249008b4ec4fae044343efc0dd1b7d3d95565ce65d9c2527d2248a42e58924b7d0baa41f7820cbb7fc5b66d07fd88249f3d7156fd98527c5341bb0450524964c65d3296064bcc4d597453fd93feebd7d07e7ad4db617733e383ae9ed3ea54d2a703f351ac5031d2c2ac049880baee4187b6b7217cdf192acce7d63ec1a508993eb708487c2bcf305fc3a16df9dd960dff4e1452e1f959c96fe5180df60f81fbbedc71a307ae5e8070c1bb4894a793c395ceab19d13ac56bc4daf47164796f0b6e433a20ea60179ab3fb5c19655fa1421424717694009ff78f9047d1142a25c81f596559dcc3d7d5bc20d36f6bc258c81e11b96146c5cfedae8b58d40113b82757a7969653ba5e97050a15d1db9710e536d5cb652621728641385cdb434d70997251971f9dcad1a0130fc20a9917772028e17389926c8a7da892837ec1d01febd2b317c4d46550d823ce702a8de481990276dbe4c058e127cec04585a728fd6fe0723520f403ea0f38290f775a9afd50e34fdea050c7980a14f53ece9d869ea6f3688ae59784340cc95e3d3e940fb51abad58ec225cca07f3f5a4c634a6c0746e263fe31c739b400f6374d2921cd847697996fcc426dcb9103dcea74b6a9e2d4da53d8aaa3c64b7a66ad1f45970894833e8295bbc915b1b2fb49c710e40647ed01f31b02a990f6444f64b8a6110628756930d084b2bb838bb8d67d916f6c6dce6dc70730f4dede8f9ef9d3eed33f2ca94c0ffca74f98c02e82497727a48ca17f5dfaeceacb0bddaecbb9d5c597fcdc838ac7db9c7b37824e0367d8af7ff151c5689758893c7ff966fb7763c3e8e57ccdfbcaea5d92a250d8730dafe1b5511817cf2453e0270a6dfe80877ff6151f35f091d595f6e03d2eb81647d209b6d8633468b816cd1886c50315aabb47ca38e45d14386dd4cf0a718afb75c5abe4892ca9f7833fb7493e19354ffa106130454c9538b8c0c432dc4c32bc4282d9e6ee7020724032100ff54f109a80950cfb13f9e81353aa8efdcab3aae0373ab6d331a447ba72b61c820c1763a0a265273945845bed08bd36b633010b2ec4bcff66ad566f454ef356461ddf7b1e5018ff2488604ef716ef78f3fede1fc5f9e997ae39c0b3ea6ff0db44b3dc27983a456c981ae549911887a0969fc2e00739318bdafa5ca6e844e555c4cec998ad421ea7c412ecc3022a5e70c734626140da479ba61b085c83fa7b940ca0de6a043d59d8e5cdc8626bbd309b70a60be960b0fb7ddd964e015dc210fef408617372cca69dc56c4e33a33990284a343645c1753cfeb254de6d64de2f6d72c1835f8d38601813307509ca5ffed88e7488a6176b0a99378399783eb658ffa32af70b283cb5169aca3a04aa8e7349d6428a7481bc8a7ad35b5aa657f21568591bf49311323a5ced6de2dba5f37e16e6eaaef09994f1b9c39823d5256661fa034964f927e0257f0382ea84a669f8b3a2602af3ba1554a62dc41b34124be96d1feb03cf1c79c996e93bb31870a245cb5f662180e120752afb9ea9d2d556c05f9e003f67142c206be5bb959f3e53c79afd0b5f186453addb6913f8db0f6e6ec4458626e41843e6e29cf34ef400ffaf08abd1f3a8fbf7f19d1d40c6576aa88f3c51da636f2a5a32a4fd334a96d19535ae6db00ab22be37967043335b9cda7685534af7e4d9b1c92cf89126a4e9dafa0e85bf8125a5d81e2d64a5bfb02f68fcd37d2d69fa73ead30c7e1ca5490691397695c4e5da0f0ac6f563aa9feeedb72ba919b236742b6429b426324e9da03cad958c25262724896d932c1f6f20fff868ccc405af9975925565c142b0f615634b62e1483ad567ae946bb96154f0380efb59006465afc0c05ca8c8960eee6d253c7b2f4b05960b3fe958e49d389bcd9f00649a42218358e1765cf5bf00f5af5e2552c46b2fcb99fc935c142c43201bfd66545a182fdcdd38c65a50bd6251da04b7d3296d2a9a65d14b80fd3c6ca941751997212997a3792718ee1ca4d1b51925d7f089d7a02e5bb1848a49f79beb4f1e2c9ee8e607215fa195d18a8653391c0f6897cf0a6cdb5b9015f538f0d4cad4bf1a0020c112e2648c7b2319f0c6fee95b9ac401fdaa73150b466faacf8b93628d28accf94be6e4ffcff13ca37af491b8e8af79f66d93c7eda55142ff13babfc511f9ffc2952ef120da5649c4687053b7163aeabf83b41d4f3a8ee1d0154d04fbb0bcf28c1664083dbec751f9cddff7fe7a16b4e0782e554a35df2df4bdb986863f1a54c8d6a693fca76cc53703f150512bcc8262531e97fc1cbbd0cd072e0cbe2521d5f47e701349da82ff0d6f279921091233c95fe4c6e06f9b392bfe10499cf965788487611b9b532c70b183d70af236202b6716da7f670ea29bc295f5960ce5ca5258be90e350eb72c79d1dd4b191d1f3fe3496639a02c5467ae1c6e3bf2936a360a42af5e7967859265e9607ea1550b842b59306f02e50bca7e2ac7ed862ad726a9bbaf6923a624e161d0e689fdd10b1d926db153a1cda547703794c0396ed1391669bfb38e5faf33e4d808efbe492b651dfee04786834cf71004cf879c2c1ac78ef2f4af8d072e7ab3925c0ee2a94197ccbf43cbdc4945a38495a82c3f11a98ef2cec13beeff0083038dee15d188baab6f48fb4cc3f05b356173be1d12d1fd995fc7c5287b51796f3a0b8669dc09a53fed3d2570e2c1a62443c996e76cc09e5230294d7cbe378e1bbf7fb7da15981e293912555378616ffb12b59fb2637d259ccb2bc6dd04b9f22008547aebb9c4a20b9bb8cf7dffe0ca0ce006aa6daa628e2b8efcbde49a3996e948ff211d1ce14516ee351443fbc4c216786291cb713b92bc6bef806cbfdeebcf973ea14d43f6a13259015c63198ba76fcc18f2aa124415fdf3dfbe9fd04d4def11282499d1f04613dd14a106d16285f3af5c785557c8bceb0c94204de72c260e03df7da430ea09320c8e4b4e03cbe058cf4f39bd2b4bfb9472f1eb44971823adba88b01693901aa18c6d07beb1ae47b69ff7d04a0653f902f018b362cf121a835b715fde26c0c3f6e122203ea1e56cd42770be3a85b21c67b9c7a99647f0937c33e3d5fa4cff489a1abc1bc3a8a122205db5f1b1c026e4117225b7da53ed0b81643d5a817caffecf2eda0620694f489a38f3a17497f9a60f74a1e618d70a7d10122a2cf25718f72c45bf2f446b6f7bd735635065ef29ac2bf5fd72a7e34c618cab22d236523ff94795d1c2fb35f266d57a8f8c22c65bf3306fce22d9215adb6c594b033b75a54e23cedea05776526072dfce22211bac823d8108cbe6d652d2b4beff869a40f421285250bc92f380eacba94febb4237a241087461b2561405053bce8383363adbf61a6a3a362435a9365edcbb2d4ddfe6a124fc7a702a042197a8cf4762b555adb83f84b5e0c89392aa11cf9d8d5790c76273cbf70ba08cb5a800d96947ca741831eae7764c8e0fee08709c6bbe0fa7698d987f720aa266c3061fadc26621a5b2e32562008f8a8c2a49b1def0d18e6a4f27f9207e657a468960752a3ba0ce6624e81dea63979a61a1ea9d0c1492b7e49252ff627017e7c038b66194bed01ea01b63e0c6fecaac39843f47ec42a2081b20a3b4cdbd5b16146040f25e4da99fb229f02a90fe94a209781786554400cc8a4f2db2e73bc9a31cbf5ce5bf913138c84d88d3447c2fc6b700deee642572db4a9faebcb78d29076f36c6fd54548176d099857c4062ed64dd9054b7da8f8a57c029cc9159daa17eacbaafb8db7c930959ea2d6c513c20a81f0c1403363eee6bccda4cdfd2b16a6934361daa8bd222cef6b9abb0ed69d23ce1812f07f92dd67d96bc19152087a2f13b8fac2ef24a3d7acf23810f1d3e4859bb091e74de1de461ab91ed3045f7077626231b1811e62c80247d522ad9c37b2113f38f2ccc650174fcb4053e135740294ae7dd993e1d373a703bac8ab898eff407ef518006f6796122002647a0462877ce29e39127191a29dc6cbf249bd8b21f0b6cdd03099d803a89f5e4e720a635635fabd53307b30db8b9337f05ccc771f554cbf7ef220d5497acf1ff923bdd1bbab521ffc7f2bed3d852ab61c06a469202a98b97c999d366827b44c3f90377b232440eef860cec7c3a5f20231cbcc024ea71640c3d2ac2d348c9bf6de3e8f1213a2a213fba215c36040edeb0574d9b418cc2670e5450b81652cbf9774c4fa326ee93521890f0501ce122da66bffb1fb68d80f0793e2771804ab36e906be0792e1ddb416c4a15ed660ac52463272d24b657d87badf4f1e89e0542b7171573ad0c3242d077e533e7f6b0a245b5c69f58661d1407d1a5697bccf9ec9a2d6868a543e8d83907ab57b4660be97525667513591a1b5d7aa4109b7df58de7a79d233c5f3d560c2e9e88c805ec7b4f2078e9b0bfe0f7d5f99a6deec78f0a99d9b9d912c9f08063496f1016cc2d1ca5b6ea4c3ba8ab64542f10a2cd63dd75f39a0777061c0bc585f15de1b1e141110bc84cbfcad36267239cfcc6b129d29b77fbe2a4acbc6af6cfe1c9e54f220e2b79ce6979b03a284a6b915a30ff1b980b7f772a1893640b1c2d784cac78e045403c50800a312d09a021347ffd930c528e66683fd3d83a574dfc33c1936fd1a47f8d96fa0b0b0e6900c00df82ff8e5cacde279c4a6f104302948c941641ed52dec16edfd25136b3a8bc8c9f4bf74d4e1801d520bc4ac0349436770535ef22d52a0cf0aad134032d2eb7f491b7c5d7efe49e7ae8d5f0d9e2a0c3758503ee5024340af7a5ffc7f15ff5503e7ba3079a8b2d5f2e033bc3996fd35dfcaf75efaf64d295a024d2420956652707c5e301cf334d6b60d9e1b70423d616ba3f34c92289bfb60c76013a1f36d68af5fd2ca2d4403c48d79a20aace73d40f9294dc2a41470cba9068979c29a2ed812db45a9f914e8e516ccf56145aca8181b19d666d51117d7b77ac6559dcd1dab7fa5b190d0139c85292034a60bc5eaa2b91931cb6b1ae58064d90c4ae471f853f736c52428294f98669f3542ce5ee320e763a387c2c09ca66bb06542b4d7664e03373506db46db3a689789e5ad1865c141a81a675d503dcd07ff9396873a027386f26638134557a13496de29433416bd6642d3d570948d0ecd7963b7c6c3d0f7d60b92d32761834f7062a1283fc518c7255245b97725bb9ebb5f04ff006e8005a136d5f65b31990fc1c277aad4376ca595f5a714241afcaf31f50a01dcef768125619726d2e17646a511a04617645a1e5e77e993c4725e61448ee572a23c2dae3dbdacd56557de5a617c0c3ec57e274d513ac221ca801c65856a2ba561b47be6b140e50d043afbe3c45a10e29132802ae355c7cc407b9d2dccad36b4895b97f2ec48f560517ea64dfa75cc16978564594685c315fdf801dc56806d5b64b63ccad52b2d853c59bf71d4a3e4995df32b13e09874402f53185aea7d10031a3b30b2219c2e539ab7d5c27059a877ffad6d07d5c18f0d4f7fda89e28ec801e4e366ed289a1f277704a8d37efaaffd3c82c85b0305d1625710629c3abe0ac56a74a6ce59afd03a749546f8b08a456d4c97d28d36c3241e1cce408ffc10320af9783fbbf8b16f5160abada9efc4f7a064d341a95b960dd56d494462c7b0c9c01a7e90ffa3b92b387ec82382e865a41940042ab2c5dae7342cd9c415483b97ad2ab584b10501d90a04b6c8fc845f2a327772ec4d982eb278b659d535b50bfd2a83b2df5c46b59005e5ec65f2ff3aa4e4b68fe2a9613b9bbb521d04be3a709a3e034961a199dbbae982ed37bf7f386e3c5b857bd084ccba12d36679e6b372b41a5bd0d64fb7aadb21472521075e23e1b4e63f81a5efb274f57bf7faa6b043bc8c697590f2c7b354c835735b591b2a965cbbf67196c0d6ce58fe6af5bda0214871d02056db92a26376a4663b5258b745e47531e398336655d601a7178523de41540b750c26fb92419620d7d67f38d5ad385382730973a14cf7d8a80f2380b2bdbcc7de8d23199bba9e773dd4f5372d66fd867fc69487b30dbbb1b438fbd840f7c96832c8fccd7f224ddb6ab81efb586f61cd364272c97ee096671e2fc127cb457fe71a642a4c5984ec9a232bf2fd69aa1d09d364a795a35447001f38c7f57ef2e04974fa46e3fd582284beb2aed291251c2c755eefa6af555c9ece395a34b411dc6360941461643ce42d796185b282f3903e0452d720682ba398d2bc0591117402a7fef38e59e3ab182e7766e6606c2d951a1319a0f9c3c7b619100ed578ecb67bbbc5853c2a87e3fa517e49fa75606309815ff51bd007261d92fac92614f4201f42f17504d3fd9cebd80c711e6e81d2ca858ac47ec0608fc067c91ad0c43c2ddf50d89084270aef53ba4cbbfd30af7276bc2aeddcd1ac30911f5e288eb4137ee859dd89c5745e971f10e0d60fa1b9504159c58a81c523423b641277939a731b2438d6ba5b5169fd934c2ca5801c4359d6f9c44c612f5bc634f1a2a5c65b69ccd7857aeab1f4afade1f5797be26a1842cc92aa62b7d5ddcf149f82c39fc93f6fc149bf1b88b23b259179435993a00794d006d8d73e056c7c36dc7a611ba5ad1e219d3313d9fcf4f495faf7951a20428619281cc9038fa08a4bbdc0b24ad12600b48c3b69289c05e79189476f9c7adc965efcd96f7058f37a690062700d37a8077808e49aa02cc9e83396eb3f1b74535e6ba598cff9d864e33ea2c7229d465e5d65f0c76cfd79993f67c308c69ee99e3ffa63730fc6b7247087280373d63719735a49e445ffb2ca679042c4b0dec617576c14ffbd0b356fbd5b421229b5ab65a069fdabdcfdcaa951a6afc8bf702475c7c359ab925d5486612ac7807355517ad93649fa89288eb3e7197670e076c409782a3fa19c7728d6ca484e6e965677c724d96f36a6b912040c189fd73eca834b5af1010660ff76212422f961046e1cab29aa7537ee6e87367ba559991df17f84190bb5db65d4c1d9bba8f19bf74b258d75bf0cda1f4bfc3649a00cc047963b3fa5b010ca1551eccc9cf7608e058f5f62193c8c9a4fa7e07c41cc00e82cd3036e1d12f5ab50588cc30f0d9e7f2faa35500888643b3d85a64061523e2d7f0e2053717d2f560742af499e89f8ae2d3fd2906911c4a59894de9d9b07dea3c7e09538a8eb17119fb1859ef662d23177acacd945606e7bc6250da2789f1bb567fc18082b8f1d2bd05b05706fbb461df3c01de4479bd3f9380a3b84f299b1b665234745b6b4aef94c66f3edb731a38c6bade6101787b8719da5c3f7b2f9f28f434face81887551b899ae648d9f29c1646fd0320152c9df77dfb3b9e8777fb090c2c0f533e38aac4d95aa55df2d8b506d0848581e3baa76fc9d01e81882877a8f4aad26bac78b094ed62d555f4813033f4d37933c8de927423a96094c7a9075abcebf90be2c5e7c60706a846c9fe60df10452eadde10b46b80c7187ca2d2d63aed83a33fcba5e3f37e53726c9049d4218f18387331e19fae0f574471118886eae483d32edb392dedebf32cb5b5a87cf070c1a4c11e60fe94689c361689c8d66b42f539b76857f558fb1c36fc33229a698a4bf2ecb521122aa6821a6c4deef11ddd855a7825bb165065e836581c7218c12b9ee202f88bb696190c5b5168e1719aa3510e867bce46df6f995f988eb6f367d2d940c794aae5cdd868d268caa36b9b869363f62dae282ce02e7a9e7dc2d6562784c00c4cecfde1a20ab1fcef68ef2bb59c02a7ac3a7c08e72051b9322ee4b36c4361950f6563bcd753dbe9c030cfab0fb213f243797ea01fb898cb4e67975941f8da4130b90e7f7a89aec99c2270d3c3f78f5e4256699b2c194f72451bb8a7e5215c840b0b80d9f43f396f00f1b77558347780f84badcd1076ded9913a562ea61e6dfd25ea60bd599e7f867ae0f233c96c5580ac6eaba93d7b9c8a583471b4637bae9ac7e3ab706145f4818283c3bf6bcd09bb903261412448524d8b5aace00781eaaf8c000519f5506bb083aa263a951b72c2536b41a553cc1113590983059cb3dfc3e01219f352eeb022fcba050d3707e5099eb89c9973fe807e37b324cf28c45d9ec71b62166227209fbfb0d958537ac20f00f56f49cee9186f49d8ce0fde0a11a4987ab50241e6fa768aab65d8dc4eac8c0556cfc00e7816366242f87e59a82ffe051668b7bf78a8e25171df4cedeb22c51b8f5573e4c32650c8c90054e160a39d5945eb2f9c0f176e8974042ca0e2a18f7ce35d6c5a0511dc25d90edce197139cd8144e6b04159439ca4ba218f93afa36b00d7016854b33f74e4316804b9acdbc6d3dc032b68bcdcc0c111dd3c02ffa52b1b56a724e92dd688eb499740c7966872e1a64c0645ab0d3139d7a275d9ccb9d57ed4a69bcaf3772111d9a674a056a175552cc19544171d338635aa6a9340f39ef65a1fa744c47a3ea71f52a41898be364b7f8b5312410f95e565c4b48319f271b769fa703ca7b6ee1147be0682450ffcc0f8c3f7b45bd3c158fb51b489da441c219231d2269c2d18781215baabada5eae8222cdd48eb2b439474cd1519bb9835304a137a75aa8c47385f13370f700e78c7131ba4a60205a081ed2f0a0a85f0af558c0081189c1c767d16ee827163cb6694f96be82aa95dacd9df066cc17bdd595880fa1316881049a1af8fa425bff1d349592792e7736c964c13628f85953be37cca19cbe3c10ddefe117bfd1907b898a646a1484ccdbb0dc2b926ebf375aa6ed44bf53167ad170cb0cd7c5334a13957271791e735ad10dbbdd7f915fbdd42356b01606ae1ee00955e094555ce6b38ed67ee3343dbb2a8a9fa389d20ccaa6773c6ddfd7713ca3a1e8113ba4ae75e4dd3b865ce5775fa3d826100859481d0a6086a809bc413d4952eec72d1d8cbcd1dea6991151c99a1c00c3f868df37b9c52e9a0d9ee14f79e88f95bd941bdb6eee8962367e6147041375ea4773627351a166cc82d04fd0cdaf5d93895cc56699849b0d19c4ee7a43e5a032ef4ef1743f1088f62ccbe740582e3310a1ba0bc31c952229ccc2c6aef7793cf6ce3a6fd6150dd082fce5d58e37720a3dbb12c187aec4d743e54883e125497885c80ce9402fe9cf6e4515e18bc76e1a205ec1e862a1777b258316f94c25ff36ac37a65ef688c6ee11ccbc7b7e14bcb8ba8881e1e0e68a6c8588726ced8dbe8a2f0e73fc4407f86453e765681cd7dfd5c87a46adf87118a9f97e59c8b232aeb317099e8baa07bb7e1c3377a85b4910687f711adaa7d7afbf018f8fab6a3c366a009242c80ca3c1fc11c51f90d6f8dea4b1a06ca60590dc88592fb8a746537cb09c7034ec9e34e4cbdb950f8bb6cde698f2d46f607675bde55b881f3ec7200b951eabd9b51dbbb90f10884c4b3c276b50fb5937957d0594abc5825cd5a3eee0fd72c3053793328627a31f5a6c8ff2bfae3febe2a06b4a043380733a27080b3f2ffa3a8ec1ec9c102be156de3995717519752540115190fab19d473146346872b21ea8e4716c2271c0b6bfa1e376c57e118930714c8b57cbc9e10a40c12be89df8d420e814519306d11d7374ae1e6842c1c012c50bc5317307c54b699cbf73b4e99e1f8fcaf4791f321ed5beaf7ed1a02b5080bac5377cc55e4977c35450bf542db82879e431fe96fff971cc5bf71ac2d6c2d045ea2371a0bde18fe81084ee98d6f507d2704253d44168904cc34bcc2a448bbd639f612b1390f035dd9c32d271a1dc58a2a2d7bf3523bd84f36a34066c46c24909ee3cfc024c40a681e4b5702b28fc4e286e26c178ccb03e7974d4389ca56e12a4404d491686017dc2e62cc6b047cba60c14aa440d7775c095105b49634eee312f9acade4294235b3210c1f45c785810dc87d658a94956d5ceabb27d4968f395348c4e191aa84b4568b7bbb8aca50d8210cff10e2d76086f5bd29c0d48ea25703a7560d77bb5c667b7beffda2faf66a6771407903bb1e9203ff51c339004ed6b4d0693ee761139275440722c7056387904ed0ba14b9ea0fcca2172b4937552019e8105e9f008b3eeffb9b509972273ddb86b0e4b1cb023605a3981bbcf96562ff3033c32ac5b48005e1ea75577e094cd2a416eed267142c7620f8473171424165bdff1a4074fdbb1365b60f6d3e9e87d51810fd6b84a95b94d2b0b50bf5820dc8d46001a7e1c9ab6b28e1fd2a3dfedb7254736027f3cdd165c5925d8a2f3e9931558691590d5001341fe01c5cb62f955e977cedc06c5e7d6e67d77d3e22d092e55c851565836bbe90c33a7b4b0adf88260b9cf84a3cffd4c4bdc6d4a8f4b82d90f5657c5b3ab21e5d1e51b51429bb60763392e4346b1347b68294bd7e90612478bddf7511865d6a13513689cb5dd18ef1776edeecfe48ba73f4072cacc8cbadd0de414a52e063da12295b07a87ea1cb546ac14957bedc17e17482e4a7d2f191ae281af5f9b3f53ee342b7bee17043a31ed0f69fc7880a75f649499ab3d6798d368423da1e750fbc8f60c79187829169a02eed5a9d3d7d2df3e90e812774d1443e59b8de8c0d607b0f9f686b7f3f31e0d55bb7d5b9f49932e6e84a7e7e55aa1cfb78d087e7210fe88a4dab1f56b118c7fb80e24b561344605c82694650205407bba69e7a72c78cd7d9820cfb85807fe7937814a87752e76184c766e8ed91f3026df4a95a5b75078256aeedc9ff83e7dad63b6b6cfdf23533238b1abbd1fc3834cce66a0cb2afb913e4cb61d7cd79a68e4c54e764eac8c1bcb03cd8d55afe52e5c64251215a6113deae2b60a1915481618bf6580492d345fff8ce12fc1433099f9cfaeed5fafc64de0385e4e790ace258f8108427be17fe20f1674f0521c1c1cd496ce4f6d2c39cd240a5d1e2b6b1dc2b8c012aa6f726263eb6fc4cc2afea371287c023dd85476677058d79c9a19877cd8fd57242935fbb2e5106deeacd79fd41836b9e6d90dcafa0bf7687eded7924169c50056c2cb698311ac9903dfaec277748dc7a9692159c358aafacef178b1c41733ca7aa82f1e8f0c4fe0c7397ab19e197dbc53c57084e10f967e9537c55b3785a7a8636f07b89518785e364e8c6b6322c060cf66cc623e6a6ccd0d8dfda7f6ac3b63c0bcf9b9124f08cc2a74e7f51c13018b9f6aa127ad61a034570e4678cc1463d0b6638747a8a1492f85b5f7d96d9b09a7554535762baaf12c98983265387b6c06e9d5ea5983d4add1008d99b3579e6279648184fdf33bbd4a6fb2f2d3722f9c0354556c89b656d30572c6ffd4f6996e7fa22e6e1fe825a74bb39cb47ef083a4addbfc754157bcaeb5ca15c6995a2ad7760552e0e29fcf72fa147bc0e16ba4a5322498fe7b4d7cd76c45f83dc246d76d92371390bb38bf6170ef8b33bdc2ad862a5026b7075a8967202ae9e7e6b4db67616189ccbe669d324fc687cb7e3f66d61f4cc8864f187f34d17a682c107071e70d1e33381c70513be30c1fb7b5e130ac0a107c7786808dcf177c1a4ac4b0c6de48a8ed80614f0b0e79451ac63357907269a1abf873f0bd5e6142297ec4a88b6336c01b7d8ee35a10b2696652ce771a6aa5b9af81f04a1c3f037cf0e6ec13cfc305ab49f9d745ccf54d33600e017a7307307de550c7c05b7028b4e1dc061adda7c794630ae3f1b2cbeeeaeccd50a2351c47b0f7de7db1e2ea16c02f568353b13f1f62fc14dcb7709370ca16f7ef8d11ce2d4a78bcc0cc76590c779c5971ebb4ff3dfbc201c3a3e8e9bf389894acd200072c3e8a3d1eb0f5adaddbc473042758f5e4a124325280220b181fbab9d135b99d5afe13beb1bc927bc2eef653f7c93289638326c9a2c78fbbcaed7fa1fdad502a37bdab33cf59ade1a766c3c2592736df1a59c9ea40bc5909299de716aa858bc41abd503729865229866dcb7c4966096c5c49b7f86b379cc94a4049dd7330aef68691a317801ceef6e33e39b22ae33f4ce775792511c2a1014ea9d1a7ff0f8c2877d2b036de9cb238c058efe6ed8af6140eb6de75914e1922c320241d67f659b82c1ea6ce1da441e1de11d7c3d93a9e41f0caaa8978256cf5645a593394f292507d4caeae8fbfb74954a4fba6f6fe08b1de21b7dbdb1e9dd810258045885fd3b7da974ffab61d6e3cf308764a6c5a64944626981c5989f44214273cc8526ba5f0d0d17dc838580d227b6b1b58e9024740e11cf752052aec4eceddd35b86e6b74be512418690bde032daf092a7d9f91c3d8edd4e57109a72807f76dba343146b5a1dd4f3574e697e38618158f3f0a31ae9357e8dbca251becdbc6a05a37f7b82c70b69570d225643335be32b3a204e52976627b39d8c6a711cd50be8c00391431d8ac3fae69ca29c6b5611705b1e18c670010b72ec8404a5ab247151088a70a509b01f5da97a8a58b73225c23dfa1dfb720210d76234b999bc06e35f51b09dc58c99b5a0c82ff6ae1ed108e1db058aa79d13834afc040799dddfba2c7d33b7062d8004662a1e2521360b456a97e9ae08f594142099b104b5952f9436ed8584d8c539cf132ddd20c54aae6dc737e8904535173602722df1eb88ab80b12858d6bd4e8a303d5cc726825956883abdc7d9856d818914aefc8f0bc1239b99c87925609653ddd8647f1d4555fbf87a30f2e934139e929ca917ba2cfbf3814c3899987cba27ef2e6693f0a54aab2c790840dae279b645f28a05ddf24543adff36e937974ae40fd155e826ec7f45fa2c0f218fc7e7bb066a38c50253860418808a2856cf60ccdc99c7227dd312a9639deda3d08e091ad50c7b5d0bcec4f44457147be2dc91e642318c978790f59024094006531c7924bdd8836670c4f16d4a2b7d55829462c29b4fd5181a87344480a8cadb8c433024de80e78dd1da3ca5a3e35173e9ea834640808fbb6301eb2923419a34d94b81fd3f3ac7dcc37dfaff1feabd23970de519c5a88c5eed95c6347d79c332064b2a4592045023e1f05b84824fdbdd4c86e26f8ad6e2381b7781980eb05d6560ab6348d41b2709b6fb203c5dc042ef32b90e2f2f7780653ce2f5b59def66859c2b87ce3060ce1b48fa1c4cd01e4eb4e63d4f78e766d9b53d2f2f08b8d3375c486c63de54f25d27f9844b346c4d31b721279592f2413f2545fe115b250836d6b270e577b1304a96977c036b8625e01d8af197a7b23fb8f0013e69b641653d0581c5e38eb1e06af6ac03a785cda7e0db589729222ed03be1113e0ba95045f5ad6301d22a831ac95e55aa2653e1e450a41013301672bfc4f3b3c32d33df1b0db3f50fccc5c3f0ca99a5285e45ebc6c0ffcb472372e50ada298a5567744c8f5f864b428a11d62a8dda2b2e08e543788ff782dc137dd214d556ee1468323683afaac63d3b4c3d72b7fc3a9f8dc09ffdbce28cf767644f03dfc85a692e9f262f841eb9b09e69384ecc1bff889cb1431b1b3d21591f19b47f525ad7f44c616daff78a5a95194e55734ef43bae1ebdf6992739311ad33b2ad893c8a90a9785d9f4bcba58a8063990ac5c4bf070fba11e849c2a312184dccadbe22da9462629ccd39f30bb6d288087c9e96e793515954ec3215d4c2c2286fe99221cb97a6db329e088b7e9c6d50ac98f20bb282ed85e9224525c26248f4fd73e7aed5b63e19277ea4af8bca9938aa1b6017143615a6bd3bf43fcd37d8b7a47f38226a986c42f503b2cbe88f90428469c6adc017d58196c08d1165ed2685099d88b0939ab4e5411cdba2aca41290374c74b789581706c673b9eaf0fd346e884ab01b8fe6ef9fafbc3cffeba7b7c641dbc730b00cc5a2fe2621955bb4535a492a1fa1dab669453fb1f5bf82ba0ae79fd74e08e47fcd6917c8b8596736689df927326aa816d6cd95a3d2c0800c6b6dc25d3736f6b984ae2fb3757e47cf85f443cde0b67aa42c174b096e25014dd59c8b82cea81fa2221ae464dc94302e54f047e8c699f3eb7e9b908e35d341fb0232e39e88b644708134fa77010d4a56f13f8578d0666df9955921d0d6bce35b8eb1aa19ac607b8faf7ff58473e274eb41612cceb50f4d953a9b22b41c808df81541e6000409cf1efa0948b78aba8da6e65551735548abad58f4cdd2ea54b65cf62b7c5c3118b85c59e54d079ac8bfc7c6ec7dfed85b4dbf1d5855c61f8a53eebebbeb6a0e6e899440f539a474a925b193abf48fa891f83b4a4517c9511cf4083764ebb78bd7899f3f6a507bc91a13fff8b4bd93f50c6424932eab46be15c74728c8d6978ef7706841b03bc0ed9168861f446e41e072db9de74562f21dd8fb0c0181e2d05542a619edd83d3e5dc0be5df2882c14c4b8d0b28b53814a6ea1cc0cb589ca45e4278097af457f75143523d80d25c71e8c7ef683583014656565d914a91786fce9e37f850cc1cde66a0f26ba6a2fb143843818b5077f6221bafb537ea3db450a69a1efd45222cc72e96156a08100e73f03c8415aa31310a613dbbfae7453c823f7defc2a71fb7c293de7304d19ff36571c10d957f1389cd6bd3d473f979d29923f988d22d0212322dacc6aaa3c19dbd37b5c97e63628a4b3f8109e987d6607b33ebc2f79a075e29f507f30499781b30adf71891ec03d67200cf43da6762c3c14f1d611a6d8367a44f871c18f801bad2afb28efbea52d44b79b5b0fa1848e9d3ecaea44e8e3e33c53ba293aae22948f1dc7a663d560b5ebc027c50702ee2884f3ed39f29baa04c8a1172297f9297da834d6b785d59f48bd3456ff1f7238b8e76ee36ebdc8361d37aba29b470f8b6da9849c76c22fcfbc0459e1a961e56a05a86923d43ef0c720b8dc8f44b87a6dd964db8b54a064cffbdf6db022b4a4df720d9d41a0a0ed5beb4f5293f967d3c17f40ee1953ac1e96b44fd39c2bb4f4ec14ed1cc967c3d4f355a50214beef15590a5e6d360c018aba477b46db18a8f941abcd1788d33a3ffc1020fced7ab0f6cf1cde6267823fbe2e2dc4bdab0c25ebfb0918add577686bd5f73e779f5d91f995a8daae090e548992214d167985cbd7dc3db6bdca155eebeedd10c50009be43ea6fffc2d1b4eec5ea7503ef0b68be11547452aa6bc84506a1f4d89054094a68e5f87779eebc5ea858b4dd2407dd508d5efb01bf0b01924b38b7b20c5b618248259720a896427d7fb7b7fd4bcb03123cd96421293b1c774e821d8f1d9761dd9eafc704871460add964da48a8a7b221f544a627c9cb17e4cbceaa64b51f1d1218078ca96eae6b9be9c51de70317a2589b387fbff1332f5f312a16baf029852c71119481be27ae2ab65be1c55b56f1f6910400c7a7e80975dbfad768ee4f99fef4628fd09c356e7371d68fb071636bf3f0f611f9df5fd075f1048ad8063643b54d0aa7f89d9d73228a1be2edfba28aa99acb025b6e9063952928490f0dada52f6b0316aa26de5f5ce5ec95b30478e5e465324f33acd76dc7c70f642df828a4f64d699d09f37c6f9e466c5f5bc3628bf9e57b306043ad0cf9169c75fd9b8a722904256ff3ed63b43304224d6fa5293907510869fbffd72ff09b39f2f5cf8e53dc5402a63ff85b23711e2da96a585b6bca90438987a5b18a133ab72770303b700f1b8b57b296b5af1857e5c13a1691ac25a0f6c5b6d493fe9b461f48d3b06f591a06c9d3cc9e071b5764bf3a7b3af87baccfddf64d1b452d236cc253cf33b351ebdfc4515f58e09f44131a216ff3e3337e56c86a8f63c44ff084ce8230ff2934e9f271628562c57354f6eb79b036234464c8e4eb3c5eae27b19296a7806b12fedb81c66a88367736cdf3b61f1c225bfadf3569887f0bd0dce2e0772bf613e0de600c8583de59bab18a075f092d9d1a438455c9d442f1a887299632acd405606eedf0b9360a0695be3a1a98903d11ccd6e55a617a2ead908bec272cc5d977fa8a121832563d3c51148b31e88035bc493a957104188794f8020ca1ca238d1de16e8752c74d3e538b146418896ceed787918fd61130e2bb92f40ff1fc90afa74858d8c72d53f7bdf274e598cdfa168ccd447977373c2852c7dcccf1a0a0be13b9b6b7fc10b6292972802c852c52d7298076796254dc84774133f8d2b1037f58daa0fac822318f6e5b510024fb3eb696e632bbb1dc3f7b1003f013720475424561164119527e9f9442c37c7863b9b582527ec1c24d8eeb6680551d3d6ff21d025e8e979ca0645881cc1f9397e42a14504cf9a34d6e3eb278c26988cbaaa20e33c063826f0a7bddac32cc54443f40618edb9fbb2adafd069c004e07ea0dee9799eba42de39dbe33a79e74f69fc415303b0a2f178787a193a47ed83766708aea344048df0412c6a87304562dcf155031a807362c4e52070e1dbf3c90fbd1b06f3752b410f7cca0c06d7069690225dbd8917785a02ad25905614e1563a83ec372d7e19e78b97e2fe1f9b9136d599e54c861475ba91bef04cb9a21c0def91330285425f5683edb356900bd55b0444a5d1030c8a811648733535b6e0408fa638fb4db503167c44338f31998ae55dbfe714a362e8a77c670558d2353b7dec72c746836e371fba3c732f89a894da53c19d42de29cce07edc2609e1fa6834588fddc7dee868b4fd9b0e3601a645e33b49dbf0253a1d4dc725e370c3c72cee8dcedc6a023b36d7db0c8dab6e5e301bee3eb4d525e186a21eb2c978bf1b0e615027fbe8337a3b25b81b815493ab84dae91b72f248181fb7e4a5a117b3da971cb7d819e6d26a00d14e4b8ae30d3bb05f912d97aa731fb5e1e4d1457b0783cd2ecdfabda5b0db5a70f09eb9b9b3c6a1bc4add272fa3a8c7c92b8176af328267e8932577e9ce31f01ef5ed402ebad76e818e5b5a0b7edb356d1dcdeaa8fef67178b254b052353f760c8f27edd474cc6f36914dfc66fc7d54e46c3955b24fcb64b8ef40949a1dc7a0eab4f69dddaff84a5a57f2374ff566c4dc71d010b0e3cbeb004552116f401a8b3b1041bd5e4375e9b2fe7cfb8cf010f483a2a9ade1d624c96e4ad06745aafb6b16fef23c000d13b79c926fb508d2a9fa2e6643079bb6d4617c506cb483e37fec77978f46fe9aaf58615c1da6d161debf199a682a33b21a4e62aa791a99730579d0802b8363f66215aa4620d20183f0ee11f152527eb65f91f9f00f2b77e6f53cb4186882fea53204fd901da9411db2b311848c1aaa434970b4435a066f635023746e385a06fa6495b0554679463e1edbc98b825c283613f915e927d819b484acac00f318e240ede2f169f33e6554fe503f88c76b0546b35dd288fa1ce147479413a24c392cbccf241c526f69b70c8f55b4ab5c40b14a42de6aaf49fbf1860c087a5f4bc7d65c0784936e1b085214ea59d5dac78fe9f92049218723b492cb68b9dc94448fff91b1b7059fe232ee927348f096e86eaf24480578e90c495607d00d02a3ad1d9e48cea1e0de6c02ce32a63a1e751bbfd25522f34f0570d23c4620dab68ac36d90a98beaaa40628120a11119ff5b7d77c2667ef8eb36dbca1b843a7c9326a846f3c93d282ed27b40e21fd6fcb1d03c90310671d6e6ad7f0a1a985adacddf1d19c9719df2be0494ac4047eb768f8fe074289b124299876d139503ecb8e2da2ec65dd169b6a1ca4e6d890304ba3b43b4b9303fb63576b13174efa6d6b2ce2a09d38ab08403e18dae7f5fdc890ecc6ca6a24546a196324ac7e549efe205e889c3506ecafbae5a9c66067290c87443cee9d1a852388a12d6a8c0e0dd6a8ef916a67424b28a88adc74648a0e6c3c5e15d9008cfa0af7d5297bdc15339117443f3298cb307e59af2ae58952bd031ac1cca361ecf557597e6d99cf43e1ca46f3a50ce9ed0a4cb4bb31e82be6c0517c481a922d1b4e291841e4e9489754780efe8fa1e3ff388c449d1f8f87d5d1ac71e969c09f6da0a2aaa27b481852e659c44d9094e2f9cd9adbee735d9e9469bd7e2dff0dadf50c51935ef3e6dfbe850260f11005d30bef825f3ffd2a76db8802e3a7ee43bb6351b4a4e80e7d4c24e4089624b1685052bc184a49292a4a8ff53d911769086743a8cceb2a5aecc4e9c9aa6583e61b545ac08d94087e067ffba9a6b69a324ab669ef877efad21cd194ed77149b64da1f00d403174edb519134a9917e102fd3c3fc3688252314b786cc3bdc66816093df8729a9e420fa5a3d17db2ef06cf07401715613a9c97e47005877c6adda2d90a109cd384be2bc244c10bf5c2ca70617567ab7de27e6a20131393fae5d8f0cfc0b430861a33269506399a115fdf1d8e59d289c4e48513b9b6d1576f0ab33a7ed2d32d43eb36aa5d5a23b6bcbcc42b609cd23f304afb93e2b4caea79c932fa5a149c0ee933b74ac355dc06fb88afc77cb7e204f11ce4c988fa2d6fb1e455a8f6e2275226f92b9a093dabcf6bff555790be10c26abec137176655de8a985e59a97f9013bb74d86e04fb494c78b2e6010f0cde95bf4b7ce2b2c8c0a5013a3779e19affefd2623e40c3858fc0ce2e5f2580696cf3821008ae069173bafe4e85ae27288b4cac425d5a70ad1898594a455a0387626516a55f676f78da2a73030d055e9d119d0f2389e5e3d28501cd8b1f69990e0f2996a0de4b4a5bfaf4bb8158c73b16d071076c6c59fb56ba4eaafb1e80b2aae41238e4ba453aa43d77af0d50efc8715c5b491536054203b86ddfceb661615d79f3a60fc73eeb66e7314326d3aef406bea5f5376bb30e1ffd60b43fd37a4b66a06cacc265fb6eea58debd1689610db0c7c75c8a33d9d4726f90fe3b5eea3e26310384f69f4325cd67483dd0beeff6f49192af4f2221b65b994e2ab941d1384dc58a9409e0fa4600bc2aae7022ef87bfb03824a564207a7694d3a278030df976adc98fc163db4abf152078e4ca00a6b98f4f9b5e1574a254b2fa9f5b98bc153c975fcae4a389c40fcd01c7a28f49750ad6619dc14a9db58ca83ef1c92615978a43029c4572d1c8f6cd208cee2670f76c69b9fca6fa748eda4aab78309f2dcc7bd96b482cf34cc137016147bb42265feee86f42b16a6d160f451d77025728f5d9b76357ba01a2372db0d1eaf60622ece96980687f1be1b5e799def1b1757a0c4806b14480b324be84271ba81ef9722e9cdd1ce33982beed03d2639a66db8ad025cf7abdc18065be53963334911c69fd82d041da0ddd8118d643474413e206417e9f505bc5edf23700408907f4b10174443f151eaaec5738b7346d95a8e50cd5c8a626cf13ebb9c9d0ef72035bde79bc8c108f097d25442480cbb0d7ddafeed556b991af41a5bbe75aac1e9b5d0723648df0e4f5c4fee8812a21f84db5f4c96122064c37f7f0abe38be3383ac4e5e807b15e556d67f652f333e9d37658ea2c8a5c3ee7a22b61c1c16b412b97d28bd8ac3ecb5bd803377f9ffad6e2f48c4ace5f4fa7bfebbdda7ea44442fcd9483cb5f5d5eae216896a530440388019b6dbf21c365aa9c56d81888d486969faf4c628caf4c132a50d19db0fd210180276ac963e364268575d2154fa44bfb7fd26eb17a732ec16f3b24f27a764ffbbbddef24fd0671f487fa3c2ddcb809604c658aed76e3943a56be156d17ec892a5c3e1a460488bca043c2543c2431d695014190d001addf1611ac8f93f4526ebb31397e0e31a54727ab01c4dc20b726700e273536f68b11369c13a4e1b51e7a534612563675c5ad0d047d2e8d685a7d21866dff34b201b14c33e4751a4644e435bb57acaf6a3afe1056625d2d9a9c484379fc78e5ee313fe3baed347c0c10895bbe7edd39b55fd0ce27104c3ba33b96995323f20035e276182c23419b8d5f8b79d5ae8c93b206db0c9dd31114cbcf8b41da8bb7a524fa1c2aa31c137a092f2b98c5023c9cef040282d7489139921c7fa23aedb0d2a7957b76699f879d34a62783ff18098e1e857e587126020ecbe3f6fd41b1b52e0d096e72f5e18303a0cf86f8f2d07690dfbff651485d2a23aabd8aa2e05395e660e3fd9f01a6ccd8f81ab167bd4d1272d01414cb608a30faa52a7eab7ae3aeef4217ab875f97344fa065e47fdca4714410fb7990b17bf019fd6c33ddd4d5b364265012de29e3a3b856ba25aa9355b23b489ad68a00f245bcbdae65e612caaa1ef03ffd6544174a1e7f49a45c451abbfe23a24cabffb11e84d9df17a33fdb8bd91ac3bef33fbe30ae1219d33dd79e557e03dee7f583e29e4f1e116a2c77a41181657fa0b419f0896df6fa49a209dd1d1994e9f3c279f05e05e8997a709e20494c19db56814856981641320c2c95de45b88968cee68e3718f77ee407c5a844aa1e1cb6b5276ed4f886a9dc000bf7f9bcf18bda4f71d96bd18cf9a02e95b9a599f0cbbedb409bc77b597c25cc10678fc78b39b21eac8ccef029bbe380ead991b1a4963fa2cbcf74e49b4b6adea99a8204b17b5432475159929a61a98abb37bcc1e1a087b5b6abda2cee30604e2264743d288d0f8ff64b5ba9d26fb66fd6b54386120442ed6d08bb7cba28b438c50aeaa92b320be6530ddc3f514a1252c1cefb5b54432698d823de2ca54b908ec7e90aacb52f7876bbe30a231bb01bcd289cd85f8305bf0cbece0760b6e6b30a8c4871a5176e29afca0531195727b790ef4142f185e0a7e32bd170f3b39c68c0e6b2e0d45a974172f7c778874c1fd2c4125331c4fd184753241d4695aeae3065fdc5c7af8b53863640eae4032fb8cb9f620eaf97e5daf2a9856c73e5be153096112d153ade12d4f849ac4f21ae136bedc164025f53ea0389160095a0c22e8983b2375427eb9f2136f13886440c17d2ed898974f0b35589475e5b4497190cdb5f81d401b4b119b41fa18801dc69d28b3feb07f7bcc2aba1a6fd8c47d2fb8409f8f6b4fd6e4ad04d361f8f0d617b732701e58f2bda2cdee78fe81dc0a4649e08a1cc30f5af7e6f7eb59df0964fb5536e40525f01321bf1db1edc1e40a48f11df39ba2222e6bb943e05b16e7075f03efdb10cb6fbc13a30e1722db027ff00a9cdd27c1ac66f0576bc63de07b9fa29d9ad08cfb086e459b7ca55eef9acb05e29401f33662d0125b5fcd863cdc55a81a5e85a09ec6e756bd39d2c614e1a16ee9c32dd05da7676f8b4238efe44bf18a5ceb27fd531c2092d5d98635fe2344335b599dd15e38f8b7396a5a05cf397441d6c3b4c10a27cfdf2e515d7ad008cf5f1c19f252dfd84cb679cfa152873ae0a26acca2998ae07ef90010fad5bcd3acde75569489948c61788987d38d0f36b104446e99981cb1d5001d3f47eb529d7a491553a4578a4a25772d9ad022628d01354748a35561f4fa5e0c83f9d8b52b08b22d0f98464d51d36eb05b19c02b438bcae61f7a5f41649a239a5854107c7887fdcf6ac38d7fab0f11be516516ced69eac8e5d55a06c985de385b9be54b1d4cbeb5970e7397e87ba04ff9a0a3a3717295c047eeb39f7493eea8b209387bff781201ad3e2aff50cc8d9bdd9052551b7f05c3301dada120c3f18c56a51f1cb8eab3b1fe9a1b5a99efb118554c88052101e1b207c499bfca5f70655de070f5bdad544b70f96bceae747000d37da4e5c90eab17954a952d0c2a77accc06dbb0e52d9c09c1a520fbb4457b88dbb620b3c5a810882653d5d72ea41f8899ba79e2412b80edbddc2a2d6353c113b5ff3abbc2e6423503a05df5c482134f8d8ba014d31b1b1bc941a688dfe84e2a1749f1e026262052dacc9e157941767420f43694fac7c62b51ee989e8613d093f26a694608423a9082806dda650f20be69006a5192af78b2ee2bcdd698daac96f6baad82d048a78e14f7d62d6c5e4f26da5a3fa9610beb1a04fc6dce4d19e2722e630d9f9a3736448c83bc1c7c2772726bea2951c330fec2d6413cf3dee74779c6232ceda90e1ed2a9402bc157e33171c6019355a9d537e700da3501b74f4a65a39d916ba64f13faa50c25104fa5c365724eb81c5dc80a35ee584728a62d95cf29672af7a6a9f3d683508b48a793f30d754fce112803fe4a4f02187d5e9297546a33b03971761d9cc2894dcb047e913d01b4443c18ed4dd53add21408f27ba817453014e6e2d171a8cf3e963857b26c9b9b743d5502cd0982cdd213f8a5448124d7b66096e0967b6a2e969bbba0ba3c41ac97f003cc66145c1ff688ca0b071cd8e5e23d076be626e28c41f2cb44f55f0836f47f9f676e5301951250016d90b72368097fa13cffedf8ed3d93ada153fa02bae3870cc1433f837b15d193d4f2ee1b35b33dd1996f810f63eab1e4e3a8f86391c713aef7783838b36854574862bbcbc5b533919a4ef0f842cf6165b61625249069e5ed891c388dd32ab5485272fc7a7615672572f339b7424bd2faa58de42914ac75ee8ca755cbec16fae866c7ad3084180e2ecd48f4b9b775ebb08564081f50cec22397ae70b41c17fd4e97e8a6a57baadbc9387aa9f3988b346f8589efbf904df5b3c5ffee0ea7bae0ce0ceb65b07233497efc7043d8a384eaec4f107ea03c370b0658618ff36ce2e2cf80dfc60992d171baeb3f9734815d6c47aa0db59c5a0adcedb04ee983b6bd776b2bc2719c0b73efb1f7482fb34dc2abe04e7a94570c48dc3d17c079f68130e1ed8f99eeb6ef58a222dc8cd7c5f37364555e73040277ae87774ba716d77a0a3c45e8181890984a77e403e9e71a3d474e5f704509d0f1794e18961587faf33b98f6bca72dc3b71d2cfe30c7303b5dcc5b6e32240434b6151aae76b9322928c914543d64898d902e8327580c136a570b4eaf975820e5bebd697e6e2c19c1923cfcd324673c5ce2262f4d208b772ce13faf0cb3f27f2a3a3f476643a04497248e71ebb7d635cc695fafbe43d6f474c704039eedfa3a3793d4bcf3f7e2b59ecc00e83a0587a8c7c9954facee51cfea2fe20392217062bb60e5fa05b09f6671972c6bbf2dfcac5f6dbec79243cc6a50636be0292a176898206779aa3dc390a7b300b0871a4f37dab01f3d46be8465c29b788810e1ccf00a85088a6e1372b338fdcfe3c5b75ebbc22d371696924f53cd45c1db426633bb813533b48e1cf6d054c2b75bd25de5bfab79ffc7fc104d6c3b384f14a6dae9037b968e6d59e91cd8dc45f6b4ab25e7b6e4d759ac5de9649627eaa33077b42d0d624030e91599b982ffb6905287f3b2b19978d708240aa20e903e16eb4c0f632b33e874ec5b031dcddb10f218b9299fbbe736ea88a1f7e95effcde33342cb78b2b92e66b5d51c761ce9e17e958e88cbbb12464a64e86ea1c027eec9950ec83d7fcfa0b9e148471c24f08ab93855e0ac8242409c31a562dc7c1dbf3e1c11158a94bda5b811401f1e547ff84c765ba42ca96a376fb89ffc4d9bdd1d46277565e2c4f8c23868328765d0f69deb480bbd466d30d32963bdd4868532916a5fc5f2b4fe72cd0263d11e6f84cae55b1277685fdc7560ad88f77739e513770ecc35e881ad7486a907493939d1ed1298d872575c64e3d89995bab18dae759c7a6d5d1e3f525320bee06f8a5c37ef8bc70c9d6de06a7dc8f27d4fa66c4aba30adb9b5ab3ef250e3253f5dd5009ca8b1479f106dd7d95319cbc4685dc01305240cc56db953066f9c7b0fe278edcdba5d7d4993b1e45b045b773e99952c5cf525cac2e1ff8d4b4bf55753fafeb6240ce96496f33d80b4997403d76a61f829637a90dc37abe7b324728eae19af6fc2a8179b0f6b351cd837512775dc8891d8c6a0b873de5ec6d89c3162854798e6cfac8b23963a48d4fb8d63afdae29855df3567bc86c9e84e3cec05bc9866e776c30bae5e94c17459e82a663b468b91ab4c3819ccfd4016b9f67bd7b5c899f60e2acaa993f95205447a612e5ccdec76b0a8001dd8424a0a9e3db69d28279ca57ea402d51cccaf03e8a62d175bcfbbc51aaca087b081281790c6c105257e71f71185e7f0ab5afebf8548d291889ba5b49aa1a4f9dc6e3c55d80cd7f5b44c43dc9181331c5c5a3dd29fa31edfe5669b221cd508aeb26e5880bcab17a26a3bfb608ea4266d5311d90d7fdb4144d7bfb52eceae2156689a62b339a7778813d19f4aa0586cdb9376f96654084e780428</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">用魔法咒语解开它吧。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>NOI2021 省队集训</title>
    <url>/2021/07/05/NOI2021-%E7%9C%81%E9%98%9F%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。">
  <script id="hbeData" type="hbeData" data-hmacdigest="a104e36575d93bec878ca20dd0bf35c8cba900a56cd11e1b2b746e27244fda1a">db04d9dc6c0c619199a2f58108234d072613b9bc0a628b648b16f01892ca8f4b8466404f9816073f6e5ef16b0e2de7665a54d6ae8fbe02aa93cf4fc66046c8dce620d6226c4c148c2b85af10aa1dd6049fcda63e421b75bacd10c95d5b6bb849dd588a50787c8b764dea13c888f50ad5102f0be08c78b53a8fec14dccef51bdbd688cddb000f73c00a6ae613dc1fd0441fae2f5ba074566f2a17fb1e89d01a1ef6210993a9d8c52d60f1d3ac50b11864a2b67358136101a0ecce2f1a445fc1eca364fa2ec7459c518e0749e56eee23c8bb10b249863fca0625ae6f0e16c4d8eb367ec477c30371480f834b6a7873df383717ea7a735b96b7aed6da3e8027f196ae69f46663662e65c94ff47067466322543dd558a22fe37288324328535dc2891814e72c26fe981ae66cbcb65fb22216fc9d0e56a5dfc080c3ee96a43a2dc8f7864e25ddebb67530d95989a7f6b0694cdbccfed9c8f4d662d904e3e8822330cb875183c0e815ec5ea22d9d22cc7151ac5144e0abb5d0cef09ef6a357300ac20a0a00b72553e2fad60113321eafd6d708ed81c70448eebd5d7cc31d43edea7619e48f2b28f4ace5fda66534852ca2e05d06b267cf2e7d4e5a422f6828387e786f0b9dca1084639c47111957200db00c78a20b2038dc544c7019ca9c379544063376042ad5f031035f4305499e22a3249c2fe84d85a41c7bd50797d327834c1c109d1e4c175a99f1edfc38cf1950eaf9f0a79a206f96788b56747ae6939a0cce56b52b12d254ab9db144db4c5863d54dcb8faa137b6a765377c9ae4e1e88ff4895d4b85b510f9784fcd40d8f43a51eb1305252a022231603fa1f2a597c723235cadb8cde1b5ec8e4be80f07d84930a59c306137a42715682aec4ba05da4dd14142889c76920ef0ad1dc1170038f831a3a927cad00dda2e98654543b2f99a90ed7968bc173e6b89f54535ffe82079aa732acfbdad68532df3e370fe37004dd9cda05c8e4c59c14e5755b5820b1f414259ce3b74dee8f2954eccc429d6c72899ffaa70f4f0d7fa2ef4b8e866802783ed0898d30e04b9638c3e2b0f9d64c0943c73976bb4cf46a26cb83925bed254e8e8e1a798ba02a61f3e3b248fedf8d45320dbbd4fdd3518fa273f22e67e403d7c67aa1efc6bc0145fcb2f7154cc0e193bd03a2f160bf68832ef7ae9f7426f10fb77d1e25551368b0c6f673c31d1ca44595d46faba4fed633da16acfd429d3a1c77ce81afa9a8848c1eab4695f2e13590009d955357105a19dcb8bc16145444f9cadd74d9e16045c7bdc8c0d6df26e23422b33c7987b8b63d3972d42899b05a2a0b45939b88f48c0f7973011806cbdd89c5d5ec2d3f62cb29e56cfff7380f11852223dd6482b033e5fd6dd1414ebda4b082d6c8432d049c91080525708534c13c5dd7914342dc415b09c0d96fea72d8a1d0095b9efc8c575b09d919ad4926e14e35d0693e5a29ab46b03cbb0d11c9a26408ae931210bc40790408cf4e9281d3f11c1905503733b301f8ef581b770fd3476b18c1fb85ff41560b52e940cb87f5489e4749f3e1646631c4e74eed791dde4b5b2823f095910d1277b1647a87e4643e034aaca8cf86e550d165e4a8062a617a53352d69b040f0cb3757869cf65dc3d5644513c37d4aa978ffe5c4857c856fb347a341e041857db388682268e16ed897453ab19d630acc14ba5705671e3e8d93f11a684700b96d89bedbfe488a8c7a6df776cd7dece198392996861d3c17166462f28723a2df50416def5fba794ada3784d7c9cc73014cd568a98187b1611d6bb82f1308d04957388c3981a1fc4886e06f87ec96e6e26d82dd837672b10138deb37457940b409c7fc16b19e627684818b2d358403be7c19bc5f0a0f2a653fe281d1fecb4448d37390e95bdc5d0f2071f7a2f3307fc38462946d578873270563e3be44eb8495f173a27d9f5b764729764ba5f04f4a5ce99dc3083cb3d2c9695485dab87c70e3a9a8cce9d7d68ffc837cc9123e4348f9c222b7ac55015cc21716bea8f2bbab9643c39587dde1466b4064208bb2b530b040d75d285323e87c0b7cfd3d5d9644b6c51b078fb667462b90deb1b63b915138cd8ec03e6fec851906581a7a7a0fc34e77390ce66119b7a591374fb8efb96a50685ca7c9403ed30d346ac099019b8a28b46ead530e8c2d20520c5d75c1e3a83bd8804a22ef9997949fc91b1bf6f9c479cff2c7671c344ff151533ae11b393b664de828efcc1d25e65ed7bda2827203f25e9d9b70c2a21c94fab4e2d1673894b49b56e5f89941a30839d7aa692200e79ee5558f928145cd6e7155b0a9e7d943542268f47b8878e0df0f81c1dbafbf33ee86921928ebec25d7c895cc1f0607b9223e1db3b20bcbe5ea9914ed6abc0b0bf525b319844f8e648e28c879c09f59055dfd72295a558e25ca596914e8c07cf44d26be3e2e6d66a92ff367c1d0f44b7f1e825678cdd5354bed123efcdb4c86abf7c1ebe1b46226564caf0ce6f35b8596610ebd7256d439851f66af5fbff65fa3f2defd5e0f427beabc427c5336a21efb2e81cb31bb7ed251726a8d579a7db9111775cf129f16bdf79b20d51c085ede429ce9682d8261fac31dfdec102742d9b3a1bafb603d0b72ff4ff4c18b9601551b2e8abf21537b906e1396e5f95723ec6b84026e6f366ab2f90cb21e6f8581f5533f08eed19c26b7c2beb1847512a5d5445e6bb59ac19e71f955a9a5ad5be84d0586944f0b34421c12d3db82e7edde676aeceacad49452a12fd051b658aa4700da2f936b62eba20d487fc1e0d7ba334ad4f317402ca2134ef016cda4848c9123d04134421de2920c91d825dd11567a92cc1bd6ece5fde0a8eec37656e759be48f42bbcb011619d5b4de3ac9aad44b42f4c3e287c68d3327ce21c2c48e21fed7c23498b34545f1ab9be814f5cb34c35ffc9b79b38ccaff5b5965a82cab8a2dfca8b417bab0207a469a93484e0b87f6045c89fdde07e1aba1c2214917d6966a00ca6adff9e933939a1037885a8a90382508eed731404dba274321c4dbf689296c1a5f2d342c3fc90834473f1e63265f92a4bb2a98c3c75085d8434ff81e24291270e77647a6b95af63e9571bc0ba64ed4840265da8958579a5ea4255be56786ff4d21e3be209a0fec777516d40c0bbd355059cb9ee114572c56270fdc803e30b853e4150463af97c0baff28ac90e27eec7dfdb59d1738ad97ee0d1c430622fd5912414d901c3cff04c56acbca8892453ce6eb84a61ecf98369a23e112bdbc4084fbecce344719a7f05705690ad71d6805d8b6bb04eeb4b18a452de78d52d5286da2a64f14765a75006e8cd3b4e1514506d5490d35398149b4495f38d569fab4eb77ea0c044efd66e72f867906b5f2a07aa2271307099b95dd30293234e609e3b15e6d69f3c2f7f112a7d21aa514030a73bb5c0fc99b46ea732428c8aab68eb8ae4613cfda7fcdefb776cac8f288dda8aa9b10fa35f57898840f93800409ced84ed2e8d6749604702c3f3874c93c738efe84c2a3a4c8c37adac3288f5b537b80ead2bec7bf58931b1b5b7c8c5f8fd3cce11a7ea59f00fa7bc446c8ffbda4dd7d241400ed048ce1000cb445859c86d8e6c54bdae8ad4927d1b9eff156c0685c7987ca5abaff45a552d672955a5448e7cf094677a726da81754477376f13132c70c6b58618ab5a0b52bdacb75cbca5df0eb91563c25a830ddb422ccc80a54ac561091de2c40db5e0ecec53761d0b8d184bc02db3e9c1055d8a502e5da97ea1f61390b4d57006f9fc728f8dee5eac56b5fa274a3113017e1ada0df33749f95f8441e6c88d4d1186c3cd8c3e3499c94ed4ea73c655845b4707cb75edceea6f144cc8ed3e84e5c2ce27a47ac418a4566b20cf20729f123db618134a5d8c77d3d59f572b0c00130ab9a35b96fb893b29bbddb2f6192c1aae999ab4208d4bdee79818b0f57adcc1fba4d9b7f76d14d66a149dbaadd7dc8b0fc12dbd66711f53f73c130689d471c9ee9a51496df3b963704fc699e6a22226bb703f3d53c814103bd678b36658f5b4ed057c371f2aaaf88b0d5fc99876fd168c9b3de46b7484e85fa25559613eabaefa0e726491e7b6c79b93fc5e7b0e8e6cc65d5aacff9a9040a4da47c46fe1af131106123be0f8a804be6552c4b76c02bc4894bcdd53d957703c11361f5106402fb8659d63bf9941696800ea4270c7298fa7aac79b2ecfb4a83a012b670508ebab8c3de00647fa6111166cf2e2f30b7bc5e8fd50650c919cb1f1ba229644069ae0ba2275d5b51474175769c789010d83a94f992cbbd9532c7186c8a9e1f14a756ceada8873ac58d0d6db8628f20628fdabc245eb6be2561d0847c00ae4a01174fab9be4649942bf26336088ca1f008b8c84c55c779c90012f913f00c1eaf8a50e9b4a3e6f4d1cb01988a574d6b8336f639c0d217f4c5578b4e704cf51078b1ad75cbed349eb3b3a85055a818eab9e8c3e81664842142cc5ee4898a818082fb679bf1ccb72a17d203ad967249edd91</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">用魔法咒语解开它吧。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
