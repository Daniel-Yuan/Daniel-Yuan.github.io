<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF506E 题解</title>
    <url>/2020/09/17/CF506E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>一道极 (e) 妙 (xin) 的自动机优化 DP 的题目。</p>
<p>先假设最后得到的字符串为 <span class="math inline">\(T\)</span>，由题意易知 <span class="math inline">\(T\)</span> 合法当且仅当 <span class="math inline">\(T\)</span> 是回文串且 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T\)</span> 的一个子序列。</p>
<p><span class="math inline">\(T\)</span> 是回文串的这个性质我们可以通过从外向内一个一个填字符来实现，所以我们需要 DP 的是 <span class="math inline">\(S\)</span> 相对于 <span class="math inline">\(T\)</span> 而言被匹配了多少个字符。</p>
<p>特别的，因为当 <span class="math inline">\(T\)</span> 的长度为奇数的时候，最后一次填的字符本质上是一个字符，需要特别处理，所以下面我们先讨论 <span class="math inline">\(T\)</span> 的长度为偶数的情况。</p>
<a id="more"></a>
<p>因为 <span class="math inline">\(T\)</span> 这个字符串是从外向内确定的，所以 <span class="math inline">\(S\)</span> 的匹配也是从外向内的，故可以设 <span class="math inline">\(f_{i,l,r}\)</span> 表示考虑 <span class="math inline">\(T\)</span> 的前后 <span class="math inline">\(i\)</span> 个字符，当前 <span class="math inline">\(S\)</span> 还剩下 <span class="math inline">\([l,r]\)</span> 没有匹配到的方案数。</p>
<p>考虑转移，假设当前有 <span class="math inline">\(s[l] = s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r-1}\)</span>，如果当前填的字符不是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(25\)</span>。</p>
<p>假设当前 <span class="math inline">\(s[l] \not= s[r]\)</span>，那么如果当前填的字符是 <span class="math inline">\(s[l]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l+1,r}\)</span>，如果当前填的字符是 <span class="math inline">\(s[r]\)</span>，就可以转移到 <span class="math inline">\(f_{i+1,l,r-1}\)</span>，如果当前填的字符不是两者，就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(24\)</span>。</p>
<p>需要注意的是，对于所有的 <span class="math inline">\(f_{i,l,r}(l&gt;r)\)</span>，因为 <span class="math inline">\((l&gt;r)\)</span>，也就是说 <span class="math inline">\(S\)</span> 已经被匹配完，所以无论填什么字符都没关系，那么它们就可以转移到 <span class="math inline">\(f_{i+1,l,r}\)</span>，转移系数为 <span class="math inline">\(26\)</span>。</p>
<p>这样我们便有了一个 <span class="math inline">\(n\times |S|^2\)</span> 的 DP，如果把后面的状态强行剥离就可以做到 <span class="math inline">\(|S|^6\log n\)</span>，似乎并没有什么用。</p>
<p>考虑优化这个 DP，我们把这个 DP 的转移用一张图来表示，对于 <span class="math inline">\(S=abab\)</span>，转移图是这样的：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/17/wftvp6.png" alt="wftvp6.png" /><figcaption>wftvp6.png</figcaption>
</figure>
<p>其中下划线是已经匹配的部分，在 <span class="math inline">\(i\)</span> 行 <span class="math inline">\(j\)</span> 列的椭圆表示 <span class="math inline">\(f_{x,i,j}\)</span>，我们把所有的 <span class="math inline">\(l&gt;r\)</span> 的状态归到一个状态里面去，就有了如上的转移图。一个合法的方案本质上就是从 <span class="math inline">\(abab\)</span> 走 <span class="math inline">\(n+|S|\)</span> 步到 ____​ 的一条路径。</p>
<p>我们把某条路径上面的所有节点拿出来，并且按照 <span class="math inline">\(s[l]\)</span> 是否等于 <span class="math inline">\(s[r]\)</span> 分类成两种点，可以发现，无论这两种点的排列如何，当这两种点的数量确定的时候，答案已经确定了。</p>
<p>设 <span class="math inline">\(s[l]=s[r]\)</span> 的点为 <span class="math inline">\(0\)</span> 类点，<span class="math inline">\(s[l]\not=s[r]\)</span> 的点为 <span class="math inline">\(1\)</span> 类点，不难发现在某条路径上确定了 <span class="math inline">\(1\)</span> 类点的数目后，可以直接计算得到一个唯一的 <span class="math inline">\(0\)</span> 类点的数目，而 <span class="math inline">\(1\)</span> 类点的数目的取值范围为 <span class="math inline">\([0,len-1]\)</span>，所以总共不同的路径数最多只有 <span class="math inline">\(|S|\)</span> 条。</p>
<p>考虑有多少种方案经过某条路径，设 <span class="math inline">\(g_{x,l,r}\)</span> 表示在区间 <span class="math inline">\([l,r]\)</span> 的这段转移中，总共经过 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(1\)</span> 类点的方案数，用记忆化搜索即可求得，我们需要的就是 <span class="math inline">\(g_{x,1,|S|}\)</span>。这部分复杂度 <span class="math inline">\(|S|^3\)</span>。</p>
<p>在一条路径上面 DP 的复杂度是 <span class="math inline">\(|S|\times n\)</span>，通过矩阵优化可以优化到 <span class="math inline">\(|S|^3\times \log n\)</span>，总复杂度即 <span class="math inline">\(|S|^4\log n\)</span>，虽然仍然过不了，但是优化了很多。</p>
<p>我们设起点为 <span class="math inline">\(S\)</span>， <span class="math inline">\(0\)</span> 类点为黑色，<span class="math inline">\(1\)</span> 类点为白色，终点为 <span class="math inline">\(T\)</span>，上述过程中的转移图差不多是这样：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/18/w4aqtH.png" alt="w4aqtH.png" /><figcaption>w4aqtH.png</figcaption>
</figure>
<p>考虑继续优化，上述算法问题就出在我们对每种路径都跑了一次 DP，考虑把它们合并成一次。先规定所有的路径<span class="math inline">\(0\)</span> 类点都在前面，<span class="math inline">\(1\)</span> 类点都在后面。然后在新的转移图上把第一行放上 <span class="math inline">\(0\)</span> 类点，第二行放上 <span class="math inline">\(1\)</span> 类点，在第一行的点之间连边，第二行的点之间连边，现在就考虑怎么在第一行的点和第二行的点之间连边，不难发现，这种连边实质上代表了一种路径，因为这种边只能走一次，且走这种边就可以确定经过的 <span class="math inline">\(0\)</span> 类点和 <span class="math inline">\(1\)</span> 类点的数目，这样的话复杂度就优化到了 <span class="math inline">\(|S|^3\log n\)</span>。</p>
<p>把上图按照这种优化连边之后的图就是这样：</p>
<figure>
<img src="https://s1.ax1x.com/2020/09/18/w4d83R.png" alt="w4d83R.png" /><figcaption>w4d83R.png</figcaption>
</figure>
<p>其中从第一行的点到第二行的点的转移系数为有多少种方案经过这种路径，即 <span class="math inline">\(g_{x,l,r}\)</span>。可以发现这样转化之后只有 <span class="math inline">\(\frac{3}{2}|S|\)</span> 个点，且因为转移图是 DAG 图，所以可以通过编号使得转移都是从编号小的点转移到编号大的点，这样可以得到一个比较优秀的常数优化。复杂度 <span class="math inline">\(|S|^3\log n\)</span>。</p>
<p>最后还需要考虑一下 <span class="math inline">\(|T|\)</span> 为奇数。我们先把 <span class="math inline">\(|T|\)</span> 的长度看做 <span class="math inline">\(|T|+1\)</span> ，这样就可以得到一个答案。考虑有多少种方案不合法，可以发现是所有最后一步是放两个字符，且恰好在最后一次转移的时候放的方案，我们把这种方案算出来减掉即可。具体的，把所有最后一步是放两个字符的路径拿出来，然后去掉终点的自环再跑一遍上述 DP，这次求出来的答案就是要减掉的方案。</p>
<p>至此便可完美解决此题。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = i; j &lt;= lim; ++j) &#123;</span><br><span class="line">        re.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = i; k &lt;= j; ++k)</span><br><span class="line">          re.a[i][j] = (re.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; F;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Matpow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Matrix re;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; j &lt;= lim; ++j)</span><br><span class="line">      re.a[i][j] = (i == j);</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[x][l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">  <span class="keyword">if</span> (s[l] == s[r])</span><br><span class="line">    f[x][l][r] = DP(x, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f[x][l][r] = (DP(x - <span class="number">1</span>, l + <span class="number">1</span>, r) + DP(x - <span class="number">1</span>, l, r - <span class="number">1</span>)) % mod;</span><br><span class="line">  <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">int</span> n, len;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; n;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  lim = len + (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">    F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  F.a[lim][lim] = <span class="number">26</span>;</span><br><span class="line">  F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">    ans = F.a[<span class="number">1</span>][lim];</span><br><span class="line">  ans = (ans + F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod) % mod;</span><br><span class="line">  <span class="keyword">if</span> ((n + len) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(F.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(F.a));</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!((len - i) &amp; <span class="number">1</span>))</span><br><span class="line">        F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">      ans = (ans - F.a[<span class="number">1</span>][lim] + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!(len &amp; <span class="number">1</span>))</span><br><span class="line">      ans = (ans - F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2019 游记</title>
    <url>/2019/11/16/CSP-S%202019%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离十一月十六日只不足几天，CSP 的审判快要降临了罢，我正有写一点东西的必要了。（雾</p>
<a id="more"></a>
<h2 id="day--1">Day -1</h2>
<p>教练组织高二的学长出去玩去了，苦逼的我还要接着考 CSP 信(zi)心(bi)赛。/羡慕</p>
<p>配 <code>emacs</code> 的时候突然忘记 <code>default</code> 怎么写了，一直认为最后两个字母是 <code>te</code> 。最后还是靠着 <code>switch</code> 的高亮打出来的（CSP 前犯这种错误我怕不是要爆零）</p>
<p>晚上 U 盘坏了，捣鼓了一晚上。</p>
<p>考前 RP 突然爆炸，感觉吃枣药丸（怕不是 CSP-S RP++ 爆负了……）</p>
<h2 id="day-0">Day 0</h2>
<p>上午写了一个线性基板子，一个矩阵快速幂板子，一个 <code>Miller-Rabin</code> 板子。</p>
<p>之后就欢快地颓了一下午加一晚上。<del>（某乎：如何看待某巨佬 AK CSP-S）</del></p>
<h2 id="day-1">Day 1</h2>
<p>在一阵互相膜拜之后进入了考场。</p>
<p>座位之间有隔板 <del>考试前还在讨论如何用毒瘤码风祸害周围同学</del>，键盘敲起来特别舒服，值得一提的是，<code>Emacs</code> 有配置文件！<del>好评</del>。</p>
<p>开考后 10 分钟就把 T1 切了。</p>
<p>T2 像极了考前的一道 <del>九条可怜</del> 的括号匹配题，几分钟码了个 <code>Trie</code> 树就过样例了，然而那个题<strong>忽略括号方向</strong> <del>我给忘了QAQ</del>。</p>
<p>然后 T3 看上去很玄学的样子，开始手玩，结果手玩不动样例……<del>还不如暴搜</del></p>
<p>闲的没事就给 T2 写了个对拍，一组就错……</p>
<p>发现了那个小错误后重新思考做法，发现还是可以用栈的思想，在每次加入或删除一个节点的时候计算贡献，过了样例后接着拍，还是炸了，不过 <del>它已经被我优化到拍几百组错一组了</del>。</p>
<p>接着调，发现是个小错误，调完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几千组错一组了</del>。</p>
<p>接着调，又发现个小错误，跳完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几万组错一组了</del>。</p>
<p>当我百思不得其解时，已经 10:50了 QAQ。</p>
<p>当我气的去打完 T3 搜索并且想了一下特殊数据后，已经 11:20 了。</p>
<p>当我感慨造化弄人，以为要命绝于此，要被这次 <code>CSP</code> 送退役时，发现：<strong>我 ** <code>vector</code> 访问了非法内存 ？？？</strong> 。</p>
<p>改完之后拍几万组都没有问题，不过这次考试也因为 T2 止步 210 了……</p>
<p>又欢乐地颓了一下午加一晚上。</p>
<h2 id="day-2">Day 2</h2>
<p>昨天颓太欢乐了，今早莫名的困……</p>
<p>感觉今天心态都不一样了……昨天想着怎么拿高分怎么 AK，今天就只想着多拿点分 <del>（还是不能给我这种蒟蒻太高的期望）</del></p>
<p>开场就写了一个 T1 的 <span class="math inline">\(n^2m\)</span> 的做法，后来发现它假了，只能补上一维保证正确性，最后打了个 <span class="math inline">\(n^3m\)</span> 的 <code>DP</code>。</p>
<p>然后写 T2，一开始写了一个 <span class="math inline">\(n^3\)</span> 的<code>DP</code>，并且理性分析发现可以优化到 <span class="math inline">\(n^2\)</span> 。经过人(bao)类(li)智(da)慧(biao)后，发现每个以每个点为终点的 <code>DP</code> 值有且仅有一个有用，于是可以使用单调队列优化做到 <span class="math inline">\(O(n)\)</span> ，<del>但是为啥我压 8 位高精都可以MLE，只能过 type=0</del></p>
<p>最后写 T3，发现暴力分出奇地高，于是写完暴搜后就找特殊数据的规律，<del>还真被我找到了</del>，又骗了一大波分。</p>
<p>一道题都没切预计都比昨天高……<del>我 ** 昨天在干嘛</del>。</p>
<h2 id="后记">后记：</h2>
<p>210 + 247 = 457……没能完成教练定的500分目标<del>AFO AFO</del>……</p>
<p>趁还没有退役先把游记码了……<del>AFO了就没机会了</del></p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1 2020 游记</title>
    <url>/2020/10/11/CSP-S1-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="day-1">Day 1</h4>
<a id="more"></a>
<p>今天的状态就一个字：困。</p>
<p>平时周末这么早还沉醉在<del>温柔乡</del>梦乡的我，坐着校车晃晃悠悠地去了考场。</p>
<p>天空很蓝，阳光很暖，和兄弟们看着来往的<del>妹子</del>人群，感觉生活无比惬意。</p>
<p>在见到如此多的小学生、初中生后，感觉自己真的老了<del>教练真就不当人</del>。</p>
<p>一坐下就想睡觉，越考越想睡，rush 到第三个阅读的时候就感觉整个人都要没了，天人交战了好一会之后才又重新开始从后往前 rush，最后好不容易 rush 完了，结果却睡不着了。<del>（强烈抗议 CSP-S1 耽误我睡觉）</del></p>
<p>中午众人决定去吃大餐，在兜兜转转之下，选择了某 M 开头的快餐店。</p>
<p>虽然状态不太好，但是这波还是很稳的，祝愿 CSP-S2 2020 RP++。</p>
<h4 id="day-inf">Day INF</h4>
<p>成绩出来了，比预计的高一点点 96pts（开心）。</p>
<p>但是……听说同校的聚聚不仅 AK 初赛，而且月考年级第二（说不定还是位人赢），突然就感觉生活失去希望。</p>
<p>不过还是祝愿 CSP-S2 2020 RP++。</p>
<p><del>为了不引起日期恐慌，博主决定把游记分开写</del>。</p>
<p><a href="">CPS-S2 2020 游记</a></p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2 2020 游记</title>
    <url>/2020/11/08/CSP-S2-2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="day--1">Day -1</h4>
<a id="more"></a>
<p>考了一场很秀的模拟赛。</p>
<p>开局看题，发现 T1,T2,T4 都是一眼题，代码难度 T1&lt;T4&lt;T2。于是 rush 完 T1 之后直接肝 T3。</p>
<p>肝了 1.5h 没肝出来，决定先稳一波 rush 一手 T4，rush 完写对拍的时候监考老师绕到了我的后面。</p>
<p>“这是第四题吗？”</p>
<p>“嗯。”</p>
<p>“这是什么？对拍吗？”</p>
<p>“嗯。”</p>
<p>“那你是不是都做完了？”</p>
<p>“没有，只写了 T1,T4。”</p>
<p>"哦~"</p>
<p>似乎这只是一个平平无奇的对话，但不久后监考老师冷不丁来一句：“其实这套题目并不完全是按照难度排序，T3 应该要比 T2 简单。”</p>
<p>一只南美洲亚马逊河流域热带雨林中的蝴蝶，偶尔扇动几下翅膀，可以在两周以后引起美国得克萨斯州的一场龙卷风。监考老师的一句提醒，也可以引起很多人做题策略的改变。</p>
<p>我听完之后虽然有点小慌，但是之前就已经止损过了，所以还是稳着先把 T2 写了，最后才去肝 T3。</p>
<p>但是很多人都因为这一句话，直接硬肝 T3，结果全盘皆崩。</p>
<p>我们称这个事件为【Y 郎妙计安天下】。</p>
<h4 id="day-0">Day 0</h4>
<p>又是一场披着 CSP 皮的毒瘤模拟赛。</p>
<p>真想拿个仙人掌拍出题人头上让他见识一下什么才是真正的仙人掌。</p>
<p>不过有一说一，感觉现在码力变强了好多，一开始误认为仙人掌是点不重复，rush 了 4k 多，发现错了之后又重新 ruch 了 4k 多结果还一遍过……</p>
<p>考前毒奶：因为 CSP 毕竟是合格性考试，所以不会太难，T1,T2 应该都是送分，T3,T4 略难一点。</p>
<h4 id="day-1">Day 1</h4>
<p>为了考前不颓废，VP 了一场 CF Div.1。</p>
<p>Rush 完 A,B 后，发现 C 是一个计算几何，D 是一个比较麻烦的 DP，瞬间失去了写代码的欲望。</p>
<p>结果剩下的时间差不多都在知乎、2020 US Election、Typeracer、Pokemonshowdown 之间徘徊。<del>考前颓废是 OIER 的传统艺能。</del></p>
<p>吃完中饭就去考场了。因为自己动作比较憨，上车的时候就只有后排中间的 C 位了，于是就有了名场面【Dan 皇登基】（雾</p>
<p>考前集体毒奶：早出来一小时就可以多休息一小时，今天下午直接车队走起。</p>
<p>考试体验依旧很 nice，座位很舒适，键盘很丝滑，配置很体贴。</p>
<p>但是……题目很毒瘤。</p>
<p>浏览一遍题目之后直接想自闭离场了。</p>
<p>打个比方，切题就类似于在山里找宝藏，有些宝藏是藏得很深，需要你依靠自己的能力找到宝藏的位置<del>（宝藏猎人）</del>。而有些宝藏就直接给扔山顶，一眼就看得到，不过如果想得到它就需要花大功夫。</p>
<p>T1 就是后者，而且山顶还不是普通山的山顶，那是珠穆朗玛峰的山顶。</p>
<p>硬着头皮肝 T1，40min，一遍过。</p>
<p>硬着头皮肝 T2，20min，一遍过。</p>
<p>T3 一开始一点思路都没有，结果就直接想睡觉了……<del>（强烈抗议 CSP-S2 又耽误我睡觉）</del>。</p>
<p>迷迷糊糊了 30min，状态回暖之后直接把 T4 70 分暴力 rush 了，然后继续肝 T3。</p>
<p>离下考还有 50min 了时候隐隐约约有了一个算法，然后直接 rush，30 min 写完一遍过样例。</p>
<p>剩下的时间感觉 T4 优化无望，于是就各种检查。</p>
<p>预计 100+100+100+70=370，似乎不低的样子。</p>
<p>考完之后就是颓颓颓！！！</p>
<h4 id="day-2">Day 2</h4>
<p>CSP 已经没有 Day 2 了……又要继续为 NOIP 奋斗了。</p>
<p>测了一下民间数据，T1,T2,T4 100+100+70 稳了，但是 T3 有点点问题。</p>
<p>后来发现我本质上要维护的是后缀积，但是我的做法是维护整体积除前缀积，然而数据范围是 <span class="math inline">\(0\leq V_j\leq 10^4\)</span>……</p>
<p>现在我的成绩完全掌握在 T3 出题人的手中了……希望 TA 能大发慈悲，可怜可怜没注意 <span class="math inline">\(V_j=0\)</span> 的孩子吧。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Daniel_yuan&#39;s New Blog</title>
    <url>/2020/09/15/Daniel-yuan-s-New-Blog/</url>
    <content><![CDATA[<p>这是 Daniel_yuan 的新博客。</p>
]]></content>
  </entry>
  <entry>
    <title>PAM 学习笔记</title>
    <url>/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="定义">定义</h4>
<p>PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。</p>
<p>PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。</p>
<a id="more"></a>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th>AC 自动机</th>
<th>PAM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">点         </td>
<td>一个前缀</td>
<td>一个回文串</td>
</tr>
<tr class="even">
<td style="text-align: left;">转移边</td>
<td>从起点走到终点，相当于在起点的字符串后面加上一个字符</td>
<td>从起点走到终点，相当于在起点的字符串两侧都加上一个字符</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fail 边</td>
<td>存在的最长后缀</td>
<td>存在的最长回文后缀</td>
</tr>
</tbody>
</table>
<p>但是，PAM 有一个 AC 自动机不具有的性质——它有两个根！因为可以发现走转移边并不会改变回文串长度的奇偶性，这样的话就保存不了所有的回文串了，所以我们需要两个根，一个叫做奇根，还有一个叫做偶根，这样才能维护所有的回文串。</p>
<h4 id="构造">构造</h4>
<p>定义完了那就看看怎么构造它。这里我们使用增量法。</p>
<p>为了方便，我们给每个点定义一个结构体，存当前点的信息，这里我们就维护三个信息：当前回文串的长度、转移边、fail 边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> son[<span class="number">26</span>], fail;</span><br><span class="line">&#125; t[MAXN];</span><br></pre></td></tr></table></figure>
<p>先看看怎么初始化，显然我们要先定义两个根。对于奇根，它的长度为 <code>-1</code> （可以把在它两侧加一个字符，当做它会吃掉一个字符），它一开始没有儿子，它的 fail 边随便指（因为它的两侧一定可以加字符）。对于偶根，它的长度为 <code>0</code> （可以看成是空串），它一开始没有儿子，它的 fail 边指向奇根，因为它两侧不能加字符的话，就只能丢给奇根了。即：（<code>0</code> 号节点是偶根，<code>1</code> 号节点是奇根）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">0</span>].len = <span class="number">0</span>; t[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">t[<span class="number">1</span>].fail = t[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>假设上一次加入的点是 <code>last</code> ，现在需要新增一个字符 <code>ch</code>，假设它存储在 <code>s[pos]</code>。</p>
<p>首先我们需要找到一个 <code>last</code> 所代表串的一个最长后缀，使得可以在这个后缀后面加上 <code>ch</code>，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfail</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s[pos] != s[pos - t[last].len - <span class="number">1</span>])</span><br><span class="line">    last = t[last].fail;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这个最长后缀所在的点记作 <code>cur</code>，然后接下来就看 <code>cur</code> 节点有没有 <code>ch</code> 这个儿子，如果有就直接跳过，把 <code>last</code> 设为这个儿子，否则就新增一个节点，记为 <code>nxt</code>。</p>
<p>对于 <code>nxt</code>，它的长度是 <code>cur</code> 的长度 <code>+2</code> （根据转移边的定义）。它的 fail 的寻找和 AC 自动机很像，是在 <code>cur</code> 的 <code>fail</code> 中再找到一个最长的有 <code>ch</code> 这个字符的儿子的后缀，然后把 <code>nxt</code> 的 fail 指向那个后缀的 <code>ch</code> 儿子。最后再把 <code>cur</code> 的 <code>ch</code> 儿子设为 <code>nxt</code>。具体实现如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nxt = ++cnt;</span><br><span class="line">t[nxt].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">t[nxt].fail = t[Getfail(t[cur].fail, pos)].son[s[pos] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">t[cur].son[s[pos] - <span class="string">&#x27;a&#x27;</span>] = nxt;</span><br></pre></td></tr></table></figure>
<p>最后也需要让 <code>last</code> 等于 <code>nxt</code> 。</p>
<p>这样就可以把 PAM 构造出来，复杂度是 <span class="math inline">\(O(n)\)</span> 的，因为每次跳 fail 会让当前串的长度至少减 <code>2</code>，而加入一个字符只会让当前串的长度加 <code>2</code>，所以跳 fail 的次数是有保障的。</p>
<h4 id="应用">应用</h4>
<p>PAM 可以处理很多有关回文串的信息，具体在此就不展开了。实际上我们可以把 AC 自动机或是 SAM 的那些套路拿到 PAM 上来用，具体的怎么做还是得要进行实践。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>POI2012</title>
    <url>/2020/10/17/POI2012/</url>
    <content><![CDATA[<p><del>吉老师是我们的红太阳，紧随吉老师的步伐。</del></p>
<a id="more"></a>
<h5 id="distance">Distance</h5>
<p>设 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(x\)</span> 的质因数个数（相同算多个）。</p>
<p>那么 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的操作数就是 <span class="math inline">\(f(\frac{xy}{\gcd(x,y)^2})\)</span>。</p>
<p>而不难发现上式等于 <span class="math inline">\(f(x)+f(y)-2f(\gcd(x,y))\)</span>。</p>
<p>所以对于要求答案的数 <span class="math inline">\(x\)</span>，枚举 <span class="math inline">\(\gcd\)</span> 后就只要看最小的 <span class="math inline">\(f(y)\)</span> 即可，而这个 <span class="math inline">\(y\)</span> 必须是枚举的 <span class="math inline">\(\gcd\)</span> 的倍数，预处理一下即可。</p>
<h5 id="cloakroom">Cloakroom</h5>
<p>考虑把询问离线，那么就可以把所有查询归为 <span class="math inline">\(n^2\)</span> 个组。</p>
<p>对于某个组，直接用 <code>bitset</code> 跑可行性背包。</p>
<p>复杂度 <span class="math inline">\(O(\frac{n^2k}{w})\)</span>，需要卡常。</p>
<h5 id="a-horrible-poem">A Horrible Poem</h5>
<p>把字符串按照块大小为 <span class="math inline">\(1,2...n\)</span> 分块，然后预处理每种分块每个块往前有多少个块和它一样。</p>
<p>对于一个查询，枚举长度的一个因子，然后查询整块是不是都相等，如果都相等就把散块拼接成一个整块再去判断这个拼接的整块和原来的整块是否相等。</p>
<p>画图就可以很显然的看出这个性质。</p>
<p>判断字符串相等直接用哈希。</p>
<p>需要卡常。</p>
<h5 id="fibonacci-representation">Fibonacci Representation</h5>
<p>先把这个数用斐波那契数拆分。</p>
<p>这么拆分有一个性质——没有相邻的 <span class="math inline">\(1\)</span>。</p>
<p>减去一个数可以看成是把原数加上一个数，所以现在就是在这个序列上面加减，求变成全 <span class="math inline">\(0\)</span> 的最小次数。需要注意的一个性质就是如果有两个相邻的 <span class="math inline">\(1\)</span> 会自动往后合并。</p>
<p>从前往后扫，碰到一个 <span class="math inline">\(1\)</span> 后，如果其后面第二位或者第三位有值，就在某个位置加上一个 <span class="math inline">\(1\)</span> 使得可以连锁反应把后面那个 <span class="math inline">\(1\)</span> 也弄掉，否则就直接删掉这个 <span class="math inline">\(1\)</span>。</p>
]]></content>
      <tags>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title>diary</title>
    <url>/2020/10/06/diary/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="你的魔法咒语太弱了。" data-whm="博主的魔法失效了。"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="用魔法咒语解开它吧。" /><label>用魔法咒语解开它吧。</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5489929edd011c760b878f4951bc1063b894e9da73884962b54414abc098b0df">d760a8545d0b399d6f7b4615394ac9fb</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ Contests</title>
    <url>/2020/10/14/UOJ-Contests/</url>
    <content><![CDATA[<p><del>九条可怜老师</del>吉老师在他的博客中大力赞扬 UR 。</p>
<p>于是博主就决定慢慢把 UR 补完。</p>
<p>希望补完之后能有吉老师十分之一的水平。</p>
<a id="more"></a>
<h4 id="uoj-easy-round-1">UOJ Easy Round #1</h4>
<h5 id="a">A</h5>
<p>最小是 <span class="math inline">\(2\sqrt{n}\)</span>，最大是 <span class="math inline">\(g+l\)</span>。</p>
<p>用三次根号分治分解 <span class="math inline">\(g,l\)</span>，剩下的要么相等，要么都是完全平方数。</p>
<h5 id="c">C</h5>
<p>离线，建操作树，用可撤销并查集求解。</p>
<p><code>Add</code> 是加一个儿子，<code>Delete</code> 是跳到 <span class="math inline">\(k\)</span> 级父亲，<code>Return</code> 是回到上一步所在位置。</p>
<p>求父亲类似长链剖分用个数组记录动指针。</p>
<h4 id="uoj-round-1">UOJ Round #1</h4>
<h5 id="a-1">A</h5>
<p>枚举缩进量 <span class="math inline">\(x\)</span>，当前代码量就是 <span class="math inline">\(\sum_{i=1}^n\lfloor\frac{a_i}{x}\rfloor a_i\text{ mod }x\)</span>。</p>
<p>显然的整数分块。</p>
<h5 id="b">B</h5>
<p>把 <span class="math inline">\(x\)</span> 模一个大于 <span class="math inline">\(x\)</span> 的数不会有任何改变。</p>
<p>故设 <span class="math inline">\(f[i]\)</span> 表示当前的值为 <span class="math inline">\(i\)</span>，所有大于 <span class="math inline">\(i\)</span> 的数都已经放好了的方案数，枚举转移即可。</p>
<h4 id="uoj-round-2">UOJ Round #2</h4>
<h5 id="a-2">A</h5>
<p>从左往右扫，遇到一个不合法的右括号，就往右找第一个左括号交换。</p>
<p>因为是右边的第一个左括号，所以如果下一次仍然有不合法的右括号，就可以从上次的那个位置开始继续往右找左括号。</p>
<h5 id="c-1">C</h5>
<p>先套上简单容斥，<span class="math inline">\(f[i]\)</span> 表示 <span class="math inline">\(\gcd\)</span> 是 <span class="math inline">\(i\)</span> 的倍数的方案数。</p>
<p>对树长链剖分，这样就只需要在链合并的时候计算对 <span class="math inline">\(f\)</span> 的贡献。</p>
<p>朴素的想法维护深度桶，合并枚举 <span class="math inline">\(i\)</span>，直接求当前链的 <span class="math inline">\(i\)</span> 的倍数个数和合并链的 <span class="math inline">\(i\)</span> 的倍数个数。这样复杂度是 <span class="math inline">\(\sum dep\)</span> 的，不太行。</p>
<p>故考虑根号分治，在加入当前点的时候就直接预处理深度模 <span class="math inline">\(1\sim B\)</span> 等于 <span class="math inline">\(x\)</span> 的数的个数，剩下的同上暴力。</p>
<p>复杂度比较玄学，<span class="math inline">\(B=50\)</span> 可过。</p>
<h4 id="uoj-round-3">UOJ Round #3</h4>
<h5 id="a-3">A</h5>
<p>不难发现次大公约数就是最大公约数除掉最小质因子。</p>
<p>而最大公约数一定是 <span class="math inline">\(a[1]\)</span> 的因子。</p>
<p>预处理出 <span class="math inline">\(a[1]\)</span> 的所有因子之后，对每个 <span class="math inline">\(\gcd\)</span> 判断即可。</p>
<h4 id="uoj-round-4">UOJ Round #4</h4>
<h5 id="a-4">A</h5>
<p>当 <span class="math inline">\(a\geq \sqrt{n}\)</span> 的时候，<span class="math inline">\(b\)</span> 已经没有用了，两人只能操作 <span class="math inline">\(a\)</span>，故可以直接 <span class="math inline">\(O(1)\)</span> 判。</p>
<p>剩下的部分可以直接 DP。</p>
<h5 id="b-1">B</h5>
<p>把当前剩下的 <span class="math inline">\(k\)</span> 平均分配给三个数组（如果某个越界了就匀出来一点给别的），然后分别查询，那么查询值最小的那个一定可以被放进去，否则把它退出来，加入别的，别的一定比它大，就不优。</p>
<p>所以可以直接这么搞若干次，每次可以确定 <span class="math inline">\(\frac{1}{3}k\)</span> 个数，当 <span class="math inline">\(k\)</span> 足够小的之后就直接暴力即可，可以在次数限制内求得答案。</p>
]]></content>
      <tags>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>做多项式题的一点小技巧</title>
    <url>/2020/09/26/%E5%81%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>有一类多项式题，十分考验选手的推式子能力，真正的代码部分仅仅只是几个模板拼凑在一起。这类题目如果出现，往往会造成比较大的分差，所以在此略微归纳一下这类题目的做法。大致如下：</p>
<a id="more"></a>
<p>两个主要思想：在解多项式方程的时候，把多项式当做数看，在允许的情况下，可以等式两边同时加减乘除一个多项式；部分题目的多项式可能是无穷项的，在这种情况下，可能会出现把原多项式经过一些操作之后得到自身。</p>
<p>两个主要套路：一个是先想出一个 DP 的做法，然后根据 DP 转移的特性，发现其卷积的性质并把卷积部分弄成多项式，之后直接卷积加速，或者通过解方程的方式求答案；另一个是直接设求解的东西为一个多项式，然后根据其性质使其可以从自己转移到自己，然后解方程。</p>
<p>具体如何使用请看下面两个题目的题解。</p>
<hr />
<h4 id="集训队作业2013城市规划-题解">[集训队作业2013]城市规划 题解</h4>
<p><strong>题意简述：</strong>求 <span class="math inline">\(n\)</span> 个点无重边无自环有标号无向连通图数目。<span class="math inline">\(n\leq 10^5\)</span>。</p>
<p><strong>题解：</strong>我们设 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(i\)</span> 个节点的答案，直接求并不好求，但是我们可以很容易的得到 <span class="math inline">\(n\)</span> 个点的图的数量，即 <span class="math inline">\(2^{C_n^2}\)</span> ，考虑怎么用 <span class="math inline">\(f\)</span> 来表示它。</p>
<p><span class="math inline">\(1\)</span> 号节点最终一定会有一个连通块，考虑枚举这个连通块的大小，于是就有 <span class="math inline">\(2^{C_n^2}=\sum_{i=1}^nC_{n-1}^{i-1}f(i)2^{C_{n-i}^2}\)</span>。也就是 <span class="math inline">\(i\)</span> 个点形成一个连通块，剩下的点随意连边。</p>
<p>为了方便，设 <span class="math inline">\(g(i)=2^{C_i^2}\)</span>，原式子就变成了 <span class="math inline">\(g(n)=\sum_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)\)</span>。</p>
<p>把组合数拆开，移项得 <span class="math inline">\(\frac{g(n)}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{g(n-i)}{(n-i)!}\)</span>，设 <span class="math inline">\(F(i)=\frac{f(i)}{(i-1)!}\)</span>，<span class="math inline">\(G(i)=\frac{g(i)}{i!}\)</span>，后面的求和就是一个卷积的形式，即 <span class="math inline">\(F\times G\)</span>。</p>
<p>把等式左边也稍加整理一下，就有 <span class="math inline">\(nG(n)=(F\times G)(n)\)</span>。</p>
<p>我们定义多项式的点乘为对应项相乘，再设 <span class="math inline">\(H(i)=i\)</span>，那么就有 <span class="math inline">\((H\cdot G)(n)=(F\times G)(n)\)</span>，即 <span class="math inline">\(H\cdot G=F\times G\)</span>。</p>
<p>又因为 <span class="math inline">\(G\)</span> 的常数项为 <span class="math inline">\(1\)</span>，故 <span class="math inline">\(G\)</span> 存在逆元，所以可以两边同时卷上 <span class="math inline">\(G^{-1}\)</span>。于是就有 <span class="math inline">\(F=(H\cdot G)\times G^{-1}\)</span>，写个多项式求逆就可以得到 <span class="math inline">\(F\)</span> 了。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<hr />
<h3 id="cf438e-the-child-and-binary-tree-题解">CF438E The Child and Binary Tree 题解</h3>
<p><strong>题意简述：</strong> 有无数个点，每个点的权值可以是给出集合 <span class="math inline">\(S\)</span> 中的任意一个，定义一棵树的权值是所有点的权值和，求有多少棵节点数目任意的、形态不同的、权值为 <span class="math inline">\(val\)</span> 的二叉树。对于每个 <span class="math inline">\(val\leq k\)</span> 都需要求解。<span class="math inline">\(k,|S|\leq 10^5\)</span>。</p>
<p>题解：直接设多项式 <span class="math inline">\(f\)</span> 为答案多项式，其中 <span class="math inline">\(f(i)\)</span> 表示 <span class="math inline">\(val=i\)</span> 的方案数。特别的，<span class="math inline">\(f(0)=1\)</span>。现在考虑 <span class="math inline">\(f\)</span> 怎么求。</p>
<p>设 <span class="math inline">\(g(i)\)</span> 表示一个点的权值为 <span class="math inline">\(i\)</span> 的方案数，显然 <span class="math inline">\(i\in S\)</span> 则 <span class="math inline">\(g(i)=1\)</span>，反之 <span class="math inline">\(g(i)=0\)</span>。</p>
<p>那么对于当前的，它左儿子的方案数是 <span class="math inline">\(f\)</span>，右儿子的方案数是 <span class="math inline">\(f\)</span>，它自己的方案数是 <span class="math inline">\(g\)</span>，而这个问题把解集合并就相当于是一个背包，那么就有 <span class="math inline">\(f=f\times f\times g+1\)</span>，这个加一是指当前这个点的子树为空。</p>
<p>之后把 <span class="math inline">\(f\)</span> 当做未知数解方程，根据求根公式，有 <span class="math inline">\(f=\frac{1\pm\sqrt{1-4g}}{2g}\)</span>，现在需要考虑正负取正还是负。</p>
<p>我们可以这么分析，当 <span class="math inline">\(g\)</span> 趋近于 <span class="math inline">\(0\)</span> 也就是 <span class="math inline">\(|S|\)</span> 趋近于 <span class="math inline">\(0\)</span> 的时候，<span class="math inline">\(f=\frac{1\pm1}{0}\)</span>，而此时方案数是为 <span class="math inline">\(0\)</span> 的，也就是 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(0\)</span>，那么就只能取负号，所以 <span class="math inline">\(f=\frac{1-\sqrt{1-4g}}{2g}\)</span>。</p>
<p><span class="math inline">\(g\)</span> 常数项不是 <span class="math inline">\(1\)</span>，没有逆元，考虑把分子有理化。就有 <span class="math inline">\(f=\frac{2}{1+\sqrt{1-4g}}\)</span>。多项式开根加个求逆即可。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<hr />
<p>上述题目，第一题用的是第一个 trick，第二题用的是第二个 trick，较好的体现了做多项式题目的技巧。且这两个题目十分经典，不失为练习多项式的好题。</p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于莫比乌斯函数的一些小技巧</title>
    <url>/2020/09/26/%E5%85%B3%E4%BA%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>总结一些有关莫比乌斯函数的应用以及一些数论方面的东西。</p>
<a id="more"></a>
<h3 id="kgcdxy-leftrightarrow-kx-text-and-ky">1. <span class="math inline">\(k|\gcd(x,y) \Leftrightarrow k|x \text{ and } k|y\)</span></h3>
<p>这个 trick 比较显然，不过还是小小的证明一下。</p>
<p>因为 <span class="math inline">\(\gcd(x,y)\)</span> 同时整除 <span class="math inline">\(x,y\)</span>，所以满足左边一定满足右边。因为 <span class="math inline">\(\gcd(x,y)\)</span> 是最大公因数，如果满足右边而不满足左边，那么一定存在一个 <span class="math inline">\(z\)</span> 使得 <span class="math inline">\(\gcd(x,y)\times z\)</span> 也是 <span class="math inline">\(x,y\)</span> 的公因数，和最大公因数的定义矛盾。</p>
<p>因此，若有式子 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{k|\gcd(x,y)}\mu(k)\)</span>，后面的 <span class="math inline">\(k|\gcd(x,y)\)</span> 就可以换成 <span class="math inline">\(k|x\text{ and }k|y\)</span>，这样的话就可以交换求和符号把 <span class="math inline">\(k\)</span> 提前了。</p>
<p>这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p>
<h3 id="若要计算-fgcdxy可以设-fnsum_dngd-来化简式子">2. 若要计算 <span class="math inline">\(f(\gcd(x,y))\)</span>，可以设 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span> 来化简式子。</h3>
<p>举个简单的例子，我们需要计算 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\gcd(i,j)\)</span>。</p>
<p>当然，这个并不典型，而且大多数人都会枚举 <span class="math inline">\(\gcd\)</span> 做，不过我们现在使用当前的这个 trick 来解决这个问题。</p>
<p>我们设 <span class="math inline">\(f(n)=n\)</span>，且 <span class="math inline">\(f(n)=\sum_{d|n}g(d)\)</span>，那么原式就变成了 <span class="math inline">\(\sum_{x=1}^n\sum_{y=1}^m\sum_{d|\gcd(x,y)}g(d)\)</span> 。然后就可以通过 trick 1 交换求和符号把 <span class="math inline">\(d\)</span> 提前了。而根据莫比乌斯反演，我们可以知道 <span class="math inline">\(g(n)=\sum_{d|n}f(d)\mu(\frac{n}{d})\)</span>（在该例题中恰好是 <span class="math inline">\(\mu*id=\varphi\)</span>），那么也可以很快地计算出 <span class="math inline">\(g\)</span>。这样就通过这个 trick 达到了简化式子的效果，而且在一些情况下比直接枚举 <span class="math inline">\(\gcd\)</span> 再把式子化来化去简单。</p>
<p>同样的，这个 trick 对于 <span class="math inline">\(\gcd\)</span> 内有多个元素同样有效。</p>
<h3 id="设-dx-为-x-的因子个数那么-dntimes-msum_xnsum_ymgcdxy1">3. 设 <span class="math inline">\(d(x)\)</span> 为 <span class="math inline">\(x\)</span> 的因子个数，那么 <span class="math inline">\(d(n\times m)=\sum_{x|n}\sum_{y|m}[\gcd(x,y)=1]\)</span>。</h3>
<p>可以发现，把所有合法的 <span class="math inline">\(x,y\)</span> 拿出来，然后列出所有的 <span class="math inline">\(x\times \frac{m}{y}\)</span>，这就是所有 <span class="math inline">\(n\times m\)</span> 的因子。</p>
<p>肯定不能感性的就这么理解，考虑严谨一点点的证明。</p>
<p><strong>先证明每个因子一定存在一种方式可以得到。</strong></p>
<p>我们假设 <span class="math inline">\(n=\prod p_i^{a_i},m=\prod p_i^{b_i}\)</span>，设某个 <span class="math inline">\(n\times m\)</span> 的因子 <span class="math inline">\(d=\prod p_i^{c_i}\)</span> 。对于 <span class="math inline">\(d\)</span> 的某个质因子及其次幂 <span class="math inline">\(p_i^{c_i}\)</span>，以及对应的 <span class="math inline">\(n,m\)</span> 的质因子及其次幂 <span class="math inline">\(p_i^{a_i},p_i^{b_i}\)</span>。分两种情况讨论。</p>
<ol type="1">
<li>若 <span class="math inline">\(c_i\leq b_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(b_i-c_i\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((0)+(b_i-(b_i-c_i))=c_i\)</span>，且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(0,b_i-c_i)=0}=1\)</span>。</li>
<li>若 <span class="math inline">\(c_i&gt;b_i\)</span>，又因为 <span class="math inline">\(c_i\leq a_i+b_i\)</span>，所以 <span class="math inline">\(c_i-b_i\leq a_i\)</span>，则使 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(c_i-b_i\)</span>，<span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\(0\)</span>。这样在 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂为 <span class="math inline">\((c_i-b_i)+(b_i-0)=c_i\)</span>。且 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(p_i^{\min(c_i-b_i,0)=0}=1\)</span></li>
</ol>
<p>这样的话，对于因子 <span class="math inline">\(d\)</span> 的每个 <span class="math inline">\(p_i\)</span> 都这么构造一下即可。</p>
<p><strong>再证明每个因子只能由这一种方式得到。</strong></p>
<p>根据上一部分的证明，不能发现这个性质其实是显然的。不过还是简要说一下。</p>
<p>对于上文的情况 1，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最小为 <span class="math inline">\((1)+(b_i-0)=b_i+1&gt; b_i\geq c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p>
<p>对于上文的情况 2，若要使 <span class="math inline">\(p_i\)</span> 在 <span class="math inline">\(\gcd\)</span> 中的贡献为 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂 <span class="math inline">\(\not=0\)</span>，那么 <span class="math inline">\(x\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂必须为 <span class="math inline">\(0\)</span>，而此时 <span class="math inline">\(x\times \frac{m}{y}\)</span> 中 <span class="math inline">\(p_i\)</span> 的次幂最大为 <span class="math inline">\((0)+(b_i-1)=b_i-1&lt;b_i&lt;c_i\)</span>，故构造不出 <span class="math inline">\(c_i\)</span>。</p>
<p>综上就可以证明这个 trick。</p>
<p>同样的，这个 trick 对于多个元素的乘积同样有效，即：</p>
<p><span class="math inline">\(d(\prod a_i)=\sum_{b_1|a_1}\sum_{b_2|a_2}...[\gcd(b_1,b_2)=1][\gcd(b_1,b_3)=1][\gcd(b_2,b_3)=1]...\)</span>。</p>
<h3 id="若求和式中出现枚举-xy-且涉及到了-xy-时大多数时候需要改变思路枚举-xy">4. 若求和式中出现枚举 <span class="math inline">\(x,y\)</span> 且涉及到了 <span class="math inline">\(xy\)</span> 时，大多数时候需要改变思路枚举 <span class="math inline">\(xy\)</span>。</h3>
<p>其实这个是一个十分普遍的小 trick。</p>
<p>还是用那个老到不能再老的例子举例，求 <span class="math inline">\(\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)\)</span>。</p>
<p>我们来枚举 <span class="math inline">\(\gcd\)</span>，然后变化一下就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]\)</span> 。根据常识，就有 <span class="math inline">\(\sum_{d=1}^nd\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{n}{kd}\rfloor\)</span>，直接这么做就是 <span class="math inline">\(n\log n\)</span> 的，而且对于 <span class="math inline">\(n\)</span> 很大或者是多组询问不太好优化。</p>
<p>我们发现求和式中出现了 <span class="math inline">\(d\)</span>，也出现了 <span class="math inline">\(k\)</span>，同时涉及到了 <span class="math inline">\(dk\)</span>，那么考虑设 <span class="math inline">\(T=dk\)</span>，我们来枚举 <span class="math inline">\(T\)</span>，就有 <span class="math inline">\(\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{n}{T}\rfloor\sum_{k|T}\mu(k)\frac{T}{k}\)</span>。这样的话，有个求和变成了狄利克雷卷积，而一般来说卷出来的东西是积性函数。这样的话，前面的东西就可以用整数分块，而后面的东西可以线性筛预处理，或者使用亚线性筛直接求。这样大大加快了代码运行的时间。</p>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title>划分数</title>
    <url>/2020/10/09/%E5%88%92%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<p>划分数就是把一个数 <span class="math inline">\(n\)</span> 拆分成若干个正整数的和的方案数，其中这若干个正整数是无序的，也就是 <span class="math inline">\(\{1,1,2\}\)</span> 和 <span class="math inline">\(\{1,2,1\}\)</span> 是等价的拆分。</p>
<p>下面我们来讨论怎么求它。</p>
<a id="more"></a>
<h5 id="简单-dp">简单 DP</h5>
<p>我们可以设 <span class="math inline">\(f_{i,j}\)</span> 表示把 <span class="math inline">\(i\)</span> 拆分成 <span class="math inline">\(j\)</span> 个正整数的方案数。</p>
<p>转移有两种，要么添加一个 <span class="math inline">\(1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j-1}+f_{i-j,j}\)</span>。</p>
<p>那么我们要求的划分数就是 <span class="math inline">\(\sum_{x=0}^n f_{n,x}\)</span>。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>这个算法的优点是我们可以知道所有把 <span class="math inline">\(x\leq n\)</span> 拆分成 <span class="math inline">\(y\leq n\)</span> 个正整数的方案数，缺点是复杂度过高。</p>
<h5 id="根号分治-dp">根号分治 DP</h5>
<p>可以发现，大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多选 <span class="math inline">\(\sqrt{n}\)</span> 个，所以我们可以依靠这个来优化算法。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示用小于等于 <span class="math inline">\(i\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p>
<p>转移有两种，要么是多加一个 <span class="math inline">\(i\)</span>，要么就把 <span class="math inline">\(i\)</span> 加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(f_{i,j}=f_{i-1,j}+f_{i,j-i}\)</span>。</p>
<p>这里的 <span class="math inline">\(i\)</span> 我们只枚举到 <span class="math inline">\(\sqrt{n}\)</span>，这样我们就可以知道用小于等于 <span class="math inline">\(\sqrt{n}\)</span> 拼成某个数的方案数。</p>
<p>设 <span class="math inline">\(g_{i,j}\)</span> 表示用 <span class="math inline">\(i\)</span> 个数大于 <span class="math inline">\(\sqrt{n}\)</span> 的数构成 <span class="math inline">\(j\)</span> 的方案数。</p>
<p>转移有两种，要么添加一个 <span class="math inline">\(\sqrt{n}+1\)</span>，要么把所有数都加 <span class="math inline">\(1\)</span>。</p>
<p>即 <span class="math inline">\(g_{i,j}=g_{i-1,j-\sqrt{n}-1}+g_{i,j-i}\)</span>。</p>
<p>因为大于 <span class="math inline">\(\sqrt{n}\)</span> 的数我们最多用 <span class="math inline">\(\sqrt{n}\)</span> 个，所以 <span class="math inline">\(i\)</span> 的上限也是 <span class="math inline">\(\sqrt{n}\)</span>。</p>
<p>那么最后的答案就是 <span class="math inline">\(\sum_{x=0}^n f_{\sqrt{n},x}\times \left(\sum_{y=0}^{\sqrt{n}} g_{y,n-x}\right)\)</span> 。即枚举小于等于 <span class="math inline">\(\sqrt{n}\)</span> 的数的和。复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<p>这个算法的优点是比多项式做法容易，且复杂度优于简单 DP。缺点是我们只能求得 <span class="math inline">\(n\)</span> 的划分数。</p>
<h5 id="多项式">多项式</h5>
<p>我们可以类似背包的来构造生成函数。</p>
<p>设 <span class="math inline">\(P\)</span> 为划分数的生成函数，即 <span class="math inline">\(P_k\)</span> 的系数为 <span class="math inline">\(k\)</span> 的划分数。</p>
<p>那么就有 <span class="math inline">\(P=\prod_j^\infty\left(\sum_i a_ix^{ij}\right)\)</span>。</p>
<p>即枚举选择的数的大小 <span class="math inline">\(j\)</span>，然后乘上它的生成函数。</p>
<p>根据常识，原式等于 <span class="math inline">\(\prod_{j=1}^\infty \frac{1}{1-x^j}\)</span>。</p>
<p>然后通过 <span class="math inline">\(\ln\)</span> 和 <span class="math inline">\(\exp\)</span> 化乘为加，就可以求得 <span class="math inline">\(P\)</span>。</p>
<p>我们先不看 <span class="math inline">\(\exp\)</span>，先算 <span class="math inline">\(\ln\)</span>。那么原式就是 <span class="math inline">\(-\sum_{j=1}^\infty\ln(1-x^j)\)</span>。</p>
<p>考虑怎么计算 <span class="math inline">\(\ln(1-x^j)\)</span>，换个元设 <span class="math inline">\(u=x^j\)</span>，我们就需要求 <span class="math inline">\(\ln(1-u)\)</span>。</p>
<p>先求导，即 <span class="math inline">\(-\frac{1}{1-u}=-\sum_{i=0}^\infty u^i\)</span>，然后积分，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{u^i}{i}\)</span> 。把元换回来，即 <span class="math inline">\(-\sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p>
<p>那么原式就成了 <span class="math inline">\(\sum_{j=1}^\infty \sum_{i=1}^\infty \frac{x^{ij}}{i}\)</span>。</p>
<p>最后把这一坨 <span class="math inline">\(\exp\)</span> 一下就得到了 <span class="math inline">\(P\)</span>。</p>
<p>不难发现当上界为 <span class="math inline">\(n\)</span> 的时候，这个求和的复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<p>而求 <span class="math inline">\(\exp\)</span> 的复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的，故总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>这个算法的优点是能非常快的计算出 <span class="math inline">\(x\leq n\)</span> 的划分数，缺点是很复杂，且对模数有要求。</p>
<hr />
<p>至此就讨论完了三种求划分数的方法。但是如果你认为这就完了那就 <code>too young too simple, sometimes naive</code> 了，出题人怎么可能就只考裸的划分数呢。</p>
<p>下面我们再讨论一下如果限制了划分出来的正整数个数，或者限制了划分出来的正整数的大小该怎么做。</p>
<p>我们可以发现，上述算法的【简单 DP】是很好处理前者的，【多项式】是很好处理后者的，而【根号分治 DP】中的 <span class="math inline">\(f\)</span> 可以维护后者， <span class="math inline">\(g\)</span> 可以维护前者，合并都不好维护。但是回顾上述算法，你会发现它们在最根本的思想上是相似的，而它们在这方面的性质又不一样，这就促使了我们去探究上面两个限制的关系。</p>
<p><strong>引理：把划分出来的正整数排序，并形成一个阶梯图，这个图在行列上具有对偶性。</strong></p>
<p>这么说比较抽象，我也不知道表达对不对，但是看了下面的图就知道了。（只看加粗部分）</p>
<p><img src="https://s1.ax1x.com/2020/10/09/0DFNCV.png" /></p>
<p>这张图不管是以列划分（左），还是以行划分（右），都可以看做是一个划分数的划分，且它们一一对应。</p>
<p>假设柱状物的个数为数的个数，柱状物的高度是数的大小。</p>
<p>那么如果限制是划分出来的正整数个数不超过数 <span class="math inline">\(x\)</span> ，在左图相当于是柱状物的个数不超过 <span class="math inline">\(x\)</span>，那么在右图就是柱状物的高度不超过 <span class="math inline">\(x\)</span>。</p>
<p>也就是说，限制划分出来的正整数个数不超过 <span class="math inline">\(x\)</span>，和限制划分出来的正整数的大小不大于 <span class="math inline">\(x\)</span> 在本质上是相同的。我们可以对它们进行等价的转化。</p>
<p>这样就可以解释为何上述三个同根的算法性质不同了。</p>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组学习笔记</title>
    <url>/2020/09/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>老忘后缀数组咋写，写个东西记录下。</p>
<p>算法核心：因为后缀是在同一个串内的，要充分利用其它信息。</p>
<a id="more"></a>
<p>考虑倍增，即从小到大按照长度为 <span class="math inline">\(2^k\)</span> 的串进行排序。</p>
<p>先按照长度为 <span class="math inline">\(1\)</span> 的串排序，每个点有一个排名。</p>
<p>然后扩展到长度为 <span class="math inline">\(2\)</span>，现在可以知道每个长度为 <span class="math inline">\(2\)</span> 的串前一半相对的排名和后一半相对的排名，那么显然是要先按前一半的排，如果相等再按后一半的排，用 pair 加快排可以做到 <span class="math inline">\(n\log n\)</span>，但是不够。考虑使用基数排序，就可以做到 <span class="math inline">\(n\)</span> 。</p>
<p>再扩展到长度为 <span class="math inline">\(4\)</span> …… 总时间复杂度 <span class="math inline">\(n\log n\)</span>。</p>
<p>光求这个没啥用，考虑求一个 height，表示排名为 i 的后缀和排名为 i-1 的最长公共前缀有多长。那么任意两个后缀的 LCP 就可以直接通过 RMQ 求。</p>
<p>考虑怎么求 height，设 h 表示第 i 串和排名恰好小于它 1 的串的最长公共前缀。那么有 <span class="math inline">\(h[i]\ge h[i-1]+1\)</span>。如果 <span class="math inline">\(h[i-1]\leq 1\)</span>，那么显然成立，否则 <span class="math inline">\(h[i-1]\geq 2\)</span>，假设排名恰好小于第 i-1 串 1 的串是第 k 串，那么就有 <span class="math inline">\(s[i-1,i-1+h[i-1])=s[k,k+h[i-1])\)</span> 且 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么 <span class="math inline">\(s[i,i-1+h[i-1])=s[k+1,k+h[i-1])\)</span>，因为 <span class="math inline">\(h[i-1]\geq 2\)</span>，那么这个区间不为空，又因为 <span class="math inline">\(s[i-1+h[i-1]]&gt;s[k+h[i-1]]\)</span>，那么第 k+1 串的排名肯定是小于第 i 串的，而距离 i 越远 LCP 就越小，那么第 i 串和排名恰好小于它 1 的串的 LCP 至少为 <span class="math inline">\(h[i-1]-1\)</span> 。所以可以直接从小到大暴力枚举求。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式学习笔记</title>
    <url>/2020/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前置知识">前置知识</h4>
<h5 id="形式幂级数">形式幂级数</h5>
<p>对于一个多项式 <span class="math inline">\(\sum_{i=0}^{\infty}a_ix^i\)</span>，如果我们只关心它的各项系数 <span class="math inline">\(\{a_0,a_1...\}\)</span>，而并不关心 <span class="math inline">\(x\)</span> 的值以及其收敛或发散的问题，就可以说其是关于 <span class="math inline">\(x\)</span> 的形式幂级数。</p>
<a id="more"></a>
<h5 id="牛顿迭代">牛顿迭代</h5>
<p>对于一个已知的多项式 <span class="math inline">\(F\)</span>，求一个多项式 <span class="math inline">\(A\)</span>，使得 <span class="math inline">\(F(A)=0\)</span> 在模 <span class="math inline">\(x^n\)</span> 意义下成立，其中 <span class="math inline">\(F,A\)</span> 都是形式幂级数。</p>
<p>牛顿迭代是这样的，假设我们已经求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 下的解 <span class="math inline">\(A_0\)</span>，那么可以把 <span class="math inline">\(F(A)\)</span> 在 <span class="math inline">\(A_0\)</span> 处泰勒展开，再模掉 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(F(A)=F(A_0)+F&#39;(A_0)(A-A_0)\)</span>，然后就可以通过解方程求的在模 <span class="math inline">\(x^n\)</span> 意义下的 <span class="math inline">\(A\)</span>。</p>
<h4 id="运算">运算</h4>
<h5 id="加减法">加减法</h5>
<p>就是多项式对应项相加减。即 <span class="math inline">\(C_ix^i=(A_i+B_i)x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="乘法卷积">乘法（卷积）</h5>
<p>多项式的乘法本质上是求 <span class="math inline">\(C_ix^i=\sum_{j+k=i}A_jB_kx^i\)</span>。可以使用 FFT 或者 NTT 解决。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="求导">求导</h5>
<p>对于一个单项式 <span class="math inline">\(kx^n\)</span> 求导，其值是 <span class="math inline">\(knx^{n-1}\)</span>，而对于多项式的求导，本质上是把各个单项式求导之后再加起来。即 <span class="math inline">\(C_ix^i=(i+1)A_{i+1}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p>有两个在多项式中常见的求导公式：<span class="math inline">\((\ln x)&#39;=\frac{1}{x},(e^x)&#39;=e^x\)</span>。</p>
<p>特别的，复合函数也可以求导，<span class="math inline">\((F(G))&#39;=F&#39;(G)\times G&#39;\)</span>。</p>
<h5 id="积分">积分</h5>
<p>积分是求导的逆运算，在求导中，有 <span class="math inline">\(kx^n\rightarrow knx^{n-1}\)</span>，那么积分里面就有 <span class="math inline">\(kx^n\rightarrow\frac{k}{n+1}x^{n+1}\)</span> 。而对于多项式的积分，也是把各个单项式求导之后再加起来，即 <span class="math inline">\(C_ix^i=\frac{A_{i-1}}{i}x^i\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="翻转">翻转</h5>
<p>对于一个 <span class="math inline">\(n\)</span> 次多项式 <span class="math inline">\(A(x)=\sum_{i=0}^n a_ix^i\)</span>，将它变成 <span class="math inline">\(\sum_{i=0}^n a_{n-i}x^i\)</span>，就称之为翻转，记作 <span class="math inline">\(A^R(x)\)</span>，不难发现本质上 <span class="math inline">\(A^R(x)=A(\frac{1}{x})\times x^n\)</span>。复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h5 id="求逆">求逆</h5>
<p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个多项式 <span class="math inline">\(A^{-1}(x)\)</span>，使得 <span class="math inline">\(A(x)\times A^{-1}(x)\equiv 1~(~{\rm mod}~x^{n})\)</span>。</p>
<p>考虑使用牛顿迭代，设 <span class="math inline">\(B(x)=A^{-1}(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 。假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\frac{1}{B(x)}=\frac{1}{B_0(x)}+(\frac{1}{B_0(x)})&#39;(B(x)-B_0(x))\)</span>，我们知道 <span class="math inline">\((\frac{1}{B_0(x)})&#39;=-\frac{1}{B_0^2(x)}\)</span>，那么把 <span class="math inline">\(\frac{1}{B(x)}-A(x)\equiv 0~(~{\rm mod}~x^{n})\)</span> 中的 <span class="math inline">\(\frac{1}{B(x)}\)</span> 换成上面右边的那一坨，然后稍加整理一下就有 <span class="math inline">\(B(x)\equiv 2B_0(x)-A(x)B_0^2(x)~(~{\rm mod}~x^n)\)</span> 。直接这么倍增处理即可，复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。因为相对于最后一次来说，前面的若干次可以忽略不计。</p>
<h5 id="除法和取模">除法和取模</h5>
<p><span class="math inline">\(A(x)=B(x)\times C(x)+D(x)\)</span>，其中 <span class="math inline">\(A(x)\)</span> 是 <span class="math inline">\(n\)</span> 次多项式，<span class="math inline">\(B(x)\)</span> 是 <span class="math inline">\(m\)</span> 次多项式，<span class="math inline">\(m&lt;n\)</span>，给出 <span class="math inline">\(A(x),B(x)\)</span>，求 <span class="math inline">\(C(x),D(x)\)</span>。</p>
<p>显然，<span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，<span class="math inline">\(D(x)\)</span> 的次数最大是 <span class="math inline">\(m-1\)</span>，就把它看做是 <span class="math inline">\(m-1\)</span> 项，高位不足就补零。</p>
<p>先换元，把等式两边的 <span class="math inline">\(x\)</span> 换做 <span class="math inline">\(\frac{1}{x}\)</span>，然后再在两边同时乘上 <span class="math inline">\(x^n\)</span>，就有 <span class="math inline">\(A(\frac{1}{x})\times x^n=B(\frac{1}{x})\times x^{m}\times C(\frac{1}{x}) \times x^{n-m}+D(\frac{1}{x})\times x^{m-1}\times x^{n-m+1}\)</span>，根据上述的翻转式子，就是 <span class="math inline">\(A^R(x)=B^R(x)\times C^R(x)+D^R(x)\times x^{n-m+1}\)</span> 。前面已经说了 <span class="math inline">\(C(x)\)</span> 的次数是 <span class="math inline">\(n-m\)</span>，那么等式模去 <span class="math inline">\(x^{n-m+1}\)</span> 并不会对 <span class="math inline">\(C(x)\)</span> 有任何损失，所以就有 <span class="math inline">\(A^R(x)\equiv B^R(x)\times C^R(x)~({\rm mod}~x^{n-m+1})\)</span>，对 <span class="math inline">\(B^R(x)\)</span> 求个逆元乘上就可以得到 <span class="math inline">\(C^R(x)\)</span>，翻转一下就是 <span class="math inline">\(C(x)\)</span>，然后就可以通过 <span class="math inline">\(A(x)-B(x)\times C(x)\)</span> 得到 <span class="math inline">\(D(x)\)</span>。复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="ln-和-exp">ln 和 exp</h5>
<p>因为积分是求导的逆运算，所以一个多项式先求导再积分，多项式不变。</p>
<p>那么对于 ln，就可以先求导再积分来求。即 <span class="math inline">\(\ln F(x)=\int_0^n(\ln F(x))&#39;~{\rm dx}\)</span>，前面已经提到了复合函数求导，所以就有 <span class="math inline">\(\ln F(x)=\int_0^n\frac{F&#39;(x)}{F(x)}~{\rm dx}\)</span> 。复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p>
<p>对于 exp，它是 ln 的逆运算，考虑用牛顿迭代求。设 <span class="math inline">\(B(x)=e^{A(x)}\)</span>，那么就有 <span class="math inline">\(\ln B(x)-A(x)=0\)</span>，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(\ln B(x)=\ln B_0(x)+\ln&#39;B_0(x)(B(x)-B_0(x))\)</span>，上文已有 <span class="math inline">\(ln&#39;B_0(x)=\frac{1}{B_0(x)}\)</span>，把这个 <span class="math inline">\(\ln B(x)\)</span> 带回原式中去，整理一下就有 <span class="math inline">\(B(x)\equiv B_0(x)(A(x)+1-\ln B_0(x))~(~{\rm mod}~x^n)\)</span>。直接倍增求即可，复杂度也是 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h5 id="开根">开根</h5>
<p>对于一个多项式 <span class="math inline">\(A(x)\)</span>，求出一个 <span class="math inline">\(B(x)\)</span>，使得 <span class="math inline">\(B^2(x)\equiv A(x)~(~{\rm mod}~x^n)\)</span>。</p>
<p>仍然可以使用牛顿迭代法求，假设我们现在求得了在模 <span class="math inline">\(x^{\frac{n}{2}}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，那么就有 <span class="math inline">\(B^2(x)=B_0^2(x)+(B_0^2(x))&#39;(B(x)-B_0(x))\)</span>。类似的，整理之后就有 <span class="math inline">\(B(x)\equiv \frac{A(x)}{2B_0(x)}+\frac{B_0(x)}{2}~(~{\rm mod}~x^n)\)</span> 。复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的。</p>
<h4 id="其他东西">其他东西</h4>
<h5 id="分治-fft">分治 FFT</h5>
<p>分治 FFT 可以用来干两种事情。</p>
<p>一种是要把一堆多项式要乘起来，如果直接一个一个乘的话复杂度最坏是 <span class="math inline">\(O(n^2\log n)\)</span> 的，而如果每次对半分，左右分别计算然后再卷积一次，单层的复杂度就是 <span class="math inline">\(O(n\log n)\)</span> 的，一共 <span class="math inline">\(O(\log n)\)</span> 层，总复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>还有一种是需要求一个多项式的时候，前面的项对后面的项有影响，那么就可以用 CDQ 分治的思想，先算前面的，然后算前面对后面的贡献，最后再算后面的，复杂度 <span class="math inline">\(O(n \log^2 n)\)</span>。</p>
<h5 id="任意模数-ntt">任意模数 NTT</h5>
<p>有两种方法，三模数 NTT 和 拆系数 MTT。</p>
<p>三模数 NTT，就如它的名字，选三个 NTT 模数，分别做一遍 NTT 最后用 CRT 合并。最后 CRT 求出来的一定是精确的值，所以需要保证最终的值在三个 NTT 模数的乘积以内。复杂度是 <span class="math inline">\(O(n \log n)\)</span>，9 倍常数。</p>
<p>拆系数 MTT，也如它的名字，就是把每个数 <span class="math inline">\(X\)</span> 拆成 <span class="math inline">\(AM+B\)</span> 的形式，那么如果有两个多项式 <span class="math inline">\(AM+B\)</span> 和 <span class="math inline">\(CM+D\)</span> 相乘，最后的结果就是 <span class="math inline">\(ACM^2 + (AD+BC)M+BD\)</span>，最后乘出来的结果是 <span class="math inline">\(M^2{\rm len}\)</span>，一般情况下可以跑 FFT，用 long double 存。复杂度是 <span class="math inline">\(O(n\log n)\)</span>，7 倍常数。</p>
<h5 id="多点求值">多点求值</h5>
<p>对于一个多项式 <span class="math inline">\(F\)</span>，给出一些 <span class="math inline">\(z_i\)</span>，需要求出 <span class="math inline">\(F(z_i)\)</span> 的值。</p>
<p>对于求出 <span class="math inline">\(F(z_i)\)</span>，我们可以这么做：次数从高到低扫这个多项式，然后把当前项的一个 <span class="math inline">\(x\)</span> 展开成 <span class="math inline">\(z_i\)</span>（即对于 <span class="math inline">\(ax^k\)</span>，把它展开成 <span class="math inline">\(ax^{k-1}z_i\)</span>，然后把它累加到 <span class="math inline">\(x^{k-1}\)</span> 项中去），最后在常数项的那个值就是 <span class="math inline">\(F(z_i)\)</span>。可以发现，这个过程实际上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p>
<p>对于上述问题，有另一种理解方式：设 <span class="math inline">\(F(z)=A(z)(z-z_i)+B\)</span>，那么当 <span class="math inline">\(z=z_i\)</span> 时，<span class="math inline">\(F(z_i)=B\)</span>，所以本质上就是对 <span class="math inline">\(x-z_i\)</span> 取模。</p>
<p>在自然数集中，有 <span class="math inline">\(X~{\rm mod}~BC~{\rm mod}~B = X~{\rm mod}~B\)</span>，其实在多项式中也是这样。</p>
<p>所以可以考虑分治。在分治的过程中，把 <span class="math inline">\(F\)</span> 对 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> 取模，最后递归到叶子节点的时候，当前的多项式就只剩下常数项，就是需要求的 <span class="math inline">\(F(z_i)\)</span>。</p>
<p>考虑发现复杂度，一开始需要求得 <span class="math inline">\(\prod_{i=l}^r (x-z_i)\)</span> ，分治 FFT 解决。之后需要分治求解，在每一层，多项式的长度都是 <span class="math inline">\(O({\rm len})\)</span>，所以每层的总长是 <span class="math inline">\(O(n)\)</span> 的，一共有 <span class="math inline">\(O(\log n)\)</span> 层。所以总复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span> ，常数巨大。</p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>广义二项式定理</title>
    <url>/2020/09/26/%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>提前介绍一下广义的组合数，组合数 <span class="math inline">\(\tbinom{n}{m}\)</span> 的定义是 <span class="math inline">\(\frac{n\times (n-1)\times ... \times (n-m+1)}{m!}\)</span>，广义下的组合数只需要保证 <span class="math inline">\(m\)</span> 为非负整数，<span class="math inline">\(n\)</span> 可以是任意实数。</p>
<a id="more"></a>
<p>对于广义的组合数，有个恒等式 <span class="math inline">\(\tbinom{n}{m}=\tbinom{m-n-1}{m}\times (-1)^{m}\)</span> 。</p>
<blockquote>
<p>两式的分母都是一样的，对于左式，其分子是 <span class="math inline">\(n\times (n-1)\times ... \times (n-m+1)\)</span>，对于右式，其分子是 <span class="math inline">\((m-n-1)\times ((m-n-1)-1) \times ... \times ((m-n-1)-m+1)\)</span>，可以发现右式分子的每个单项式和左式分子的单项式一一对应，并且互为相反数，那么最后乘上一个 <span class="math inline">\((-1)^m\)</span> 即可。</p>
</blockquote>
<p>有个很妙的记忆方法：两级反转（和艾克真的一点关系都没有 /doge）连续变化两次，设未知数，下标不变，上标用 <span class="math inline">\(m-1\)</span> 去减，即：<span class="math inline">\(\tbinom{n}{m}=\tbinom{m-?-1}{m}\times (-1)^{2m}\)</span>，那么可以很快得出问号是 <span class="math inline">\(m-n-1\)</span> 。当然直接用上文的证明去推更 nice。</p>
<p>广义二项式定理： <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 这里的 <span class="math inline">\(k\)</span> 可以是任意实数，一般会用在 <span class="math inline">\(k\)</span> 为负整数的时候，那么我们在下面约定所有出现的 <span class="math inline">\(k\)</span> 都是<strong>负整数</strong>，且为了方便理解，设 <span class="math inline">\(n=-k\)</span>。</p>
<p>考虑用生成函数去解释，先把 <span class="math inline">\((a+b)^{k}\)</span> 看成 <span class="math inline">\((a+bx)^{k}\)</span> 那么最后只要把 <span class="math inline">\(x\)</span> 看成 <span class="math inline">\(1\)</span> 即可。</p>
<p>先考虑最基本的情况：<span class="math inline">\((1-x)^{-n}\)</span> 。</p>
<p>根据数学知识可以知道上式就是 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}\)</span> 。</p>
<p>根据生成函数，可以知道 <span class="math inline">\((1-x)^{-1}=\sum_{i=0}^{\infty} x^i\)</span> 。</p>
<blockquote>
<p>设 <span class="math inline">\(S=1+x+x^2+...\)</span>，那么 <span class="math inline">\(xS=x+x^2+x^3+...\)</span>，那么 <span class="math inline">\(S-xS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-x}\)</span> 即 $ (1-x)^{-1}$</p>
</blockquote>
<p>那么 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\left( \sum_{i=0}^{\infty} x^i \right)^{n}\)</span> 。</p>
<p>考虑从组合意义上去计算这个式子：你有 <span class="math inline">\(n\)</span> 种球，每种球无限个，你需要从这 <span class="math inline">\(n\)</span> 种球中选择一共 <span class="math inline">\(i\)</span> 个球，每种球至少选 <span class="math inline">\(0\)</span> 个，其方案数就是 <span class="math inline">\(x^i\)</span> 的系数。那么使用隔板法就有 <span class="math inline">\(\tbinom{i+n-1}{n-1}\)</span> 。</p>
<p>所以 <span class="math inline">\(\left( (1-x)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}x^i\)</span> 。</p>
<p>那么我们再在 <span class="math inline">\(x\)</span> 前面加上一个系数 <span class="math inline">\(p\)</span> ，即求 <span class="math inline">\((1-px)^{-1}\)</span> 。它是等于 <span class="math inline">\(\sum_{i=0}^{\infty} p^ix^i\)</span> 。</p>
<blockquote>
<p>设 <span class="math inline">\(S=1+px+p^2x^2+...\)</span> ，那么 <span class="math inline">\(pxS=px+p^2x^2+p^3x^3+...\)</span>，那么 <span class="math inline">\(S-pxS=1\)</span>，所以 <span class="math inline">\(S=\frac{1}{1-px}\)</span> 即 <span class="math inline">\((1-px)^{-1}\)</span> 。</p>
</blockquote>
<p>那再按照上面的方法去推，就有 <span class="math inline">\(\left( (1-px)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}p^ix^i\)</span></p>
<p>回到一开始的问题，<span class="math inline">\((a+bx)^k=a^k \left( 1-(-\frac{b}{a}x) \right)^k\)</span> 。</p>
<p>那么就有 <span class="math inline">\((a+bx)^k=a^k \sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-\frac{b}{a})^ix^i\)</span> 。整理一下，<span class="math inline">\(\sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-1)^ia^{k-i}b^ix^i\)</span> 。</p>
<p>注意了，这里等式内部的组合数的 <span class="math inline">\(k\)</span> 前面都带个负号，因为上文在推导过程中，设的是 <span class="math inline">\(n=-k\)</span>，所以在组合数中的 <span class="math inline">\(n\)</span> 才是正号。</p>
<p>再根据文首提及的那个恒等式，就有 <span class="math inline">\(\tbinom{i-k-1}{-k-1}=\tbinom{i-k-1}{i}=\tbinom{k}{i}\times (-1)^i\)</span> 。</p>
<p>可以发现两个 <span class="math inline">\((-1)^i\)</span> 抵掉了，那么 <span class="math inline">\((a+bx)^k=\sum_{i=0}^{\infty} \tbinom{k}{i}a^{k-i}b^ix^i\)</span> 。</p>
<p>把 <span class="math inline">\(x=1\)</span> 带入原式，即可得 <span class="math inline">\((a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i\)</span> 。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构总结</title>
    <url>/2020/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>数据结构的一些小 trick。</p>
<a id="more"></a>
<h3 id="并查集">并查集</h3>
<h4 id="支持撤销">支持撤销</h4>
<p>每次合并的时候按照集合的大小进行启发式合并，并且用一个操作栈记录本次操作。</p>
<p>在撤销一次操作的时候，只需要按照记录还原并查集即可。</p>
<p>合并查询操作单次 <span class="math inline">\(O(\log n)\)</span>，撤销操作单次 <span class="math inline">\(O(1)\)</span>。这种并查集在一些离线算法下有大用处。</p>
<h4 id="维护不可逆的覆盖操作">维护不可逆的覆盖操作</h4>
<p>考虑这么一道题目：给一棵 <span class="math inline">\(n\)</span> 个点的树，有 <span class="math inline">\(m\)</span> 次操作，每次操作会把一条路径上的点染色，且颜色会覆盖之前染的颜色，求最后每个点的颜色，不强制在线。<span class="math inline">\(n\leq 10^6,m\leq 5\times 10^6\)</span>。</p>
<p>一种 naive 的思想是用树链剖分和线段树维护颜色，但是这样是 <span class="math inline">\(m\log^2 n\)</span> 的。</p>
<p>考虑把操作倒序，那么每次执行的是不可逆的染色操作。</p>
<p>对每个点维护并查集，表示它到根路径上第一个需要被染色的点是什么，一开始显然指向自己。</p>
<p>如果一个点被染色了，那么就把它的边连向它父亲。每次染色就直接按照并查集的链接暴力跳，然后染色即可。</p>
<p>因为每个点最多被染色一次，在并查集使用 <span class="math inline">\(n\alpha(n)\)</span> 复杂度的版本下，总复杂度仅为 <span class="math inline">\(O(n\alpha(n))\)</span>。</p>
<p>这个 trick 虽然可能不会单独成题，但是可能会被穿插到一些题目中。它对复杂度的优化还是挺大的。</p>
<h3 id="栈">栈</h3>
<h4 id="对顶栈">对顶栈</h4>
<p>例题：你需要动态维护一个长度为 <span class="math inline">\(n\)</span> 序列，有 <span class="math inline">\(q\)</span> 个操作，每个操作为头尾加删元素或查询一些信息。</p>
<p>假设只能从尾部加删，那么我们就可以维护一个类似于栈的东西，每次加进来一个就把它压入栈，并更新一些信息，删掉一个就把它从栈弹掉，并把信息复原。</p>
<p>现在我们两头都要支持加删，一种直接的想法是维护两个栈，并且把它们的栈底顶到一起，这样头尾加删和普通的加删就没有什么区别，只有查询的时候需要额外计算跨过两个栈的贡献。</p>
<p>但是这样会出现一个问题，可能有一次删除会把一个栈的栈底给删了，这样原先的结构就被破坏了，这是很麻烦的。但实际上只需要再从序列中间开始，重新构造两个栈就可以了，这样总的重新构造的点的数目的上限是 <span class="math inline">\(\max(n,q)\)</span> 的。</p>
<p>因为维护了这两个栈的顶着的，所以我们称它为对顶栈。</p>
<p>好像这种套路就能干这一件事情，博主也就在某次考试中遇到了一次，不过了解一下它的思想总是好的。</p>
<h4 id="栈-1">2048 栈</h4>
<p>因为没得名字，随手取了一个。（侵删）</p>
<p>当你需要动态维护一个不好加入元素的东西的时候（如 AC 自动机、凸包等），你就可以用这个 trick，花费额外的一个 <span class="math inline">\(\log\)</span> 的代价去较为方便的维护它。</p>
<p>这里就用 AC 自动机举例。</p>
<p>维护一个栈，每个栈内的元素都是一个 AC 自动机，并且记录下 AC 自动机内的字符串数目。</p>
<p>对于一次加入，就在栈顶加入一个新的 AC 自动机，内部保存这一次加入的这一个字符串。</p>
<p>如果此时栈顶的两个 AC 自动机内的字符串数目相同，就把这两个 AC 自动机合并，并且建出一个新的 AC 自动机，一直这样直到栈顶的两个 AC 自动机不满足这个条件。</p>
<p>不难发现，每次更新栈的时候，AC 自动机的大小就像 2048 一样，相同即合并，且都是 <span class="math inline">\(2\)</span> 的倍数。故每个字符串只会在它所在的 AC 自动机的大小为 <span class="math inline">\(2^k\)</span> 的时候有一个贡献，所以总复杂度是总长度乘上 <span class="math inline">\(\log\)</span> 字符串个数的。</p>
<p>特别的，这个 trick 是可以在线维护的。</p>
<p>boshi 提供了一个题目 <a href="https://www.luogu.com.cn/problem/CF710F">CF710F</a> 。</p>
<h3 id="线段树">线段树</h3>
<h4 id="时间和序列的对调">时间和序列的对调</h4>
<p>一般线段树都是维护的序列信息，如区间和，区间积。</p>
<p>但是在某些问题中，它的操作是区间修改，查询是单点查询，这时候就有一个对调时间和序列的 trick 。</p>
<p>正如 trick 的名字，我们把时间和序列对调，每次一步一步地在序列上面走，同时对时间维护线段树。</p>
<p>那么对于对调前的区间修改，现在就变成了两个单点的修改，对于对调前的查询，现在就变成了一个前缀的查询。</p>
<p>在某些方便不维护前者，而较方便维护后者的题目中，这个 trick 是非常实用的。</p>
<p>比如说 <a href="http://172.16.11.217:5283/problem/170">某场公开的考试题</a>。</p>
<h4 id="懒信息">懒信息</h4>
<p>也是随手取的名字，其实这个 trick 挺常见的。（侵删）</p>
<p>懒标记是不下传的标记，懒信息就是查询的时候不合并的信息。</p>
<p>在一些题目中，对于查询操作，如果各个区间的信息是独立的（也就是说并不需要把区间信息合并就可以得到答案），且合并区间信息的复杂度远大于通过单个区间的信息得到答案的复杂度，就可以把信息懒化。</p>
<p>例题：维护一个序列，支持两个操作：往后面加一个数，查询 <span class="math inline">\(x\)</span> 在区间 <span class="math inline">\([l,r]\)</span> 的排名，操作数 <span class="math inline">\(\leq 10^5\)</span>，保证查询的时候序列长度大于等于 <span class="math inline">\(r\)</span>，强制在线。</p>
<p>先设操作数为 <span class="math inline">\(n\)</span>，序列可能有 <span class="math inline">\(n\)</span> 这么长，所以先开一个长度为 <span class="math inline">\(n\)</span> 的线段树。</p>
<p>每个点维护一个有序的序列，表示它控制区间内的数排序之后的结果。</p>
<p>不难发现每层最多 <span class="math inline">\(n\)</span> 个数，一共 <span class="math inline">\(\log n\)</span> 层，所以空间复杂度 <span class="math inline">\(n \log n\)</span>。</p>
<p>对于每次往后面加数，就把对应位置的数进行更改，并且往上更新，更新的规则是这样的：如果一个点的儿子是满的，那么就更新它，否则就不更新它。</p>
<p>更新的时候可以使用归并排序，复杂度是 <span class="math inline">\(O(len)\)</span> 的，因为更新的规则，每个点只会被更新一次，复杂度也是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<p>对于查询，naive 的方法是把查询定位到的区间归并，然后看 <span class="math inline">\(x\)</span> 的排名，这样复杂度又回去了。</p>
<p>因为 <span class="math inline">\(x\)</span> 的排名就是 <span class="math inline">\(x\)</span> 前面有多少个数，所以我们没必要把查询定位到的区间合并，直接在每个定位到的区间内查询有多少个数小于 <span class="math inline">\(x\)</span> 即可。使用二分复杂度就是 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<p>更加复杂一点的还有 <a href="https://uoj.ac/problem/46">UOJ #46</a>。</p>
<h3 id="平衡树">平衡树</h3>
<h4 id="替罪羊树">替罪羊树</h4>
<p>trick 不是这个数据结构，而是它拍扁重构的思想。</p>
<p>如果你要动态维护一棵树，而且想要让它尽量的平衡（树高在 <span class="math inline">\(O(\log)\)</span> 级别），那么就可以通过控制平衡因子拍扁重构。</p>
<p>比较经典的是动态加点，动态维护点分树。因为点分树如果要保证复杂度，需要树高在 <span class="math inline">\(O(\log)\)</span> 级别，而动态加点并不好维护。那么我们就干脆在每次加点的时候，就把这个点看做一个子分治中心，并连向父亲。然后像替罪羊一样，如果某个子树太难看了，就直接拍扁重建。</p>
<p>比较经典的莫过于 <a href="https://www.luogu.com.cn/problem/P3920">[WC2014]紫荆花之恋</a> 了。</p>
<h3 id="根号算法">根号算法</h3>
<h4 id="根号分治">根号分治</h4>
<p>应该是一个比较普及的 trick。</p>
<p>差不多就是小于根号的暴力也无所谓，大于根号的也就根号个东西。</p>
<p>比如出现次数大于根号的数不超过根号个，图中度数大于根号的点不超过根号个等。</p>
<p>这个 trick 比较简单，但是也容易被忽视，注意一下就可以了。</p>
<p>这方面的话可能比较简单，<a href="https://www.luogu.com.cn/problem/P3396">哈希冲突</a> 是一个比较好的例子。</p>
<h4 id="时间分块">时间分块</h4>
<p>似乎对时间轴操作的 trick 都挺重要的。</p>
<p>如标题所说，就是把所有的操作按照时间分块，那么在块的内部就有一个很好的性质：时间线的变动量不超过块大小。所以就可以在块内按照其它东西排序，对于询问就只需要动时间线，可能会更加方便。</p>
<p>比如说 <a href="https://www.luogu.com.cn/problem/P5443">[APIO2019]桥梁</a>。</p>
<p>当然，一些其它的题目也可以用这个思想，可以把时间线的变动看做是别的东西的变动，比如 <a href="https://www.luogu.com.cn/problem/P3247">[HNOI2016]最小公倍数</a>。</p>
<h4 id="操作分块定期重构">操作分块（定期重构）</h4>
<p>也是一个比较妙的 trick。</p>
<p>在一些题目中，如果操作不好应用于序列，且很多个操作可以放一起修改序列，且操作对查询的影响比较好求，就可以用这个 trick。</p>
<p>这个 trick 的意思是先把所有的操作屯着，查询的时候可以先在原序列查，然后再去屯着的操作里面查。当屯着的操作达到一个上限的时候，就把它们一起放出来，把整个序列翻新一次。</p>
<p>这个 trick 也不常见，不过其思想也十分有意义。</p>
<h3 id="其它">其它</h3>
<h4 id="树的坐标表示">树的坐标表示</h4>
<p>其实也不是什么高科技，也就标题唬人。</p>
<p>把树上每个点的坐标看做是 <span class="math inline">\((dfn,dep)\)</span>。</p>
<p>这样的话，一个子树就代表着一个只有左右边界上下无界的矩形，子树内离当前点距离为某个范围内的点就对应着一个矩形，我们就可以把树上问题转化成二维平面上问题。</p>
<p><a href="https://ac.nowcoder.com/acm/contest/6944/C">这道题</a> 是个不错的例子。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数学习笔记</title>
    <url>/2020/09/26/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="下降幂和上升幂">下降幂和上升幂</h4>
<p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次下降幂记作 <span class="math inline">\(x^{\underline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x-i)\)</span> 。</p>
<p><span class="math inline">\(x\)</span> 的 <span class="math inline">\(k\)</span> 次上升幂记作 <span class="math inline">\(x^{\overline{k}}\)</span>，表示的是 <span class="math inline">\(\prod_{i=0}^{k-1}(x+i)\)</span>。</p>
<a id="more"></a>
<h4 id="第一类斯特林数">第一类斯特林数</h4>
<p><span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}\)</span> 表示第一类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个圆排列的方案数。圆排列不能为空。</p>
<p>第一类斯特林数有一个递推式，<span class="math inline">\(\begin{bmatrix} n \\ i \end{bmatrix}=\begin{bmatrix} n-1 \\ i \end{bmatrix}\times(n-1)+\begin{bmatrix} n-1 \\ i-1 \end{bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个圆排列，要么就跟在某个数的后面。</p>
<h4 id="第二类斯特林数">第二类斯特林数</h4>
<p><span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}\)</span> 表示第二类斯特林数，它的意义是把 <span class="math inline">\(n\)</span> 个有标号的点放入 <span class="math inline">\(i\)</span> 个无标号的集合的方案数。集合不能为空。</p>
<p>第二类斯特林数有一个递推式，<span class="math inline">\(\begin{Bmatrix}n \\ i\end{Bmatrix}=\begin{Bmatrix}n-1 \\ i\end{Bmatrix}\times i+\begin{Bmatrix}n-1 \\ i-1\end{Bmatrix}\)</span>，即考虑最后一个点放在哪里，要么是新开一个集合，要么就放在之前的某个集合里面。</p>
<h4 id="斯特林数和自然幂下降幂上升幂的关系">斯特林数和自然幂、下降幂、上升幂的关系</h4>
<p>对于自然幂和下降幂，有这么一个式子。<span class="math inline">\(n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\)</span>。</p>
<p>考虑从组合意义来理解它。<span class="math inline">\(n^m\)</span> 相当于是把 <span class="math inline">\(m\)</span> 个有标号的球放入 <span class="math inline">\(n\)</span> 个有标号的盒子的方案数，考虑枚举有多少个盒子有球，假设为 <span class="math inline">\(i\)</span>，那么选盒子的方案就是 <span class="math inline">\(\begin{pmatrix}n \\ i\end{pmatrix}\)</span>，然后把 <span class="math inline">\(m\)</span> 个球放到这 <span class="math inline">\(i\)</span> 个盒子里面去，方案是 <span class="math inline">\(\begin{Bmatrix}m \\ i\end{Bmatrix}\)</span>，而因为第二类斯特林数的集合是无标号的，这里是有标号的，所以最后需要乘上一个 <span class="math inline">\(i!\)</span>，然后把组合数展开，就得到上面的那个式子。</p>
<p>对于自然幂和上升幂，有这么一个式子。<span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}n^i\)</span> 。</p>
<p>考虑用数学归纳法来证明它，对于 <span class="math inline">\(m=0\)</span> 式子显然成立，假设现在已经证明对于 <span class="math inline">\(m\leq k-1\)</span> 式子成立，需要证明对于 <span class="math inline">\(m=k\)</span> 式子成立。</p>
<p><span class="math display">\[
\begin{split}
n^{\overline{k}}&amp;=n^{\overline{k-1}}\times(n+k-1)\\
&amp;=n^{\overline{k-1}}\times n+n^{\overline{k-1}}\times(k-1)\\
&amp;=\sum_{i=0}^{k-1}\begin{bmatrix}k-1 \\ i\end{bmatrix}n^{i+1}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~\\
&amp;=\sum_{i=1}^{k-1}\begin{bmatrix}k-1 \\ i-1\end{bmatrix}n^{i}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \\ i\end{bmatrix}n^i~~~~~~~~~\\
&amp;=\sum_{i=0}^k\begin{bmatrix}k \\ i\end{bmatrix}n^i
\end{split}
\]</span></p>
<p>故可以证明原式子成立。</p>
<h4 id="斯特林反演">斯特林反演</h4>
<h5 id="反转公式-i">反转公式 I</h5>
<p><span class="math inline">\(x^{\overline{k}}=(-1)^k(-x)^{\underline{k}}\)</span>，<span class="math inline">\(x^{\underline{k}}=(-1)^k(-x)^{\overline{k}}\)</span>。</p>
<p>这两个式子把它们拆开就可以证明相等了。</p>
<h5 id="反转公式-ii">反转公式 II</h5>
<p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}\begin{Bmatrix}i \\ m\end{Bmatrix}=[m==n]\)</span></p>
<p><span class="math inline">\(\sum_{i=m}^n(-1)^{n-i}\begin{Bmatrix}n \\ i\end{Bmatrix}\begin{bmatrix}i \\ m\end{bmatrix}=[m==n]\)</span></p>
<p>对于第二个证明如下： <span class="math display">\[
\begin{split}
n^m&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\
&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i(-n)^{\overline{i}}\\
&amp;=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix} i \\ j \end{bmatrix}(-n)^j\\
&amp;=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m \\ i\end{Bmatrix}\begin{bmatrix} i \\ j \end{bmatrix}(-1)^{i-j}\\
\end{split}
\]</span> 把 <span class="math inline">\(n\)</span> 看成是一个未知数时，对于一个多项式 <span class="math inline">\(\sum a_in^i\)</span>，<span class="math inline">\(n^m\)</span> 可以且仅可以用 <span class="math inline">\(a_mn^m\)</span> 来表示，所以最后的式子只有 <span class="math inline">\(j=m\)</span> 的时候为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>对于第一个式子，有 <span class="math inline">\(n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \\ i\end{bmatrix}(-1)^i(-n)^i\)</span>，把后面的自然幂展开成下降幂，然后再推一推就可以类似于上面讨论证明。</p>
<h5 id="斯特林反演公式">斯特林反演公式</h5>
<p><span class="math inline">\(f(n)=\sum_{i=0}^n\begin{Bmatrix}n \\ i\end{Bmatrix}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n \\ i\end{bmatrix}f(i)\)</span>。</p>
<p>和二项式反演类似，只需要证明一个方向，另一个方向显然成立。</p>
<p>正向证明如下： <span class="math display">\[
\begin{split}
g(n)&amp;=\sum_{i=0}^n[i==n]g(i)\\
&amp;=\sum_{i=0}^n\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\
&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}\sum_{i=0}^j\begin{Bmatrix}j \\ i\end{Bmatrix}g(i)\\
&amp;=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \\ j\end{bmatrix}f(j)
\end{split}
\]</span></p>
<h4 id="第一类斯特林数求自然数幂和">第一类斯特林数求自然数幂和</h4>
<p>设 <span class="math inline">\(\sum_{i=1}^n i^k\)</span> 为 <span class="math inline">\(S_k(n)\)</span>。 <span class="math display">\[
\begin{split}
&amp;\because n^m=\sum_{i=0}^m\begin{Bmatrix}m \\ i\end{Bmatrix}n^{\underline{i}}\\
&amp;\therefore n^{\underline{m}}=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\therefore n^m=n^{\underline{m}}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\therefore \sum_{n=1}^X n^m=\sum_{n=1}^Xn^{\underline{m}}-\sum_{n=1}^X\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}n^i\\
&amp;\begin{split}
\therefore S_m(X)&amp;=m!\sum_{n=1}^X\begin{pmatrix}n \\ m\end{pmatrix}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}\sum_{n=1}^Xn^i\\
&amp;=m!\begin{pmatrix}X+1 \\ m+1\end{pmatrix}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)\\
&amp;=\frac{(X+1)^{\underline{m+1}}}{m+1}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \\ i\end{bmatrix}S_i(X)~\\
\end{split}
\end{split}
\]</span> 故 <span class="math inline">\(S_m(X)\)</span> 可以在 <span class="math inline">\(m^2\)</span> 的时间复杂度内求得，且不要求模数是质数。</p>
<h4 id="快速求两类斯特林数">快速求两类斯特林数</h4>
<h5 id="第一类斯特林数行">第一类斯特林数·行</h5>
<p>我们知道 <span class="math inline">\(x^{\overline n}=\prod \begin{bmatrix}n \\ i\end{bmatrix}x^i\)</span> ，那直接算出 <span class="math inline">\(x(x+1)(x+2)...(x+n-1)\)</span> 就行了，分治 FFT 解决，时间复杂度 <span class="math inline">\(n\log^2 n\)</span>。</p>
<p>但是这样似乎有亿点点慢，考虑优化。</p>
<p>设 <span class="math inline">\(F_n(x)\)</span> 表示 <span class="math inline">\(x^{\overline n}\)</span> 形成的多项式，那么 <span class="math inline">\(x^{\overline {2n} }\)</span> 的多项式是等于 <span class="math inline">\(F_n(x)\times F_n(x+n)\)</span> 的，用二项式定理把后者展开，会发现是一个减法卷积的形式，所以可以在 <span class="math inline">\(n\log n\)</span> 的时间内求得 <span class="math inline">\(F_{2n}\)</span>，倍增的处理就可以做到 <span class="math inline">\(n\log n\)</span>。</p>
<h5 id="第一类斯特林数列">第一类斯特林数·列</h5>
<p>考虑用生成函数解决这个问题。</p>
<p>设由若干个数形成 <span class="math inline">\(k\)</span> 个圆排列的生成函数是 <span class="math inline">\(F_k\)</span>，这恰好是我们要求的。</p>
<p>因为用来形成圆排列的数是可以区分的，所以这个生成函数表示的应该是排列而不是组合（或者可以这么理解，设 <span class="math inline">\(x_1\)</span> 个数形成 <span class="math inline">\(y_1\)</span> 个圆排列的方案数为 <span class="math inline">\(z_1\)</span>，<span class="math inline">\(x_2\)</span> 个数形成 <span class="math inline">\(y_2\)</span> 个圆排列的方案数为 <span class="math inline">\(z_2\)</span>，那么由 <span class="math inline">\(x_1+x_2\)</span> 个数形成 <span class="math inline">\(y_1+y_2\)</span> 个圆排列的方案数并不是 <span class="math inline">\(z_1\times z_2\)</span>，而需要额外乘上一个组合数 <span class="math inline">\(\begin{pmatrix}x_1+x_2 \\ x_1\end{pmatrix}\)</span>），故 <span class="math inline">\(F_k\)</span> 是指数型生成函数。</p>
<p>假设我们现在已经知道了 <span class="math inline">\(F_1\)</span>，那么 <span class="math inline">\(F_k=\frac{F_1^k}{k!}\)</span>，即先生成 <span class="math inline">\(k\)</span> 个有序的圆排列，然后把序去掉。</p>
<p><span class="math inline">\(F_1\)</span> 很容易知道，即 <span class="math inline">\(\sum_{i&gt;0}(i-1)!\frac{x^i}{i!}\)</span> 。化简一下就是 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 。</p>
<p>那么我们就可以通过多项式快速幂得到 <span class="math inline">\(F_k\)</span>。</p>
<p>至此我们就已经可以得到某一列的第一类斯特林数的值，但是这个式子有那么一点点丑，考虑把它美化一下。</p>
<p>仔细观察一下 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 这个式子，会发现似乎这个东西有亿点点眼熟。先把它求导，得到 <span class="math inline">\(\sum_{i\geq 0}x^i=\frac{1}{1-x}\)</span>，再积分，就得到了 <span class="math inline">\(-\ln(1-x)\)</span>（实际上，博主是通过对 <span class="math inline">\(-\ln(1-x)\)</span> 求导积分得到 <span class="math inline">\(\sum_{i&gt;0} \frac{x^i}{i}\)</span> 的）。</p>
<p>所以 <span class="math inline">\(F_k=\frac{(-\ln(1-x))^k}{k!}\)</span> 。（虽然这并不能简化运算量，甚至还加大了难度（因为需要手动展开 <span class="math inline">\(\ln\)</span>），但是它变得好看了）。</p>
<h5 id="第二类斯特林数行">第二类斯特林数·行</h5>
<p>第二类斯特林数有一个人尽皆知的式子 <span class="math inline">\(n^m=\sum_{i=1}^n\begin{pmatrix}n \\ i \end{pmatrix}\begin{Bmatrix}m \\ i \end{Bmatrix}i!\)</span> 。</p>
<p>设 <span class="math inline">\(g(n)=n^m,f(i)=\begin{Bmatrix}m \\ i \end{Bmatrix}i!\)</span>，对原式使用二项式反演得到 <span class="math inline">\(\begin{Bmatrix}m \\ n \end{Bmatrix}n!=\sum_{i=1}^n(-1)^{n-i}\begin{pmatrix}n \\ i \end{pmatrix}i^m\)</span> 。把组合数展开，不难发现右边是一个卷积的形式，所以可以通过 FFT 在 <span class="math inline">\(n \log n\)</span> 的时间内求得第二类斯特林数的一行。</p>
<h5 id="第二类斯特林数列">第二类斯特林数·列</h5>
<p>同第一类斯特林数一样，用生成函数解决这个问题。</p>
<p>设把若干个数分到 <span class="math inline">\(k\)</span> 个集合的生成函数是 <span class="math inline">\(F_k\)</span>，这恰好是我们要求的。</p>
<p>同样的，用分析第一类斯特林数的方法来分析第二类斯特林数，可以发现 <span class="math inline">\(F_k\)</span> 也是指数型生成函数（可以参考上文理解）。</p>
<p>假设我们知道了 <span class="math inline">\(F_1\)</span>，那么 <span class="math inline">\(F_k=\frac{F_1^k}{k!}\)</span>，即先形成 <span class="math inline">\(k\)</span> 个有序的集合，然后把序去掉。</p>
<p><span class="math inline">\(F_1\)</span> 很容易知道，即 <span class="math inline">\(\sum_{i&gt;0}\frac{x^i}{i!}\)</span> ，特别的，它的第 <span class="math inline">\(0\)</span> 项为 <span class="math inline">\(0\)</span>。</p>
<p>这样我们就可以通过多项式快速幂得到 <span class="math inline">\(F_k\)</span>。</p>
<p>然后这个式子还不够美观，考虑把它美化一下。</p>
<p>根据常识，<span class="math inline">\(\sum_{i&gt;0}\frac{x^i}{i!}=e^x-1\)</span>。</p>
<p>所以 <span class="math inline">\(F_k=\frac{(e^x-1)^k}{k!}\)</span> 。</p>
<h4 id="贝尔数">贝尔数</h4>
<p>定义：对 <span class="math inline">\(n\)</span> 个数集合划分的数目。符号 <span class="math inline">\(B_n\)</span>。</p>
<p>根据定义不难得到 <span class="math inline">\(B_n\)</span> 是第二类斯特林数第 <span class="math inline">\(n\)</span> 行的和。</p>
<h5 id="递推式">递推式</h5>
<p>枚举第 <span class="math inline">\(n\)</span> 个数所在集合大小，有 <span class="math inline">\(B_n=\sum_{i=0}^{n-1}\begin{pmatrix}n-1 \\ i \end{pmatrix}B_{n-i-1}\)</span>。因为 <span class="math inline">\(\begin{pmatrix}n \\ i \end{pmatrix}=\begin{pmatrix}n \\ n-i \end{pmatrix}\)</span>，为了美观一般把递推式写成 <span class="math inline">\(B_n=\sum_{i=0}^{n-1}\begin{pmatrix}n-1 \\ i \end{pmatrix}B_i\)</span> 。</p>
<h5 id="生成函数">生成函数</h5>
<p>设 <span class="math inline">\(B_n\)</span> 的生成函数为 <span class="math inline">\(G\)</span>。</p>
<p>上文中，对于第二类斯特林数的第 <span class="math inline">\(k\)</span> 列，有 <span class="math inline">\(F_k=\frac{(e^x-1)^k}{k!}\)</span>，其中第 <span class="math inline">\(n\)</span> 项是 <span class="math inline">\(\begin{Bmatrix}n \\ k \end{Bmatrix}\)</span>。那么 <span class="math inline">\(\sum_{k\geq 0}F_k\)</span> 中第 <span class="math inline">\(n\)</span> 项就是第 <span class="math inline">\(n\)</span> 行斯特林数的和，就是 <span class="math inline">\(G\)</span>。</p>
<p><span class="math inline">\(G=\sum_{k\geq 0}F_k=\sum_{k\geq 0}\frac{(e^x-1)^k}{k!}=e^{e^x-1}\)</span> 。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛 70 E 题解</title>
    <url>/2020/09/29/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B-70-E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/7509/E">题目链接</a></p>
<p><strong>题意简述</strong></p>
<p>定义若二元组 <span class="math inline">\((a,b)&lt;(c,d)\)</span>，则有 <span class="math inline">\(a&gt;c\)</span> 或者 <span class="math inline">\(a=c \text{ and } b&lt;d\)</span>。</p>
<p>给你 <span class="math inline">\(n\)</span> 个数，第 <span class="math inline">\(i\)</span> 个数是 <span class="math inline">\(a_i\)</span>。</p>
<p>现在系统会生成 <span class="math inline">\(n\)</span> 个二元组，第 <span class="math inline">\(i\)</span> 个二元组是 <span class="math inline">\((a_i,i)\)</span> 或者是 <span class="math inline">\((a_i+1,i)\)</span>，然后给每个二元组一个排名，设排名数列为 <span class="math inline">\(rk\)</span>。</p>
<p>求有多少种不同的 <span class="math inline">\(rk\)</span> 数列，两个 <span class="math inline">\(rk\)</span> 序列不同当且仅当存在至少一个位置 <span class="math inline">\(x\)</span>，使得两个 <span class="math inline">\(rk\)</span> 数列的 <span class="math inline">\(rk_x\)</span> 不同。</p>
<p><span class="math inline">\(n\leq 5\times 10^5,a_i\leq 10^6\)</span>，时空限制：2s 256M。</p>
<a id="more"></a>
<p><strong>样例</strong></p>
<p>输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>解释：有以下八种二元组的搭配方式，以及其相应的 <span class="math inline">\(rk\)</span> 序列。</p>
<p><span class="math inline">\((1,1),(2,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((1,1),(2,2),(3,3)\ \ \ \ rk:3,2,1\)</span></p>
<p><span class="math inline">\((1,1),(3,2),(2,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((1,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p>
<p><span class="math inline">\((2,1),(2,2),(2,3)\ \ \ \ rk:1,2,3\)</span></p>
<p><span class="math inline">\((2,1),(2,2),(3,3)\ \ \ \ rk:2,3,1\)</span></p>
<p><span class="math inline">\((2,1),(3,2),(2,3)\ \ \ \ rk:2,1,3\)</span></p>
<p><span class="math inline">\((2,1),(3,2),(3,3)\ \ \ \ rk:3,1,2\)</span></p>
<p>不同的 <span class="math inline">\(rk\)</span> 序列一共有 <span class="math inline">\(5\)</span> 个。</p>
<p><strong>题解</strong></p>
<p>比赛的时候一直认为是一个组合数学题目，没想到是一个 DP。</p>
<p>先下一个定义：若两个由前 <span class="math inline">\(i-1\)</span> 个二元组形成的序列，无论 <span class="math inline">\([i,n]\)</span> 中的每个二元组是 <span class="math inline">\((a_x,x)\)</span> 还是 <span class="math inline">\((a_x+1,x)\)</span>，这两个序列最终形成的排名序列都是相同的，那么我们把它们称作<strong>不可区分</strong>的。</p>
<p>首先把所有二元组按照 <span class="math inline">\((a_i,i)\)</span> 排序。为了方便，下文默认输入就已经保证了 <span class="math inline">\((a_i,i)&lt;(a_{i+1},i+1)\)</span>。</p>
<p>考虑 DP，设 <span class="math inline">\(f_i\)</span> 表示前 <span class="math inline">\(i-1\)</span> 个二元组组成的<strong>可区分</strong>的序列个数。</p>
<p>那么第 <span class="math inline">\(i\)</span> 个位置既可以放 <span class="math inline">\((a_i,i)\)</span> 也可以放 <span class="math inline">\((a_i+1,i)\)</span>，所以有 <span class="math inline">\(f_{i+1}=2f_i\)</span>，但是这样显然会算重，所以考虑容斥。</p>
<p>考虑对于一个位置 <span class="math inline">\(i\)</span>，找到一个极短的区间 <span class="math inline">\([l,r](l\leq i\leq r)\)</span>，它需要满足存在一种在 <span class="math inline">\([l,i-1],[i+1,r]\)</span> 放置二元组的方案，使得第 <span class="math inline">\(i\)</span> 个位置放 <span class="math inline">\((a_i,i)\)</span> 和放 <span class="math inline">\((a_i+1,i)\)</span> 是<strong>不可区分</strong>的。这样的话，这种放置方法的贡献本来只有 <span class="math inline">\(1\)</span> 但是被算了两次，所以 <span class="math inline">\(f_r\)</span> 就需要减去 <span class="math inline">\(f_l\)</span>。</p>
<p>因为这个区间是极短的，所以可以恰好不重不漏地把所有的不合法的方案都减掉，最终的 <span class="math inline">\(f_{n+1}\)</span> 即为答案。</p>
<p>不难发现，因为我们一开始排好了序，所以 <span class="math inline">\(l,r\)</span> 是单调递增的，<span class="math inline">\(i\)</span> 也是我们单调枚举的，所以 DP 的总复杂度是 <span class="math inline">\(O(n)\)</span> 的。（有趣的是，复杂度的瓶颈在于排序）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1000000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? EOF : *(p1++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">n</span>) &#123;</span></span><br><span class="line">    n = <span class="number">0</span>; RI ch = gc(), f;</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) ch = gc();</span><br><span class="line">    f = (ch == <span class="string">&#x27;-&#x27;</span> ? ch = gc(), <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) n = n * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = gc();</span><br><span class="line">    n *= f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> Of[<span class="number">105</span>], *O1 = Of, *O2 = Of;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">n</span>, <span class="title">char</span> <span class="title">ch</span> = &#x27;\<span class="title">n</span>&#x27;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), n = -n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n) *(O1++) = (n % <span class="number">10</span>) ^ <span class="number">48</span>, n /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (O1 != O2) <span class="built_in">putchar</span>(*(--O1));</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IO :: read;</span><br><span class="line"><span class="keyword">using</span> IO :: print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> MAXN = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, id;</span><br><span class="line">  Node (<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _id = <span class="number">0</span>) &#123; x = _x, id = _id; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x ^ A.x ? x &gt; A.x : id &lt; A.id; &#125;;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n; read(n);</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(a[i].x), a[i].id = i;</span><br><span class="line">  sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; i &amp;&amp; (Node(a[l].x, a[l].id) &lt; Node(a[i].x + <span class="number">1</span>, a[i].id))) ++l;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n &amp;&amp; (Node(a[r].x + <span class="number">1</span>, a[r].id) &lt; Node(a[i].x, a[i].id))) ++r;</span><br><span class="line">    f[r] = (f[r] + mod - f[l]) % mod;</span><br><span class="line">    f[i + <span class="number">1</span>] = ((f[i] + f[i]) % mod + f[i + <span class="number">1</span>]) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  print(f[n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>妙题</tag>
      </tags>
  </entry>
  <entry>
    <title>用二进制模拟 K 进制</title>
    <url>/2020/11/11/%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E6%8B%9F-K-%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<p>被个三进制下位运算题搞自闭了，琢磨了好久才有了一个看似贼简单的做法，故记录一下。</p>
<a id="more"></a>
<p>先考虑怎么用二进制模拟三进制。</p>
<p>用 <span class="math inline">\(01\)</span> 串 <span class="math inline">\(s_0,s_1,s_2\)</span> 依次表示某数在三进制下，数位为 <span class="math inline">\(0,1,2\)</span> 的位的集合。</p>
<p>不难发现 <span class="math inline">\(s_0,s_1,s_2\)</span> 两两无交。</p>
<p>那么对于两个数的三进制下位运算，就可以通过枚举两数的 <span class="math inline">\(s_0,s_1,s_2\)</span>，得到两数在三进制下数位为 <span class="math inline">\(0,1,2,3,4\)</span> 的位的集合。且这些集合也两两无交。</p>
<p>之后再通过位运算的定义，把五个集合重新整理成新的 <span class="math inline">\(s_0,s_1,s_2\)</span>。</p>
<p>复杂度是 <span class="math inline">\(O(9)\)</span> 的（因为需要枚举 <span class="math inline">\(s_0,s_1,s_2\)</span>）。</p>
<p>类似的，这种做法也可以推广到 K 进制下，复杂度是 <span class="math inline">\(O(K^2)\)</span> 的。</p>
]]></content>
      <tags>
        <tag>数位</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数优化矩阵快速幂</title>
    <url>/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>如果我们需要求维度为 <span class="math inline">\(c\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 次幂，那么一个显然的方法是用快速幂，复杂度为 <span class="math inline">\(c^3 \log m\)</span>。不过当需要用到高精度的时候，该算法速度会大大下降。</p>
<p>考虑这么一个事情，<a id="more"></a> 如果可以找到一个矩阵 <span class="math inline">\(C\)</span> 和一个对角矩阵 <span class="math inline">\(P\)</span>（只有主对角线上的值不为 <span class="math inline">\(0\)</span>），使得 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>，那么 <span class="math inline">\(A^m=C\times P \times C^{-1} \times C \times P \times C^{-1}...\)</span>，不断的使用结合率，就可以得到 <span class="math inline">\(C \times P^m \times C^{-1}\)</span>。因为 <span class="math inline">\(P\)</span> 是对角矩阵，那么 <span class="math inline">\(P^m\)</span> 本质上只要对 <span class="math inline">\(P\)</span> 中的每个值跑一个实数的快速幂。这样就可以把复杂度优化到 <span class="math inline">\(c^3+c\log n\)</span>，即实数的快速幂和两次矩阵乘法。</p>
<p>现在的问题就是怎么得到一个合法的 <span class="math inline">\(C\)</span>。</p>
<p>引入两个概念：特征值和特征向量。</p>
<p>一个数 <span class="math inline">\(\lambda\)</span> 是矩阵 <span class="math inline">\(A\)</span> 的特征值，当且仅当存在一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>，使得 <span class="math inline">\(A\times B=\lambda B\)</span>，我们把这个向量 <span class="math inline">\(B\)</span> 称作特征向量。需要注意的是，对于同一个 <span class="math inline">\(\lambda\)</span>，<span class="math inline">\(B\)</span> 可能不止一个。</p>
<p>如果我们求出了一组特征值 <span class="math inline">\(\lambda_1,\lambda_2...\lambda_c\)</span>，以及对应的特征向量 <span class="math inline">\(B_1,B_2...B_c\)</span>，那么就有 <span class="math inline">\(A\times [B_1,B_2...B_c]=[\lambda_1\cdot B_1,\lambda_2\cdot B_2...\lambda_c\cdot B_c]\)</span>，设 <span class="math inline">\(C=[B_1,B_2...B_c]\)</span>，右乘一个对角矩阵相当于每一列 <span class="math inline">\(i\)</span> 乘上一个对角阵中的元素 <span class="math inline">\(a_{i,i}\)</span>，所以可以构造对角矩阵 <span class="math inline">\(P=\begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots&amp;0\\ 0 &amp; \lambda_2 &amp; \cdots&amp;0\\ \vdots &amp; \vdots&amp;\ddots&amp;\vdots \\ 0&amp;\cdots&amp;0&amp;\lambda_c\end{bmatrix}\)</span>，就可以得到 <span class="math inline">\(A\times C=C\times P\Leftrightarrow A=C\times P\times C^{-1}\)</span> 。</p>
<p>考虑怎么求特征值，因为 <span class="math inline">\(A\times B=\lambda B\)</span> 那么就有 <span class="math inline">\(\lambda B-A\times B=0\)</span>，所以 <span class="math inline">\((\lambda I-A)\times B=0\)</span>，因为 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span>，所以必须有 <span class="math inline">\(\det(\lambda I-A)=0\)</span>，那么可以通过行列式列方程求得 <span class="math inline">\(\lambda\)</span>。</p>
<p>考虑使用反证法证明 <span class="math inline">\(\det(\lambda I-A)=0\)</span>。设 <span class="math inline">\(G=\lambda I-A\)</span>，那么如果 <span class="math inline">\(\det(G)\not=0\)</span>，那么如果把 <span class="math inline">\(G\)</span> 看作是一个方程组的系数矩阵，<span class="math inline">\(B\)</span> 为未知数，那么 <span class="math inline">\(B\)</span> 将会是唯一的。而因为等式右边等于 <span class="math inline">\(0\)</span> ，所以无论如何用高斯消元，最后总会有 <span class="math inline">\(B_c=0\)</span>，那么一直往回迭代就会得到一个全 <span class="math inline">\(0\)</span> 向量，与 <span class="math inline">\(B\)</span> 向量非 <span class="math inline">\(0\)</span> 冲突。而如果 <span class="math inline">\(det(G)=0\)</span>，那么 <span class="math inline">\(G\)</span> 至少有一个自由元，那么就可以通过自由元，得到至少一个非 <span class="math inline">\(0\)</span> 向量 <span class="math inline">\(B\)</span>。</p>
<p>由此我们就可以求出所有的特征值，对于某个特征值，把它带回矩阵，通过初等矩阵的行变换把它变成一个最简形式，然后把自由元带入任意一个值（一般为 <span class="math inline">\(1\)</span>）就可以得到一个特征向量 <span class="math inline">\(B\)</span>（当然对于任意的 <span class="math inline">\(k\cdot B,k\not=0\)</span> 都是符合要求的）。</p>
<p>至此就可以得到所有的特征值及其对应的特征向量。那么就可以得到矩阵 <span class="math inline">\(C\)</span>，求个逆就可以得到 <span class="math inline">\(C^{-1}\)</span>（消元可以用辗转相除法，就可以避免求逆元），就可以用上述做法优化了。</p>
<p>下面就举个栗子，用此方法得到斐波那契数列的通项公式。</p>
<p>众所周知，斐波那契数列的递推矩阵是 <span class="math inline">\(A=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\ \end{bmatrix}\)</span> 。</p>
<p>先求出该矩阵的特征值，设其为 <span class="math inline">\(\lambda\)</span>，根据定义，有 <span class="math inline">\(\det \left ( \begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \right) = 0\)</span> ，所以 <span class="math inline">\((\lambda-1)\times \lambda-1=0\)</span>，解出 <span class="math inline">\(\lambda=\frac{1\pm\sqrt{5}}{2}\)</span> 。</p>
<p>再根据定理，列出方程 <span class="math inline">\(\begin{bmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \\ \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ \end{bmatrix}=\begin{bmatrix} 0 \\ 0 \\ \end{bmatrix}\)</span> 可以解出两个特征向量 <span class="math inline">\(\lambda_1=\frac{1-\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_1=\begin{bmatrix} 1 \\ \frac{-1-\sqrt{5}}{2} \\ \end{bmatrix}\)</span>，<span class="math inline">\(\lambda_2=\frac{1+\sqrt{5}}{2}\)</span> 对应 <span class="math inline">\(B_2=\begin{bmatrix} 1 \\ \frac{-1+\sqrt{5}}{2} \\ \end{bmatrix}\)</span> 。那么根据定义，设 <span class="math inline">\(C=[B_1,B_2]\)</span>，构造对角阵 $P=\begin{bmatrix} _1 &amp; 0 \ 0 &amp; _2 \ \end{bmatrix} $，就可以得到 <span class="math inline">\(A\times C=C\times P\)</span>，所以有 <span class="math inline">\(A=C\times P \times C^{-1}\)</span>。故 <span class="math inline">\(A^m=C\times P^m \times C^{-1}\)</span>。</p>
<p>通过手算可以求得 <span class="math inline">\(C^{-1}= \begin{bmatrix} 1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; -\frac{\sqrt{5}}{5} \\ \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; \frac{\sqrt{5}}{5} \\ \end{bmatrix}\)</span>。</p>
<p>对于斐波那契数列第 <span class="math inline">\(m\)</span> 项，即是 <span class="math inline">\(A^m\)</span> 的 <span class="math inline">\(a_{1,1}\)</span>。显然 <span class="math inline">\(P^m=\begin{bmatrix} (\frac{1-\sqrt{5}}{2})^m &amp; 0 \\ 0 &amp; (\frac{1+\sqrt{5}}{2})^m \ \end{bmatrix}\)</span> ，那么 <span class="math inline">\(C\times P^m \times C^{-1}\)</span> 的 <span class="math inline">\(a_{1,1}\)</span> 为 <span class="math inline">\((\frac{1-\sqrt{5}}{2})^m\times(1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5})+(\frac{1+\sqrt{5}}{2})^m\times \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5}\)</span>，整理之后就为 <span class="math inline">\(\frac{1}{\sqrt{5}}\left((\frac{1+\sqrt{5}}{2})^{m+1}-(\frac{1-\sqrt{5}}{2})^{m+1}\right)\)</span> ，即为斐波那契数列的通项公式。</p>
<p>因为出现了根号，所以整个过程看似比较麻烦，不过在递推矩阵满足一些性质的时候有较快的方法求特征值和特征向量（比如在整个矩阵是一个上/下三角矩阵时，特征值就是主对角线上的值，自由元就是项数变少了某行，设它为 <span class="math inline">\(1\)</span>，就可以在矩阵大小的复杂度内求得一个特征向量）。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基的瞎操作</title>
    <url>/2020/11/11/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E7%9E%8E%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="查找某个数可以被给出基底如何异或得到">1. 查找某个数可以被给出基底如何异或得到</h4>
<p>把基底做线性基，并且在线性基的同时维护线性基中每个元素是由哪些基底中的元素异或得到的，那么在查询的时候，把对应线性基的元素集合也一起异或，就可以得到最终所求。</p>
<h4 id="把基底的一个数与另一个数交换保证交换后基底仍然是基底">2. 把基底的一个数与另一个数交换，保证交换后基底仍然是基底</h4>
<p>同上，在线性基的同时维护线性基中每个元素是由哪些基底中的元素异或得到的。先查询交换的这个数怎么被基底表示，因为交换后基底仍然是基底，那么基底中被交换的数一定会被用来表示交换的这个数。所以被交换的数可以用基底中的数和交换的数一起表示，然后就直接去更新线性基中元素维护的集合即可。</p>
]]></content>
      <tags>
        <tag>数位</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
</search>
