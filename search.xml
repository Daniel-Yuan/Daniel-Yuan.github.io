<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF506E 题解</title>
    <url>/2020/09/17/CF506E-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>一道极 (e) 妙 (xin) 的自动机优化 DP 的题目。</p>
<p>先假设最后得到的字符串为 $T$，由题意易知 $T$ 合法当且仅当 $T$ 是回文串且 $S$ 是 $T$ 的一个子序列。</p>
<p>$T$ 是回文串的这个性质我们可以通过从外向内一个一个填字符来实现，所以我们需要 DP 的是 $S$ 相对于 $T$ 而言被匹配了多少个字符。</p>
<p>特别的，因为当 $T$ 的长度为奇数的时候，最后一次填的字符本质上是一个字符，需要特别处理，所以下面我们先讨论 $T$ 的长度为偶数的情况。</p>
<a id="more"></a>

<p>因为 $T$ 这个字符串是从外向内确定的，所以 $S$ 的匹配也是从外向内的，故可以设 $f_{i,l,r}$ 表示考虑 $T$ 的前后 $i$ 个字符，当前 $S$ 还剩下 $[l,r]$ 没有匹配到的方案数。</p>
<p>考虑转移，假设当前有 $s[l] = s[r]$，那么如果当前填的字符是 $s[l]$，就可以转移到 $f_{i+1,l+1,r-1}$，如果当前填的字符不是 $s[l]$，就可以转移到 $f_{i+1,l,r}$，转移系数为 $25$。</p>
<p>假设当前 $s[l] \not= s[r]$，那么如果当前填的字符是 $s[l]$，就可以转移到 $f_{i+1,l+1,r}$，如果当前填的字符是 $s[r]$，就可以转移到 $f_{i+1,l,r-1}$，如果当前填的字符不是两者，就可以转移到 $f_{i+1,l,r}$，转移系数为 $24$。</p>
<p>需要注意的是，对于所有的 $f_{i,l,r}(l&gt;r)$，因为 $(l&gt;r)$，也就是说 $S$ 已经被匹配完，所以无论填什么字符都没关系，那么它们就可以转移到 $f_{i+1,l,r}$，转移系数为 $26$。</p>
<p>这样我们便有了一个 $n\times |S|^2$ 的 DP，如果把后面的状态强行剥离就可以做到 $|S|^6\log n$，似乎并没有什么用。</p>
<p>考虑优化这个 DP，我们把这个 DP 的转移用一张图来表示，对于 $S=abab$，转移图是这样的：</p>
<p><img src="https://s1.ax1x.com/2020/09/17/wftvp6.png" alt="wftvp6.png"></p>
<p>其中下划线是已经匹配的部分，在 $i$ 行 $j$ 列的椭圆表示 $f_{x,i,j}$，我们把所有的 $l&gt;r$ 的状态归到一个状态里面去，就有了如上的转移图。一个合法的方案本质上就是从 $abab$ 走 $n+|S|$ 步到 ____​ 的一条路径。</p>
<p>我们把某条路径上面的所有节点拿出来，并且按照 $s[l]$ 是否等于 $s[r]$ 分类成两种点，可以发现，无论这两种点的排列如何，当这两种点的数量确定的时候，答案已经确定了。</p>
<p>设 $s[l]=s[r]$ 的点为 $0$ 类点，$s[l]\not=s[r]$ 的点为 $1$ 类点，不难发现在某条路径上确定了 $1$ 类点的数目后，可以直接计算得到一个唯一的 $0$ 类点的数目，而 $1$ 类点的数目的取值范围为 $[0,len-1]$，所以总共不同的路径数最多只有 $|S|$ 条。</p>
<p>考虑有多少种方案经过某条路径，设 $g_{x,l,r}$ 表示在区间 $[l,r]$ 的这段转移中，总共经过 $x$ 个 $1$ 类点的方案数，用记忆化搜索即可求得，我们需要的就是 $g_{x,1,|S|}$。这部分复杂度 $|S|^3$。</p>
<p>在一条路径上面 DP 的复杂度是 $|S|\times n$，通过矩阵优化可以优化到 $|S|^3\times \log n$，总复杂度即 $|S|^4\log n$，虽然仍然过不了，但是优化了很多。</p>
<p>我们设起点为 $S$， $0$ 类点为黑色，$1$ 类点为白色，终点为 $T$，上述过程中的转移图差不多是这样：</p>
<p><img src="https://s1.ax1x.com/2020/09/18/w4aqtH.png" alt="w4aqtH.png"></p>
<p>考虑继续优化，上述算法问题就出在我们对每种路径都跑了一次 DP，考虑把它们合并成一次。先规定所有的路径$0$ 类点都在前面，$1$ 类点都在后面。然后在新的转移图上把第一行放上 $0$ 类点，第二行放上 $1$ 类点，在第一行的点之间连边，第二行的点之间连边，现在就考虑怎么在第一行的点和第二行的点之间连边，不难发现，这种连边实质上代表了一种路径，因为这种边只能走一次，且走这种边就可以确定经过的 $0$ 类点和 $1$ 类点的数目，这样的话复杂度就优化到了 $|S|^3\log n$。</p>
<p>把上图按照这种优化连边之后的图就是这样：</p>
<p><img src="https://s1.ax1x.com/2020/09/18/w4d83R.png" alt="w4d83R.png"></p>
<p>其中从第一行的点到第二行的点的转移系数为有多少种方案经过这种路径，即 $g_{x,l,r}$。可以发现这样转化之后只有 $\frac{3}{2}|S|$ 个点，且因为转移图是 DAG 图，所以可以通过编号使得转移都是从编号小的点转移到编号大的点，这样可以得到一个比较优秀的常数优化。复杂度 $|S|^3\log n$。</p>
<p>最后还需要考虑一下 $|T|$ 为奇数。我们先把 $|T|$ 的长度看做 $|T|+1$ ，这样就可以得到一个答案。考虑有多少种方案不合法，可以发现是所有最后一步是放两个字符，且恰好在最后一次转移的时候放的方案，我们把这种方案算出来减掉即可。具体的，把所有最后一步是放两个字符的路径拿出来，然后去掉终点的自环再跑一遍上述 DP，这次求出来的答案就是要减掉的方案。</p>
<p>至此便可完美解决此题。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RI register int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEIO(name) freopen(name<span class="meta-string">&quot;.in&quot;</span>, <span class="meta-string">&quot;r&quot;</span>, stdin), freopen(name<span class="meta-string">&quot;.out&quot;</span>, <span class="meta-string">&quot;w&quot;</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">  Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;A) &#123;</span><br><span class="line">    Matrix re;</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">      <span class="keyword">for</span> (RI j = i; j &lt;= lim; ++j) &#123;</span><br><span class="line">        re.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (RI k = i; k &lt;= j; ++k)</span><br><span class="line">          re.a[i][j] = (re.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; F;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Matpow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  Matrix re;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">    <span class="keyword">for</span> (RI j = <span class="number">1</span>; j &lt;= lim; ++j)</span><br><span class="line">      re.a[i][j] = (i == j);</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, a = a * a)</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) re = re * a;</span><br><span class="line">  <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> x == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (f[x][l][r] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">  <span class="keyword">if</span> (s[l] == s[r])</span><br><span class="line">    f[x][l][r] = DP(x, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f[x][l][r] = (DP(x - <span class="number">1</span>, l + <span class="number">1</span>, r) + DP(x - <span class="number">1</span>, l, r - <span class="number">1</span>)) % mod;</span><br><span class="line">  <span class="keyword">return</span> f[x][l][r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  FILEIO(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">int</span> n, len;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; n;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  lim = len + (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">    F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">    F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">    F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  F.a[lim][lim] = <span class="number">26</span>;</span><br><span class="line">  F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">    ans = F.a[<span class="number">1</span>][lim];</span><br><span class="line">  ans = (ans + F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod) % mod;</span><br><span class="line">  <span class="keyword">if</span> ((n + len) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(F.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(F.a));</span><br><span class="line">    <span class="keyword">for</span> (RI i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">24</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = (i != len - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (!((len - i) &amp; <span class="number">1</span>))</span><br><span class="line">        F.a[i][lim - (len - i + <span class="number">1</span>) / <span class="number">2</span>] = DP(i, <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (RI i = len; i &lt; lim; ++i) &#123;</span><br><span class="line">      F.a[i][i] = <span class="number">25</span>;</span><br><span class="line">      F.a[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F = Matpow(F, (n + len + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (len != <span class="number">1</span>)</span><br><span class="line">      ans = (ans - F.a[<span class="number">1</span>][lim] + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!(len &amp; <span class="number">1</span>))</span><br><span class="line">      ans = (ans - F.a[len][lim] * DP(<span class="number">0</span>, <span class="number">1</span>, len) % mod + mod) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// created by Daniel yuan</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     ________</span></span><br><span class="line"><span class="comment">    /        \</span></span><br><span class="line"><span class="comment">   / /      \ \</span></span><br><span class="line"><span class="comment">  / /        \ \</span></span><br><span class="line"><span class="comment">  \            /</span></span><br><span class="line"><span class="comment">   \  ______  /</span></span><br><span class="line"><span class="comment">    \________/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>DP</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2019 游记</title>
    <url>/2019/11/16/CSP-S%202019%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离十一月十六日只不足几天，CSP 的审判快要降临了罢，我正有写一点东西的必要了。（雾</p>
<a id="more"></a>

<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>教练组织高二的学长出去玩去了，苦逼的我还要接着考 CSP 信(zi)心(bi)赛。/羡慕</p>
<p>配 <code>emacs</code> 的时候突然忘记 <code>default</code> 怎么写了，一直认为最后两个字母是 <code>te</code> 。最后还是靠着 <code>switch</code> 的高亮打出来的（CSP 前犯这种错误我怕不是要爆零）</p>
<p>晚上 U 盘坏了，捣鼓了一晚上。</p>
<p>考前 RP 突然爆炸，感觉吃枣药丸（怕不是 CSP-S RP++ 爆负了……）</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>上午写了一个线性基板子，一个矩阵快速幂板子，一个 <code>Miller-Rabin</code> 板子。</p>
<p>之后就欢快地颓了一下午加一晚上。<del>（某乎：如何看待某巨佬 AK CSP-S）</del></p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>在一阵互相膜拜之后进入了考场。</p>
<p>座位之间有隔板 <del>考试前还在讨论如何用毒瘤码风祸害周围同学</del>，键盘敲起来特别舒服，值得一提的是，<code>Emacs</code> 有配置文件！<del>好评</del>。</p>
<p>开考后 10 分钟就把 T1 切了。</p>
<p>T2 像极了考前的一道 <del>九条可怜</del> 的括号匹配题，几分钟码了个 <code>Trie</code> 树就过样例了，然而那个题<strong>忽略括号方向</strong> <del>我给忘了QAQ</del>。</p>
<p>然后 T3 看上去很玄学的样子，开始手玩，结果手玩不动样例……<del>还不如暴搜</del></p>
<p>闲的没事就给 T2 写了个对拍，一组就错……</p>
<p>发现了那个小错误后重新思考做法，发现还是可以用栈的思想，在每次加入或删除一个节点的时候计算贡献，过了样例后接着拍，还是炸了，不过 <del>它已经被我优化到拍几百组错一组了</del>。</p>
<p>接着调，发现是个小错误，调完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几千组错一组了</del>。</p>
<p>接着调，又发现个小错误，跳完后 <del>又过了样例</del>，接着拍，还是炸了，不过 <del>它已经被我优化到拍几万组错一组了</del>。</p>
<p>当我百思不得其解时，已经 10:50了 QAQ。</p>
<p>当我气的去打完 T3 搜索并且想了一下特殊数据后，已经 11:20 了。</p>
<p>当我感慨造化弄人，以为要命绝于此，要被这次 <code>CSP</code> 送退役时，发现：<strong>我 ** <code>vector</code> 访问了非法内存 ？？？</strong> 。</p>
<p>改完之后拍几万组都没有问题，不过这次考试也因为 T2 止步 210 了……</p>
<p>又欢乐地颓了一下午加一晚上。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>昨天颓太欢乐了，今早莫名的困……</p>
<p>感觉今天心态都不一样了……昨天想着怎么拿高分怎么 AK，今天就只想着多拿点分 <del>（还是不能给我这种蒟蒻太高的期望）</del></p>
<p>开场就写了一个 T1 的 $n^2m$ 的做法，后来发现它假了，只能补上一维保证正确性，最后打了个 $n^3m$ 的 <code>DP</code>。</p>
<p>然后写 T2，一开始写了一个 $n^3$ 的<code>DP</code>，并且理性分析发现可以优化到 $n^2$ 。经过人(bao)类(li)智(da)慧(biao)后，发现每个以每个点为终点的 <code>DP</code> 值有且仅有一个有用，于是可以使用单调队列优化做到 $O(n)$ ，<del>但是为啥我压 8 位高精都可以MLE，只能过 type=0</del></p>
<p>最后写 T3，发现暴力分出奇地高，于是写完暴搜后就找特殊数据的规律，<del>还真被我找到了</del>，又骗了一大波分。</p>
<p>一道题都没切预计都比昨天高……<del>我 ** 昨天在干嘛</del>。</p>
<h2 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h2><p>210 + 247 = 457……没能完成教练定的500分目标<del>AFO AFO</del>……</p>
<p>趁还没有退役先把游记码了……<del>AFO了就没机会了</del></p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Daniel_yuan&#39;s New Blog</title>
    <url>/2020/09/15/Daniel-yuan-s-New-Blog/</url>
    <content><![CDATA[<p>这是 Daniel_yuan 的新博客。</p>
]]></content>
  </entry>
  <entry>
    <title>PAM 学习笔记</title>
    <url>/2020/09/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>PAM (Palindrome Automaton) 是一种处理回文串的、针对某个串的自动机，它保存了该串所有回文串的信息。</p>
<p>PAM 需要维护三个基础的东西：点、转移边、fail 边。PAM 和 AC 自动机类似，所以我们可以借鉴 AC 自动机来理解这些东西。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="left"></th>
<th>AC 自动机</th>
<th>PAM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>一个前缀</td>
<td>一个回文串</td>
</tr>
<tr>
<td align="left">转移边</td>
<td>从起点走到终点，相当于在起点的字符串后面加上一个字符</td>
<td>从起点走到终点，相当于在起点的字符串两侧都加上一个字符</td>
</tr>
<tr>
<td align="left">fail 边</td>
<td>存在的最长后缀</td>
<td>存在的最长回文后缀</td>
</tr>
</tbody></table>
<p>但是，PAM 有一个 AC 自动机不具有的性质——它有两个根！因为可以发现走转移边并不会改变回文串长度的奇偶性，这样的话就保存不了所有的回文串了，所以我们需要两个根，一个叫做奇根，还有一个叫做偶根，这样才能维护所有的回文串。</p>
<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>定义完了那就看看怎么构造它。这里我们使用增量法。</p>
<p>为了方便，我们给每个点定义一个结构体，存当前点的信息，这里我们就维护三个信息：当前回文串的长度、转移边、fail 边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> son[<span class="number">26</span>], fail;</span><br><span class="line">&#125; t[MAXN];</span><br></pre></td></tr></table></figure>

<p>先看看怎么初始化，显然我们要先定义两个根。对于奇根，它的长度为 <code>-1</code> （可以把在它两侧加一个字符，当做它会吃掉一个字符），它一开始没有儿子，它的 fail 边随便指（因为它的两侧一定可以加字符）。对于偶根，它的长度为 <code>0</code> （可以看成是空串），它一开始没有儿子，它的 fail 边指向奇根，因为它两侧不能加字符的话，就只能丢给奇根了。即：（<code>0</code> 号节点是偶根，<code>1</code> 号节点是奇根）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">0</span>].len = <span class="number">0</span>; t[<span class="number">1</span>].len = <span class="number">-1</span>;</span><br><span class="line">t[<span class="number">1</span>].fail = t[<span class="number">0</span>].fail = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>假设上一次加入的点是 <code>last</code> ，现在需要新增一个字符 <code>ch</code>，假设它存储在 <code>s[pos]</code>。</p>
<p>首先我们需要找到一个 <code>last</code> 所代表串的一个最长后缀，使得可以在这个后缀后面加上 <code>ch</code>，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfail</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (s[pos] != s[pos - t[last].len - <span class="number">1</span>])</span><br><span class="line">    last = t[last].fail;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这个最长后缀所在的点记作 <code>cur</code>，然后接下来就看 <code>cur</code> 节点有没有 <code>ch</code> 这个儿子，如果有就直接跳过，把 <code>last</code> 设为这个儿子，否则就新增一个节点，记为 <code>nxt</code>。</p>
<p>对于 <code>nxt</code>，它的长度是 <code>cur</code> 的长度 <code>+2</code> （根据转移边的定义）。它的 fail 的寻找和 AC 自动机很像，是在 <code>cur</code> 的 <code>fail</code> 中再找到一个最长的有 <code>ch</code> 这个字符的儿子的后缀，然后把 <code>nxt</code> 的 fail 指向那个后缀的 <code>ch</code> 儿子。最后再把 <code>cur</code> 的 <code>ch</code> 儿子设为 <code>nxt</code>。具体实现如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nxt = ++cnt;</span><br><span class="line">t[nxt].len = t[cur].len + <span class="number">2</span>;</span><br><span class="line">t[nxt].fail = t[Getfail(t[cur].fail, pos)].son[s[pos] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">t[cur].son[s[pos] - <span class="string">&#x27;a&#x27;</span>] = nxt;</span><br></pre></td></tr></table></figure>

<p>最后也需要让 <code>last</code> 等于 <code>nxt</code> 。</p>
<p>这样就可以把 PAM 构造出来，复杂度是 $O(n)$ 的，因为每次跳 fail 会让当前串的长度至少减 <code>2</code>，而加入一个字符只会让当前串的长度加 <code>2</code>，所以跳 fail 的次数是有保障的。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>PAM 可以处理很多有关回文串的信息，具体在此就不展开了。实际上我们可以把 AC 自动机或是 SAM 的那些套路拿到 PAM 上来用，具体的怎么做还是得要进行实践。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>做多项式题的一点小技巧</title>
    <url>/2020/09/26/%E5%81%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>有一类多项式题，十分考验选手的推式子能力，真正的代码部分仅仅只是几个模板拼凑在一起。这类题目如果出现，往往会造成比较大的分差，所以在此略微归纳一下这类题目的做法。大致如下：</p>
<a id="more"></a>

<p>两个主要思想：在解多项式方程的时候，把多项式当做数看，在允许的情况下，可以等式两边同时加减乘除一个多项式；部分题目的多项式可能是无穷项的，在这种情况下，可能会出现把原多项式经过一些操作之后得到自身。</p>
<p>两个主要套路：一个是先想出一个 DP 的做法，然后根据 DP 转移的特性，发现其卷积的性质并把卷积部分弄成多项式，之后直接卷积加速，或者通过解方程的方式求答案；另一个是直接设求解的东西为一个多项式，然后根据其性质使其可以从自己转移到自己，然后解方程。</p>
<p>具体如何使用请看下面两个题目的题解。</p>
<hr>
<h4 id="集训队作业2013-城市规划-题解"><a href="#集训队作业2013-城市规划-题解" class="headerlink" title="[集训队作业2013]城市规划 题解"></a>[集训队作业2013]城市规划 题解</h4><p><strong>题意简述：</strong>求 $n$ 个点无重边无自环有标号无向连通图数目。$n\leq 10^5$。</p>
<p><strong>题解：</strong>我们设 $f(i)$ 表示 $i$ 个节点的答案，直接求并不好求，但是我们可以很容易的得到 $n$ 个点的图的数量，即 $2^{C_n^2}$ ，考虑怎么用 $f$ 来表示它。</p>
<p>$1$ 号节点最终一定会有一个连通块，考虑枚举这个连通块的大小，于是就有 $2^{C_n^2}=\sum_{i=1}^nC_{n-1}^{i-1}f(i)2^{C_{n-i}^2}$。也就是 $i$ 个点形成一个连通块，剩下的点随意连边。</p>
<p>为了方便，设 $g(i)=2^{C_i^2}$，原式子就变成了 $g(n)=\sum_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)$。</p>
<p>把组合数拆开，移项得 $\frac{g(n)}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{g(n-i)}{(n-i)!}$，设 $F(i)=\frac{f(i)}{(i-1)!}$，$G(i)=\frac{g(i)}{i!}$，后面的求和就是一个卷积的形式，即 $F\times G$。</p>
<p>把等式左边也稍加整理一下，就有 $nG(n)=(F\times G)(n)$。</p>
<p>我们定义多项式的点乘为对应项相乘，再设 $H(i)=i$，那么就有 $(H\cdot G)(n)=(F\times G)(n)$，即 $H\cdot G=F\times G$。</p>
<p>又因为 $G$ 的常数项为 $1$，故 $G$ 存在逆元，所以可以两边同时卷上 $G^{-1}$。于是就有 $F=(H\cdot G)\times G^{-1}$，写个多项式求逆就可以得到 $F$ 了。时间复杂度 $O(n\log n)$。</p>
<hr>
<h3 id="CF438E-The-Child-and-Binary-Tree-题解"><a href="#CF438E-The-Child-and-Binary-Tree-题解" class="headerlink" title="CF438E The Child and Binary Tree 题解"></a>CF438E The Child and Binary Tree 题解</h3><p><strong>题意简述：</strong> 有无数个点，每个点的权值可以是给出集合 $S$ 中的任意一个，定义一棵树的权值是所有点的权值和，求有多少棵节点数目任意的、形态不同的、权值为 $val$ 的二叉树。对于每个 $val\leq k$ 都需要求解。$k,|S|\leq 10^5$。</p>
<p>题解：直接设多项式 $f$ 为答案多项式，其中 $f(i)$ 表示 $val=i$ 的方案数。特别的，$f(0)=1$。现在考虑 $f$ 怎么求。</p>
<p>设 $g(i)$ 表示一个点的权值为 $i$ 的方案数，显然 $i\in S$ 则 $g(i)=1$，反之 $g(i)=0$。</p>
<p>那么对于当前的，它左儿子的方案数是 $f$，右儿子的方案数是 $f$，它自己的方案数是 $g$，而这个问题把解集合并就相当于是一个背包，那么就有 $f=f\times f\times g+1$，这个加一是指当前这个点的子树为空。</p>
<p>之后把 $f$ 当做未知数解方程，根据求根公式，有 $f=\frac{1\pm\sqrt{1-4g}}{2g}$，现在需要考虑正负取正还是负。</p>
<p>我们可以这么分析，当 $g$ 趋近于 $0$ 也就是 $|S|$ 趋近于 $0$ 的时候，$f=\frac{1\pm1}{0}$，而此时方案数是为 $0$ 的，也就是 $f$ 为 $0$，那么就只能取负号，所以 $f=\frac{1-\sqrt{1-4g}}{2g}$。</p>
<p>$g$ 常数项不是 $1$，没有逆元，考虑把分子有理化。就有 $f=\frac{2}{1+\sqrt{1-4g}}$。多项式开根加个求逆即可。复杂度 $O(n\log n)$。</p>
<hr>
<p>上述题目，第一题用的是第一个 trick，第二题用的是第二个 trick，较好的体现了做多项式题目的技巧。且这两个题目十分经典，不失为练习多项式的好题。</p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀数组学习笔记</title>
    <url>/2020/09/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>老忘后缀数组咋写，写个东西记录下。</p>
<p>算法核心：因为后缀是在同一个串内的，要充分利用其它信息。</p>
<a id="more"></a>

<p>考虑倍增，即从小到大按照长度为 $2^k$ 的串进行排序。</p>
<p>先按照长度为 $1$ 的串排序，每个点有一个排名。</p>
<p>然后扩展到长度为 $2$，现在可以知道每个长度为 $2$ 的串前一半相对的排名和后一半相对的排名，那么显然是要先按前一半的排，如果相等再按后一半的排，用 pair 加快排可以做到 $n\log n$，但是不够。考虑使用基数排序，就可以做到 $n$ 。</p>
<p>再扩展到长度为 $4$ …… 总时间复杂度 $n\log n$。</p>
<p>光求这个没啥用，考虑求一个 height，表示排名为 i 的后缀和排名为 i-1 的最长公共前缀有多长。那么任意两个后缀的 LCP 就可以直接通过 RMQ 求。</p>
<p>考虑怎么求 height，设 h 表示第 i 串和排名恰好小于它 1 的串的最长公共前缀。那么有 $h[i]\ge h[i-1]+1$。如果 $h[i-1]\leq 1$，那么显然成立，否则 $h[i-1]\geq 2$，假设排名恰好小于第 i-1 串 1 的串是第 k 串，那么就有 $s[i-1,i-1+h[i-1])=s[k,k+h[i-1])$ 且 $s[i-1+h[i-1]]&gt;s[k+h[i-1]]$，那么 $s[i,i-1+h[i-1])=s[k+1,k+h[i-1])$，因为 $h[i-1]\geq 2$，那么这个区间不为空，又因为 $s[i-1+h[i-1]]&gt;s[k+h[i-1]]$，那么第 k+1 串的排名肯定是小于第 i 串的，而距离 i 越远 LCP 就越小，那么第 i 串和排名恰好小于它 1 的串的 LCP 至少为 $h[i-1]-1$ 。所以可以直接从小到大暴力枚举求。</p>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>关于莫比乌斯函数的一些小技巧</title>
    <url>/2020/09/26/%E5%85%B3%E4%BA%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>总结一些有关莫比乌斯函数的应用以及一些数论方面的东西。</p>
<a id="more"></a>

<h3 id="1-k-gcd-x-y-Leftrightarrow-k-x-text-and-k-y"><a href="#1-k-gcd-x-y-Leftrightarrow-k-x-text-and-k-y" class="headerlink" title="1. $k|\gcd(x,y) \Leftrightarrow k|x \text{ and } k|y$"></a>1. $k|\gcd(x,y) \Leftrightarrow k|x \text{ and } k|y$</h3><p>这个 trick 比较显然，不过还是小小的证明一下。</p>
<p>因为 $\gcd(x,y)$ 同时整除 $x,y$，所以满足左边一定满足右边。因为 $\gcd(x,y)$ 是最大公因数，如果满足右边而不满足左边，那么一定存在一个 $z$ 使得 $\gcd(x,y)\times z$ 也是 $x,y$ 的公因数，和最大公因数的定义矛盾。</p>
<p>因此，若有式子 $\sum_{x=1}^n\sum_{y=1}^m\sum_{k|\gcd(x,y)}\mu(k)$，后面的 $k|\gcd(x,y)$ 就可以换成 $k|x\text{ and }k|y$，这样的话就可以交换求和符号把 $k$ 提前了。</p>
<p>这个 trick 对于 $\gcd$ 内有多个元素同样有效。</p>
<h3 id="2-若要计算-f-gcd-x-y-，可以设-f-n-sum-d-n-g-d-来化简式子。"><a href="#2-若要计算-f-gcd-x-y-，可以设-f-n-sum-d-n-g-d-来化简式子。" class="headerlink" title="2. 若要计算 $f(\gcd(x,y))$，可以设 $f(n)=\sum_{d|n}g(d)$ 来化简式子。"></a>2. 若要计算 $f(\gcd(x,y))$，可以设 $f(n)=\sum_{d|n}g(d)$ 来化简式子。</h3><p>举个简单的例子，我们需要计算 $\sum_{x=1}^n\sum_{y=1}^m\gcd(i,j)$。</p>
<p>当然，这个并不典型，而且大多数人都会枚举 $\gcd$ 做，不过我们现在使用当前的这个 trick 来解决这个问题。</p>
<p>我们设 $f(n)=n$，且 $f(n)=\sum_{d|n}g(d)$，那么原式就变成了 $\sum_{x=1}^n\sum_{y=1}^m\sum_{d|\gcd(x,y)}g(d)$ 。然后就可以通过 trick 1 交换求和符号把 $d$ 提前了。而根据莫比乌斯反演，我们可以知道 $g(n)=\sum_{d|n}f(d)\mu(\frac{n}{d})$（在该例题中恰好是 $\mu*id=\varphi$），那么也可以很快地计算出 $g$。这样就通过这个 trick 达到了简化式子的效果，而且在一些情况下比直接枚举 $\gcd$ 再把式子化来化去简单。</p>
<p>同样的，这个 trick 对于 $\gcd$ 内有多个元素同样有效。</p>
<h3 id="3-设-d-x-为-x-的因子个数，那么-d-n-times-m-sum-x-n-sum-y-m-gcd-x-y-1-。"><a href="#3-设-d-x-为-x-的因子个数，那么-d-n-times-m-sum-x-n-sum-y-m-gcd-x-y-1-。" class="headerlink" title="3. 设 $d(x)$ 为 $x$ 的因子个数，那么 $d(n\times m)=\sum_{x|n}\sum_{y|m}[\gcd(x,y)=1]$。"></a>3. 设 $d(x)$ 为 $x$ 的因子个数，那么 $d(n\times m)=\sum_{x|n}\sum_{y|m}[\gcd(x,y)=1]$。</h3><p>可以发现，把所有合法的 $x,y$ 拿出来，然后列出所有的 $x\times \frac{m}{y}$，这就是所有 $n\times m$ 的因子。</p>
<p>肯定不能感性的就这么理解，考虑严谨一点点的证明。</p>
<p><strong>先证明每个因子一定存在一种方式可以得到。</strong></p>
<p>我们假设 $n=\prod p_i^{a_i},m=\prod p_i^{b_i}$，设某个 $n\times m$ 的因子 $d=\prod p_i^{c_i}$ 。对于 $d$ 的某个质因子及其次幂 $p_i^{c_i}$，以及对应的 $n,m$ 的质因子及其次幂 $p_i^{a_i},p_i^{b_i}$。分两种情况讨论。</p>
<ol>
<li>若 $c_i\leq b_i$，则使 $x$ 中 $p_i$ 的次幂为 $0$，$y$ 中 $p_i$ 的次幂为 $b_i-c_i$。这样在 $x\times \frac{m}{y}$ 中 $p_i$ 的次幂为 $(0)+(b_i-(b_i-c_i))=c_i$，且 $p_i$ 在 $\gcd$ 中的贡献为 $p_i^{\min(0,b_i-c_i)=0}=1$。</li>
<li>若 $c_i&gt;b_i$，又因为 $c_i\leq a_i+b_i$，所以 $c_i-b_i\leq a_i$，则使 $x$ 中 $p_i$ 的次幂为 $c_i-b_i$，$y$ 中 $p_i$ 的次幂为 $0$。这样在 $x\times \frac{m}{y}$ 中 $p_i$ 的次幂为 $(c_i-b_i)+(b_i-0)=c_i$。且 $p_i$ 在 $\gcd$ 中的贡献为 $p_i^{\min(c_i-b_i,0)=0}=1$</li>
</ol>
<p>这样的话，对于因子 $d$ 的每个 $p_i$ 都这么构造一下即可。</p>
<p><strong>再证明每个因子只能由这一种方式得到。</strong></p>
<p>根据上一部分的证明，不能发现这个性质其实是显然的。不过还是简要说一下。</p>
<p>对于上文的情况 1，若要使 $p_i$ 在 $\gcd$ 中的贡献为 $1$，而 $x$ 中 $p_i$ 的次幂 $\not=0$，那么 $y$ 中 $p_i$ 的次幂必须为 $0$，而此时 $x\times \frac{m}{y}$ 中 $p_i$ 的次幂最小为 $(1)+(b_i-0)=b_i+1&gt; b_i\geq c_i$，故构造不出 $c_i$。</p>
<p>对于上文的情况 2，若要使 $p_i$ 在 $\gcd$ 中的贡献为 $1$，而 $y$ 中 $p_i$ 的次幂 $\not=0$，那么 $x$ 中 $p_i$ 的次幂必须为 $0$，而此时 $x\times \frac{m}{y}$ 中 $p_i$ 的次幂最大为 $(0)+(b_i-1)=b_i-1&lt;b_i&lt;c_i$，故构造不出 $c_i$。</p>
<p>综上就可以证明这个 trick。</p>
<p>同样的，这个 trick 对于多个元素的乘积同样有效，即：</p>
<p>$d(\prod a_i)=\sum_{b_1|a_1}\sum_{b_2|a_2}…[\gcd(b_1,b_2)=1][\gcd(b_1,b_3)=1][\gcd(b_2,b_3)=1]…$。</p>
<h3 id="4-若求和式中出现枚举-x-y-且涉及到了-xy-时，大多数时候需要改变思路枚举-xy-。"><a href="#4-若求和式中出现枚举-x-y-且涉及到了-xy-时，大多数时候需要改变思路枚举-xy-。" class="headerlink" title="4. 若求和式中出现枚举 $x,y$ 且涉及到了 $xy$ 时，大多数时候需要改变思路枚举 $xy$。"></a>4. 若求和式中出现枚举 $x,y$ 且涉及到了 $xy$ 时，大多数时候需要改变思路枚举 $xy$。</h3><p>其实这个是一个十分普遍的小 trick。</p>
<p>还是用那个老到不能再老的例子举例，求 $\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)$。</p>
<p>我们来枚举 $\gcd$，然后变化一下就有 $\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)=1]$ 。根据常识，就有 $\sum_{d=1}^nd\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{n}{kd}\rfloor$，直接这么做就是 $n\log n$ 的，而且对于 $n$ 很大或者是多组询问不太好优化。</p>
<p>我们发现求和式中出现了 $d$，也出现了 $k$，同时涉及到了 $dk$，那么考虑设 $T=dk$，我们来枚举 $T$，就有 $\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{n}{T}\rfloor\sum_{k|T}\mu(k)\frac{T}{k}$。这样的话，有个求和变成了狄利克雷卷积，而一般来说卷出来的东西是积性函数。这样的话，前面的东西就可以用整数分块，而后面的东西可以线性筛预处理，或者使用亚线性筛直接求。这样大大加快了代码运行的时间。</p>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式学习笔记</title>
    <url>/2020/09/26/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h5><p>对于一个多项式 $\sum_{i=0}^{\infty}a_ix^i$，如果我们只关心它的各项系数 ${a_0,a_1…}$，而并不关心 $x$ 的值以及其收敛或发散的问题，就可以说其是关于 $x$ 的形式幂级数。</p>
<a id="more"></a>

<h5 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h5><p>对于一个已知的多项式 $F$，求一个多项式 $A$，使得 $F(A)=0$ 在模 $x^n$ 意义下成立，其中 $F,A$ 都是形式幂级数。</p>
<p>牛顿迭代是这样的，假设我们已经求得了在模 $x^{\frac{n}{2}}$ 下的解 $A_0$，那么可以把 $F(A)$ 在 $A_0$ 处泰勒展开，再模掉 $x^n$，就有 $F(A)=F(A_0)+F’(A_0)(A-A_0)$，然后就可以通过解方程求的在模 $x^n$ 意义下的 $A$。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><h5 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h5><p>就是多项式对应项相加减。即 $C_ix^i=(A_i+B_i)x^i$。复杂度 $O(n)$。</p>
<h5 id="乘法（卷积）"><a href="#乘法（卷积）" class="headerlink" title="乘法（卷积）"></a>乘法（卷积）</h5><p>多项式的乘法本质上是求 $C_ix^i=\sum_{j+k=i}A_jB_kx^i$。可以使用 FFT 或者 NTT 解决。复杂度 $O(n\log n)$。</p>
<h5 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h5><p>对于一个单项式 $kx^n$ 求导，其值是 $knx^{n-1}$，而对于多项式的求导，本质上是把各个单项式求导之后再加起来。即 $C_ix^i=(i+1)A_{i+1}x^i$。复杂度 $O(n)$。</p>
<p>有两个在多项式中常见的求导公式：$(\ln x)’=\frac{1}{x},(e^x)’=e^x$。</p>
<p>特别的，复合函数也可以求导，$(F(G))’=F’(G)\times G’$。</p>
<h5 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h5><p>积分是求导的逆运算，在求导中，有 $kx^n\rightarrow knx^{n-1}$，那么积分里面就有 $kx^n\rightarrow\frac{k}{n+1}x^{n+1}$ 。而对于多项式的积分，也是把各个单项式求导之后再加起来，即 $C_ix^i=\frac{A_{i-1}}{i}x^i$。复杂度 $O(n)$。</p>
<h5 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h5><p>对于一个 $n$ 次多项式 $A(x)=\sum_{i=0}^n a_ix^i$，将它变成 $\sum_{i=0}^n a_{n-i}x^i$，就称之为翻转，记作 $A^R(x)$，不难发现本质上 $A^R(x)=A(\frac{1}{x})\times x^n$。复杂度 $O(n)$。</p>
<h5 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h5><p>对于一个多项式 $A(x)$，求出一个多项式 $A^{-1}(x)$，使得 $A(x)\times A^{-1}(x)\equiv 0<del>(</del>{\rm mod}~x^{n})$。</p>
<p>考虑使用牛顿迭代，设 $B(x)=A^{-1}(x)$，那么就有 $\frac{1}{B(x)}-A(x)\equiv 0<del>(</del>{\rm mod}<del>x^{n})$ 。假设我们现在求得了在模 $x^{\frac{n}{2}}$ 意义下的解 $B_0(x)$，那么就有 $\frac{1}{B(x)}=\frac{1}{B_0(x)}+(\frac{1}{B_0(x)})’(B(x)-B_0(x))$，我们知道 $(\frac{1}{B_0(x)})’=-\frac{1}{B_0^2(x)}$，那么把 $\frac{1}{B(x)}-A(x)\equiv 0</del>(<del>{\rm mod}</del>x^{n})$ 中的 $\frac{1}{B(x)}$ 换成上面右边的那一坨，然后稍加整理一下就有 $B(x)\equiv 2B_0(x)-A(x)B_0^2(x)<del>(</del>{\rm mod}~x^n)$ 。直接这么倍增处理即可，复杂度是 $O(n\log n)$ 的。因为相对于最后一次来说，前面的若干次可以忽略不计。</p>
<h5 id="除法和取模"><a href="#除法和取模" class="headerlink" title="除法和取模"></a>除法和取模</h5><p>$A(x)=B(x)\times C(x)+D(x)$，其中 $A(x)$ 是 $n$ 次多项式，$B(x)$ 是 $m$ 次多项式，$m&lt;n$，给出 $A(x),B(x)$，求 $C(x),D(x)$。</p>
<p>显然，$C(x)$ 的次数是 $n-m$，$D(x)$ 的次数最大是 $m-1$，就把它看做是 $m-1$ 项，高位不足就补零。</p>
<p>先换元，把等式两边的 $x$ 换做 $\frac{1}{x}$，然后再在两边同时乘上 $x^n$，就有 $A(\frac{1}{x})\times x^n=B(\frac{1}{x})\times x^{m}\times C(\frac{1}{x}) \times x^{n-m}+D(\frac{1}{x})\times x^{m-1}\times x^{n-m+1}$，根据上述的翻转式子，就是 $A^R(x)=B^R(x)\times C^R(x)+D^R(x)\times x^{n-m+1}$ 。前面已经说了 $C(x)$ 的次数是 $n-m$，那么等式模去 $x^{n-m+1}$ 并不会对 $C(x)$ 有任何损失，所以就有 $A^R(x)\equiv B^R(x)\times C^R(x)<del>({\rm mod}</del>x^{n-m+1})$，对 $B^R(x)$ 求个逆元乘上就可以得到 $C^R(x)$，翻转一下就是 $C(x)$，然后就可以通过 $A(x)-B(x)\times C(x)$ 得到 $D(x)$。复杂度 $O(n\log n)$。</p>
<h5 id="ln-和-exp"><a href="#ln-和-exp" class="headerlink" title="ln 和 exp"></a>ln 和 exp</h5><p>因为积分是求导的逆运算，所以一个多项式先求导再积分，多项式不变。</p>
<p>那么对于 ln，就可以先求导再积分来求。即 $\ln F(x)=\int_0^n(\ln F(x))’<del>{\rm dx}$，前面已经提到了复合函数求导，所以就有 $\ln F(x)=\int_0^n\frac{F’(x)}{F(x)}</del>{\rm dx}$ 。复杂度 $O(n \log n)$。</p>
<p>对于 exp，它是 ln 的逆运算，考虑用牛顿迭代求。设 $B(x)=e^{A(x)}$，那么就有 $\ln B(x)-A(x)=0$，假设我们现在求得了在模 $x^{\frac{n}{2}}$ 意义下的解 $B_0(x)$，那么就有 $\ln B(x)=\ln B_0(x)+\ln’B_0(x)(B(x)-B_0(x))$，上文已有 $ln’B_0(x)=\frac{1}{B_0(x)}$，把这个 $\ln B(x)$ 带回原式中去，整理一下就有 $B(x)\equiv B_0(x)(A(x)+1-\ln B_0(x))<del>(</del>{\rm mod}~x^n)$。直接倍增求即可，复杂度也是 $O(n\log n)$。</p>
<h5 id="开根"><a href="#开根" class="headerlink" title="开根"></a>开根</h5><p>对于一个多项式 $A(x)$，求出一个 $B(x)$，使得 $B^2(x)\equiv A(x)<del>(</del>{\rm mod}~x^n)$。</p>
<p>仍然可以使用牛顿迭代法求，假设我们现在求得了在模 $x^{\frac{n}{2}}$ 意义下的解 $B_0(x)$，那么就有 $B^2(x)=B_0^2(x)+(B_0^2(x))’(B(x)-B_0(x))$。类似的，整理之后就有 $B(x)\equiv \frac{A(x)}{2B_0(x)}+\frac{B_0(x)}{2}<del>(</del>{\rm mod}~x^n)$ 。复杂度是 $O(n \log n)$ 的。</p>
<h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><h5 id="分治-FFT"><a href="#分治-FFT" class="headerlink" title="分治 FFT"></a>分治 FFT</h5><p>分治 FFT 可以用来干两种事情。</p>
<p>一种是要把一堆多项式要乘起来，如果直接一个一个乘的话复杂度最坏是 $O(n^2\log n)$ 的，而如果每次对半分，左右分别计算然后再卷积一次，单层的复杂度就是 $O(n\log n)$ 的，一共 $O(\log n)$ 层，总复杂度 $O(n\log^2 n)$。</p>
<p>还有一种是需要求一个多项式的时候，前面的项对后面的项有影响，那么就可以用 CDQ 分治的思想，先算前面的，然后算前面对后面的贡献，最后再算后面的，复杂度 $O(n \log^2 n)$。</p>
<h5 id="任意模数-NTT"><a href="#任意模数-NTT" class="headerlink" title="任意模数 NTT"></a>任意模数 NTT</h5><p>有两种方法，三模数 NTT 和 拆系数 MTT。</p>
<p>三模数 NTT，就如它的名字，选三个 NTT 模数，分别做一遍 NTT 最后用 CRT 合并。最后 CRT 求出来的一定是精确的值，所以需要保证最终的值在三个 NTT 模数的乘积以内。复杂度是 $O(n \log n)$，9 倍常数。</p>
<p>拆系数 MTT，也如它的名字，就是把每个数 $X$ 拆成 $AM+B$ 的形式，那么如果有两个多项式 $AM+B$ 和 $CM+D$ 相乘，最后的结果就是 $ACM^2 + (AD+BC)M+BD$，最后乘出来的结果是 $M^2{\rm len}$，一般情况下可以跑 FFT，用 long double 存。复杂度是 $O(n\log n)$，7 倍常数。</p>
<h5 id="多点求值"><a href="#多点求值" class="headerlink" title="多点求值"></a>多点求值</h5><p>对于一个多项式 $F$，给出一些 $z_i$，需要求出 $F(z_i)$ 的值。</p>
<p>对于求出 $F(z_i)$，我们可以这么做：次数从高到低扫这个多项式，然后把当前项的一个 $x$ 展开成 $z_i$（即对于 $ax^k$，把它展开成 $ax^{k-1}z_i$，然后把它累加到 $x^{k-1}$ 项中去），最后在常数项的那个值就是 $F(z_i)$。可以发现，这个过程实际上就是对 $x-z_i$ 取模。</p>
<p>在自然数集中，有 $X<del>{\rm mod}</del>BC<del>{\rm mod}</del>B = X<del>{\rm mod}</del>B$，其实在多项式中也是这样。</p>
<p>所以可以考虑分治。在分治的过程中，把 $F$ 对 $\prod_{i=l}^r (x-z_i)$ 取模，最后递归到叶子节点的时候，当前的多项式就只剩下常数项，就是需要求的 $F(z_i)$。</p>
<p>考虑发现复杂度，一开始需要求得 $\prod_{i=l}^r (x-z_i)$ ，分治 FFT 解决。之后需要分治求解，在每一层，多项式的长度都是 $O({\rm len})$，所以每层的总长是 $O(n)$ 的，一共有 $O(\log n)$ 层。所以总复杂度是 $O(n \log^2 n)$ ，常数巨大。</p>
]]></content>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>广义二项式定理</title>
    <url>/2020/09/26/%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>提前介绍一下广义的组合数，组合数 $\tbinom{n}{m}$ 的定义是 $\frac{n\times (n-1)\times … \times (n-m+1)}{m!}$，广义下的组合数只需要保证 $m$ 为非负整数，$n$ 可以是任意实数。</p>
<a id="more"></a>

<p>对于广义的组合数，有个恒等式 $\tbinom{n}{m}=\tbinom{m-n-1}{m}\times (-1)^{m}$ 。</p>
<blockquote>
<p>两式的分母都是一样的，对于左式，其分子是 $n\times (n-1)\times … \times (n-m+1)$，对于右式，其分子是 $(m-n-1)\times ((m-n-1)-1) \times … \times ((m-n-1)-m+1)$，可以发现右式分子的每个单项式和左式分子的单项式一一对应，并且互为相反数，那么最后乘上一个 $(-1)^m$ 即可。</p>
</blockquote>
<p>有个很妙的记忆方法：两级反转（和艾克真的一点关系都没有 /doge）连续变化两次，设未知数，下标不变，上标用 $m-1$ 去减，即：$\tbinom{n}{m}=\tbinom{m-?-1}{m}\times (-1)^{2m}$，那么可以很快得出问号是 $m-n-1$ 。当然直接用上文的证明去推更 nice。</p>
<p>广义二项式定理： $(a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i$ 这里的 $k$ 可以是任意实数，一般会用在 $k$ 为负整数的时候，那么我们在下面约定所有出现的 $k$ 都是<strong>负整数</strong>，且为了方便理解，设 $n=-k$。</p>
<p>考虑用生成函数去解释，先把 $(a+b)^{k}$ 看成 $(a+bx)^{k}$ 那么最后只要把 $x$ 看成 $1$ 即可。</p>
<p>先考虑最基本的情况：$(1-x)^{-n}$ 。</p>
<p>根据数学知识可以知道上式就是 $\left( (1-x)^{-1} \right)^{n}$ 。</p>
<p>根据生成函数，可以知道 $(1-x)^{-1}=\sum_{i=0}^{\infty} x^i$ 。</p>
<blockquote>
<p>设 $S=1+x+x^2+…$，那么 $xS=x+x^2+x^3+…$，那么 $S-xS=1$，所以 $S=\frac{1}{1-x}$ 即 $ (1-x)^{-1}$</p>
</blockquote>
<p>那么 $\left( (1-x)^{-1} \right)^{n}=\left( \sum_{i=0}^{\infty} x^i \right)^{n}$ 。 </p>
<p>考虑从组合意义上去计算这个式子：你有 $n$ 种球，每种球无限个，你需要从这 $n$ 种球中选择一共 $i$ 个球，每种球至少选 $0$ 个，其方案数就是 $x^i$ 的系数。那么使用隔板法就有 $\tbinom{i+n-1}{n-1}$ 。</p>
<p>所以 $\left( (1-x)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}x^i$ 。</p>
<p>那么我们再在 $x$ 前面加上一个系数 $p$ ，即求 $(1-px)^{-1}$ 。它是等于 $\sum_{i=0}^{\infty} p^ix^i$ 。</p>
<blockquote>
<p>设 $S=1+px+p^2x^2+…$ ，那么 $pxS=px+p^2x^2+p^3x^3+…$，那么 $S-pxS=1$，所以 $S=\frac{1}{1-px}$ 即 $(1-px)^{-1}$ 。</p>
</blockquote>
<p>那再按照上面的方法去推，就有 $\left( (1-px)^{-1} \right)^{n}=\sum_{i=0}^{\infty}\tbinom{i+n-1}{n-1}p^ix^i$ </p>
<p>回到一开始的问题，$(a+bx)^k=a^k \left( 1-(-\frac{b}{a}x) \right)^k$ 。</p>
<p>那么就有 $(a+bx)^k=a^k \sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-\frac{b}{a})^ix^i$ 。整理一下，$\sum_{i=0}^{\infty} \tbinom{i-k-1}{-k-1}(-1)^ia^{k-i}b^ix^i$ 。</p>
<p>注意了，这里等式内部的组合数的 $k$ 前面都带个负号，因为上文在推导过程中，设的是 $n=-k$，所以在组合数中的 $n$ 才是正号。</p>
<p>再根据文首提及的那个恒等式，就有 $\tbinom{i-k-1}{-k-1}=\tbinom{i-k-1}{i}=\tbinom{k}{i}\times (-1)^i$ 。</p>
<p>可以发现两个 $(-1)^i$ 抵掉了，那么 $(a+bx)^k=\sum_{i=0}^{\infty} \tbinom{k}{i}a^{k-i}b^ix^i$ 。</p>
<p>把 $x=1$ 带入原式，即可得  $(a+b)^{k}=\sum_{i=0}^{\infty}\tbinom{k}{i}a^{k-i}b^i$ 。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数学习笔记</title>
    <url>/2020/09/26/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="下降幂和上升幂"><a href="#下降幂和上升幂" class="headerlink" title="下降幂和上升幂"></a>下降幂和上升幂</h4><p>$x$ 的 $k$ 次下降幂记作 $x^{\underline{k}}$，表示的是 $\prod_{i=0}^{k-1}(x-i)$ 。</p>
<p>$x$ 的 $k$ 次上升幂记作 $x^{\overline{k}}$，表示的是 $\prod_{i=0}^{k-1}(x+i)$。</p>
<a id="more"></a>

<h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><p>$\begin{bmatrix} n \ i \end{bmatrix}$ 表示第一类斯特林数，它的意义是把 $n$ 个有标号的点放入 $i$ 个圆排列的方案数。圆排列不能为空。</p>
<p>第一类斯特林数有一个递推式，$\begin{bmatrix} n \ i \end{bmatrix}=\begin{bmatrix} n-1 \ i \end{bmatrix}\times(n-1)+\begin{bmatrix} n-1 \ i-1 \end{bmatrix}$，即考虑最后一个点放在哪里，要么是新开一个圆排列，要么就跟在某个数的后面。</p>
<h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><p>$\begin{Bmatrix}n \ i\end{Bmatrix}$ 表示第二类斯特林数，它的意义是把 $n$ 个有标号的点放入 $i$ 个无标号的集合的方案数。集合不能为空。</p>
<p>第二类斯特林数有一个递推式，$\begin{Bmatrix}n \ i\end{Bmatrix}=\begin{Bmatrix}n-1 \ i\end{Bmatrix}\times i+\begin{Bmatrix}n-1 \ i-1\end{Bmatrix}$，即考虑最后一个点放在哪里，要么是新开一个集合，要么就放在之前的某个集合里面。</p>
<h4 id="斯特林数和自然幂、下降幂、上升幂的关系"><a href="#斯特林数和自然幂、下降幂、上升幂的关系" class="headerlink" title="斯特林数和自然幂、下降幂、上升幂的关系"></a>斯特林数和自然幂、下降幂、上升幂的关系</h4><p>对于自然幂和下降幂，有这么一个式子。$n^m=\sum_{i=0}^m\begin{Bmatrix}m \ i\end{Bmatrix}n^{\underline{i}}$。</p>
<p>考虑从组合意义来理解它。$n^m$ 相当于是把 $m$ 个有标号的球放入 $n$ 个有标号的盒子的方案数，考虑枚举有多少个盒子有球，假设为 $i$，那么选盒子的方案就是 $\begin{pmatrix}n \ i\end{pmatrix}$，然后把 $m$ 个球放到这 $i$ 个盒子里面去，方案是 $\begin{Bmatrix}m \ i\end{Bmatrix}$，而因为第二类斯特林数的集合是无标号的，这里是有标号的，所以最后需要乘上一个 $i!$，然后把组合数展开，就得到上面的那个式子。</p>
<p>对于自然幂和上升幂，有这么一个式子。$n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \ i\end{bmatrix}n^i$ 。</p>
<p>考虑用数学归纳法来证明它，对于 $m=0$ 式子显然成立，假设现在已经证明对于 $m\leq k-1$ 式子成立，需要证明对于 $m=k$ 式子成立。<br>$$<br>n^{\overline{k}}=n^{\overline{k-1}}\times(n+k-1)<del>\<br>=n^{\overline{k-1}}\times n+n^{\overline{k-1}}\times(k-1)</del>\<br>=\sum_{i=0}^{k-1}\begin{bmatrix}k-1 \ i\end{bmatrix}n^{i+1}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \ i\end{bmatrix}n^i<del>\<br>=\sum_{i=1}^{k-1}\begin{bmatrix}k-1 \ i-1\end{bmatrix}n^{i}+\sum_{i=0}^{k-1}(k-1)\begin{bmatrix}k-1 \ i\end{bmatrix}n^i</del>\<br>=\sum_{i=0}^k\begin{bmatrix}k \ i\end{bmatrix}n^i<del>~</del><br>$$<br>故可以证明原式子成立。</p>
<h4 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h4><h5 id="反转公式-I"><a href="#反转公式-I" class="headerlink" title="反转公式 I"></a>反转公式 I</h5><p>$x^{\overline{k}}=(-1)^k(-x)^{\underline{k}}$，$x^{\underline{k}}=(-1)^k(-x)^{\overline{k}}$。</p>
<p>这两个式子把它们拆开就可以证明相等了。</p>
<h5 id="反转公式-II"><a href="#反转公式-II" class="headerlink" title="反转公式 II"></a>反转公式 II</h5><p>$\sum_{i=m}^n(-1)^{n-i}\begin{bmatrix}n \ i\end{bmatrix}\begin{Bmatrix}i \ m\end{Bmatrix}=[m==n]$</p>
<p>$\sum_{i=m}^n(-1)^{n-i}\begin{Bmatrix}n \ i\end{Bmatrix}\begin{bmatrix}i \ m\end{bmatrix}=[m==n]$</p>
<p>对于第二个证明如下：<br>$$<br>n^m=\sum_{i=0}^m\begin{Bmatrix}m \ i\end{Bmatrix}n^{\underline{i}}<del>\<br>=\sum_{i=0}^m\begin{Bmatrix}m \ i\end{Bmatrix}(-1)^i(-n)^{\overline{i}}</del>\<br>=\sum_{i=0}^m\begin{Bmatrix}m \ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix} i \ j \end{bmatrix}(-n)^j\<br>=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m \ i\end{Bmatrix}\begin{bmatrix} i \ j \end{bmatrix}(-1)^{i-j}<del>~</del>\<br>$$<br>把 $n$ 看成是一个未知数时，对于一个多项式 $\sum a_in^i$，$n^m$ 可以且仅可以用 $a_mn^m$ 来表示，所以最后的式子只有 $j=m$ 的时候为 $1$，否则为 $0$。</p>
<p>对于第一个式子，有 $n^{\overline{m}}=\sum_{i=0}^m\begin{bmatrix}m \ i\end{bmatrix}(-1)^i(-n)^i$，把后面的自然幂展开成下降幂，然后再推一推就可以类似于上面讨论证明。</p>
<h5 id="斯特林反演公式"><a href="#斯特林反演公式" class="headerlink" title="斯特林反演公式"></a>斯特林反演公式</h5><p>$f(n)=\sum_{i=0}^n\begin{Bmatrix}n \ i\end{Bmatrix}g(i)\Leftrightarrow g(n)=\sum_{i=0}^n(-1)^{n-i}\begin{bmatrix}n \ i\end{bmatrix}f(i)$。</p>
<p>和二项式反演类似，只需要证明一个方向，另一个方向显然成立。</p>
<p>正向证明如下：<br>$$<br>g(n)=\sum_{i=0}^n[i==n]g(i)<del>\<br>=\sum_{i=0}^n\sum_{j=i}^n(-1)^{n-j}\begin{bmatrix}n \ j\end{bmatrix}\begin{Bmatrix}j \ i\end{Bmatrix}g(i)\<br>=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \ j\end{bmatrix}\sum_{i=0}^j\begin{Bmatrix}j \ i\end{Bmatrix}g(i)\<br>=\sum_{j=0}^n(-1)^{n-j}\begin{bmatrix}n \ j\end{bmatrix}f(j)</del><br>$$</p>
<h4 id="第一类斯特林数求自然数幂和"><a href="#第一类斯特林数求自然数幂和" class="headerlink" title="第一类斯特林数求自然数幂和"></a>第一类斯特林数求自然数幂和</h4><p>设 $\sum_{i=1}^n i^k$ 为 $S_k(n)$。<br>$$<br>\because n^m=\sum_{i=0}^m\begin{Bmatrix}m \ i\end{Bmatrix}n^{\underline{i}}<del>\<br>\therefore n^{\underline{m}}=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}n^i</del>\<br>\therefore n^m=n^{\underline{m}}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}n^i<del>\<br>\therefore \sum_{n=1}^X n^m=\sum_{n=1}^Xn^{\underline{m}}-\sum_{n=1}^X\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}n^i</del>\<br>\therefore S_m(X)=m!\sum_{n=1}^X\begin{pmatrix}n \ m\end{pmatrix}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}\sum_{n=1}^Xn^i<del>\<br>=m!\begin{pmatrix}X+1 \ m+1\end{pmatrix}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}S_i(X)\<br>=\frac{(X+1)^{\underline{m+1}}}{m+1}\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m \ i\end{bmatrix}S_i(X)</del>\<br>$$<br>故 $S_m(X)$ 可以在 $m^2$ 的时间复杂度内求得，且不要求模数是质数。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数优化矩阵快速幂</title>
    <url>/2020/09/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>如果我们需要求维度为 $c$ 的矩阵 $A$ 的 $m$ 次幂，那么一个显然的方法是用快速幂，复杂度为 $c^3 \log m$。不过当需要用到高精度的时候，该算法速度会大大下降。</p>
<p>考虑这么一个事情，<a id="more"></a> 如果可以找到一个矩阵 $C$ 和一个对角矩阵 $P$（只有主对角线上的值不为 $0$），使得 $A=C\times P \times C^{-1}$，那么 $A^m=C\times P \times C^{-1} \times C \times P \times C^{-1}…$，不断的使用结合率，就可以得到 $C \times P^m \times C^{-1}$。因为 $P$ 是对角矩阵，那么 $P^m$ 本质上只要对 $P$ 中的每个值跑一个实数的快速幂。这样就可以把复杂度优化到 $c^3+c\log n$，即实数的快速幂和两次矩阵乘法。</p>
<p>现在的问题就是怎么得到一个合法的 $C$。</p>
<p>引入两个概念：特征值和特征向量。</p>
<p>一个数 $\lambda$ 是矩阵 $A$ 的特征值，当且仅当存在一个非 $0$ 向量 $B$，使得 $A\times B=\lambda B$，我们把这个向量 $B$ 称作特征向量。需要注意的是，对于同一个 $\lambda$，$B$ 可能不止一个。</p>
<p>如果我们求出了一组特征值 $\lambda_1,\lambda_2…\lambda_c$，以及对应的特征向量 $B_1,B_2…B_c$，那么就有 $A\times [B_1,B_2…B_c]=[\lambda_1\cdot B_1,\lambda_2\cdot B_2…\lambda_c\cdot B_c]$，设 $C=[B_1,B_2…B_c]$，右乘一个对角矩阵相当于每一列 $i$ 乘上一个对角阵中的元素 $a_{i,i}$，所以可以构造对角矩阵 $P=\begin{bmatrix} \lambda_1 &amp; 0 &amp; \cdots&amp;0\ 0 &amp; \lambda_2 &amp; \cdots&amp;0\ \vdots &amp; \vdots&amp;\ddots&amp;\vdots \ 0&amp;\cdots&amp;0&amp;\lambda_c\end{bmatrix}$，就可以得到 $A\times C=C\times P\Leftrightarrow A=C\times P\times C^{-1}$ 。</p>
<p>考虑怎么求特征值，因为 $A\times B=\lambda B$ 那么就有 $\lambda B-A\times B=0$，所以 $(\lambda I-A)\times B=0$，因为 $B$ 向量非 $0$，所以必须有 $\det(\lambda I-A)=0$，那么可以通过行列式列方程求得 $\lambda$。</p>
<p>考虑使用反证法证明 $\det(\lambda I-A)=0$。设 $G=\lambda I-A$，那么如果 $\det(G)\not=0$，那么如果把 $G$ 看作是一个方程组的系数矩阵，$B$ 为未知数，那么 $B$ 将会是唯一的。而因为等式右边等于 $0$ ，所以无论如何用高斯消元，最后总会有 $B_c=0$，那么一直往回迭代就会得到一个全 $0$ 向量，与 $B$ 向量非 $0$ 冲突。而如果 $det(G)=0$，那么 $G$ 至少有一个自由元，那么就可以通过自由元，得到至少一个非 $0$ 向量 $B$。</p>
<p>由此我们就可以求出所有的特征值，对于某个特征值，把它带回矩阵，通过初等矩阵的行变换把它变成一个最简形式，然后把自由元带入任意一个值（一般为 $1$）就可以得到一个特征向量 $B$（当然对于任意的 $k\cdot B,k\not=0$ 都是符合要求的）。</p>
<p>至此就可以得到所有的特征值及其对应的特征向量。那么就可以得到矩阵 $C$，求个逆就可以得到 $C^{-1}$（消元可以用辗转相除法，就可以避免求逆元），就可以用上述做法优化了。</p>
<p>下面就举个栗子，用此方法得到斐波那契数列的通项公式。</p>
<p>众所周知，斐波那契数列的递推矩阵是 $ A=\begin{bmatrix} 1 &amp; 1 \ 1 &amp; 0 \ \end{bmatrix}$ 。</p>
<p>先求出该矩阵的特征值，设其为 $\lambda$，根据定义，有 $ \det \left ( \begin{bmatrix} \lambda - 1 &amp; -1 \ -1 &amp; \lambda \ \end{bmatrix} \right)  = 0$ ，所以 $(\lambda-1)\times \lambda-1=0$，解出 $\lambda=\frac{1\pm\sqrt{5}}{2}$ 。</p>
<p>再根据定理，列出方程 $ \begin{bmatrix} \lambda - 1 &amp; -1 \ -1 &amp; \lambda \ \end{bmatrix}  \begin{bmatrix} x_0 \ x_1 \ \end{bmatrix}=\begin{bmatrix} 0 \ 0 \ \end{bmatrix}$ 可以解出两个特征向量 $\lambda_1=\frac{1-\sqrt{5}}{2}$ 对应 $B_1=\begin{bmatrix} 1 \ \frac{-1-\sqrt{5}}{2} \ \end{bmatrix}$，$\lambda_2=\frac{1+\sqrt{5}}{2}$ 对应 $B_2=\begin{bmatrix} 1 \ \frac{-1+\sqrt{5}}{2} \ \end{bmatrix}$ 。那么根据定义，设 $C=[B_1,B_2]$，构造对角阵 $P=\begin{bmatrix} \lambda_1 &amp; 0 \ 0 &amp; \lambda_2 \ \end{bmatrix} $，就可以得到 $A\times C=C\times P$，所以有 $A=C\times P \times C^{-1}$。故 $A^m=C\times P^m \times C^{-1}$。</p>
<p>通过手算可以求得 $C^{-1}= \begin{bmatrix} 1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; -\frac{\sqrt{5}}{5}  \ \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5} &amp; \frac{\sqrt{5}}{5}  \ \end{bmatrix}$。</p>
<p>对于斐波那契数列第 $m$ 项，即是 $A^m$ 的 $a_{1,1}$。显然 $P^m=\begin{bmatrix} (\frac{1-\sqrt{5}}{2})^m &amp; 0 \ 0 &amp; (\frac{1+\sqrt{5}}{2})^m \ \end{bmatrix}$ ，那么 $C\times P^m \times C^{-1}$ 的 $a_{1,1}$ 为 $(\frac{1-\sqrt{5}}{2})^m\times(1-\frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5})+(\frac{1+\sqrt{5}}{2})^m\times \frac{1+\sqrt{5}}{2}\times \frac{\sqrt{5}}{5}$，整理之后就为 $\frac{1}{\sqrt{5}}\left((\frac{1+\sqrt{5}}{2})^{m+1}-(\frac{1-\sqrt{5}}{2})^{m+1}\right)$ ，即为斐波那契数列的通项公式。</p>
<p>因为出现了根号，所以整个过程看似比较麻烦，不过在递推矩阵满足一些性质的时候有较快的方法求特征值和特征向量（比如在整个矩阵是一个上/下三角矩阵时，特征值就是主对角线上的值，自由元就是项数变少了某行，设它为 $1$，就可以在矩阵大小的复杂度内求得一个特征向量）。</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
</search>
